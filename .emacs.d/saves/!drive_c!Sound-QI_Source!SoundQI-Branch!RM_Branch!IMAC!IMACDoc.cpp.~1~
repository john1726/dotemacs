// IMACDoc.cpp : implementation of the CIMACDoc class
//

#include "stdafx.h"
#include "IMAC.h"

#include "IMACDoc.h"
#include "IMACView.h"
#include "XplotParms.h"
#include "NewPathDlg.h"
#include "ParmToolDlg.h"
#include "CSIViewParmDlg.h"
#include "SegyOutDlg.h"
#include "../common/ProgressDlg.h"
#include "../common/cppTemplate.h"
#include "../common/SegyUtil.h"
#include "../common/CUtil.h"
#include "../common/CppUtil.h"
#include <direct.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#endif

static UINT __cdecl SingleThreadTask(LPVOID pParm);
void __cdecl BeginThreadTask(void *pArg);

/////////////////////////////////////////////////////////////////////////////
// CIMACDoc

IMPLEMENT_DYNCREATE(CIMACDoc, CDocument)

BEGIN_MESSAGE_MAP(CIMACDoc, CDocument)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CIMACDoc construction/destruction

CIMACDoc::CIMACDoc()
{
	GenerateNewPallet();
	GenerateDensityColorBar();
	m_pHorizon = NULL;
	m_histoData.SetSize(MAXCLASS);
	m_histoFlag.SetSize(MAXCLASS);
	m_pMapSelectDlg = NULL;
	m_nFile = 0;
	m_trackInline = 0;
	m_trackXline  = 0;
	m_userLineDataArray.SetSize(0, 1000);
	m_userLineNameArray.SetSize(0, 1000);
    m_userLineSmoothedCoordinateArray.SetSize(0, 1000);
	m_userLineSelected = 0;
	m_arrClassNames.SetSize(MAXCLASS);
	m_bShowFilelist = TRUE;
	m_bDragMode = FALSE;
	m_hCustomCursor = NULL;
	pCursorAND = NULL;
	pCursorXOR = NULL;
	m_bSourceCursorFlag = FALSE;
	m_bTargetCursorFlag = FALSE;
	m_outputState = FALSE;
    // Attribute Advisor
    m_AAEllipseData.SetSize(1000, 1000);
    m_AAEllipseCount = 0;
    m_AARegion1Data.SetSize(1000, 1000);
    m_AARegion2Data.SetSize(1000, 1000);
    m_AARegionCount = 0;
    m_AASelectedAttributeCount = 0;

	for (int i = 0; i < NFILE; i++) {
		m_Segy[i] = new CSegy;
	}

	// CSI...
	GenerateNewPallet();
	// make a r-w-b default color bar
	for (int i = 0; i<MAXCBSIZE; i++) m_colorbar[i] = NOCOLOR;
	m_cbSize = 21;
	m_colorbar[0] = RGB(255, 0, 0);
	m_colorbar[10] = RGB(255, 255, 255);
	m_colorbar[20] = RGB(0, 0, 255);
//	InterpolateColorbar();
	m_ampList = NULL;
	m_ampListSize = 0;
	m_ampListAllocSize = 0;
	m_pColorMapWnd = NULL;
	m_bMinimizeColorMap = TRUE;
	m_colorbarOpenedFromCSI = FALSE;

	m_arrDynamicSliders = NULL;
	m_nDynamicSliders = 0;
	m_bUpdateSliderEnabledFlag = TRUE;
	m_bShowCSIPane = FALSE;
	m_bIMACMode = TRUE;
	m_bCSIMode = FALSE;
	m_minimizedFlag = 0;
	m_viewInstance = -1;
    m_suppressPolygonMessages = FALSE;
    m_suppressEllipseMessages = FALSE;

	// allocate some memory for thread data.  This only has to be done once to prevent memory fragmentation.
	SYSTEM_INFO sysInfo;
	GetSystemInfo(&sysInfo);
	m_numberOfProcessors = sysInfo.dwNumberOfProcessors;
	if (m_numberOfProcessors <= 0) m_numberOfProcessors = 1;
	handles = new HANDLE[m_numberOfProcessors];
	pThreads = new CWinThread*[m_numberOfProcessors];
	taskparm = new PTS_DENSITY_PARM[m_numberOfProcessors];
	nodeparm = new NODE_DENSITY_PARM[m_numberOfProcessors];
	vvparm = new VIRTUAL_VOLUME_PARM[m_numberOfProcessors];
	GenerateThirdAttributeColorbar();


	m_parmToolDataArray.SetSize(100, 100);
	m_pMainView = NULL;
	m_pCSIView = NULL;
	m_pColorBarView = NULL;

	m_arrExportAttributeNames.RemoveAll();
	m_arrExportFileNames.RemoveAll();

	m_lastSuccessfulExportedFile.Empty();
	m_bLastExportedFileReadyFlag = false;
    m_petrelProjectPath.Empty();

	m_projectUnits = eUNDEF_UNITS;
	m_seiswareProjectFlag = FALSE;
}


CIMACDoc::~CIMACDoc()
{
	for (int i=0; i<NFILE; i++) {
		delete m_Segy[i];
	}
	DestroyWellData();
	if (m_pHorizon) {
		m_pHorizon->DestroyData();
		delete m_pHorizon;
	}
	if (m_pMapSelectDlg) {
		m_pMapSelectDlg->DestroyWindow();
		delete m_pMapSelectDlg;
	}

	// destroy the user line
    for (int i = 0; i < m_userLineDataArray.GetCount(); i++) {
        CPointArray *pData = (CPointArray *)m_userLineDataArray[i];
        if (pData) {
            pData->RemoveAll();
            delete pData;
        }
    }
    for (int i = 0; i < m_userLineSmoothedCoordinateArray.GetCount(); i++) {
        CDoublePointArray *pDoubleData = (CDoublePointArray *)m_userLineSmoothedCoordinateArray[i];
        if (pDoubleData) {
            pDoubleData->RemoveAll();
            delete pDoubleData;
        }
    }
	m_userLineDataArray.RemoveAll();
	m_userLineNameArray.RemoveAll();
    m_userLineSmoothedCoordinateArray.RemoveAll();

	m_viewZoneArray.RemoveAll();

	DestroySeisParmList();
	DestroyVolTypeList();

	// destroy the dynamic sliders.
	for (int i = 0; i<m_nDynamicSliders; i++) {
		if (m_arrDynamicSliders[i]) {
			m_arrDynamicSliders[i]->DestroyData();
			delete m_arrDynamicSliders[i];
		}
	}
	if (m_arrDynamicSliders) delete m_arrDynamicSliders;

	// destroy the AA regions.
	DestroyAARegions();
	DestroyAAEllipses();

	delete [] handles;
	delete [] pThreads;
	delete [] taskparm;
	delete [] nodeparm;
	delete [] vvparm;

	if (m_ampList) delete m_ampList;

}

BOOL CIMACDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	InitWellDatabase();

	DestroySeisParmList();
	for (int i=0; i<NFILE; i++) {
		m_arrAttributePaths[i] = "";
		m_favorite[i] = 0;
	}
	m_nClass = 10;
	m_nFile = 0;
	m_nXplot = 0;
	m_rcClassifiedWin = CRect(0, 0, 0, 0);
	m_rcParentWin = CRect(0, 0, 0, 0);
	
	int ix=0;
	for (int i=0; i<MAXCLASS; i++){
		if (ix>=NCOL*NCOL*6) ix = i;
		m_colorbar[i]=m_pallet[ix];
		ix += NCOL*NCOL;
		m_histoData[i] = 0;
		m_histoFlag[i] = 0;
		if(i==0) {
			m_arrClassNames[i] = "Unclassified";
            m_colorbar[i] = RGB(190, 190, 190); // unclassified is grey
		}
		else {
			m_arrClassNames[i].Format("Class %d", i);
		}
	}
	GenerateThirdAttributeColorbar();

	m_nHscale=25;
	m_nDisplayInline=0;
	m_nDisplayXline=0;
    m_nDisplayUserline = 0;
	m_nStartTime=INT_MIN;
	m_nEndTime=INT_MAX;
	m_fVscale=10.0;
	m_10msTLineMode=FALSE;
	m_100msTLineMode = TRUE;
	m_500msTLineMode = TRUE;
	m_cursorPositionMode=FALSE;
	m_selectColor1 = RGB(255, 255, 255);
	m_selectColor2 = RGB(255, 255, 255);
    m_highliteDotSize=1;
    m_highliteLine = 0;
    m_highliteLineMode = 0;
    m_initialSelect = FALSE;
    SetHighliteRegion1Null();
    SetHighliteRegion2Null();
	m_fWellWidth=0.5;
	m_fWellOffset=0.5;
	m_bWellBoldPen=TRUE;
	m_nColorTrackWidth=3;
	m_nDeviatedCurveView = eFLAT_CURVE_VIEW;
	m_fDeviationCurveWindowSize = 1.0f;
	m_flattenHorizonCheck = FALSE;
	m_flatteningDatum = 0;
	m_flatteningHorizon = "";
	m_flatteningUseAverage = TRUE;

	SetInlineXlineMode(eINLINE);

	m_bDrawFlag=FALSE;
	m_bReadyToCompute=FALSE;
	m_si=0;
	m_bNewColorFlag=0xffffffff;

	for (int i=0; i<NXPLOT; i++) {
		bMenuParms[i]=FALSE;
		bMenuXPlots[i]=FALSE;
		m_initializeXplotView[i]=FALSE;
		m_bUpdateXplotPane[i]=TRUE;
	}

	for (int i=0; i<NXPLOT+1; i++) {
		m_bReadyToDisplay[i] = TRUE;		// TRUE: Draw the image. FALSE: Use the memory DC.
	}
	for (int i=0; i<NXPLOT; i++) {
		m_pCrossPlotView[i]  = NULL;
	}

	m_strOutFile = "";
	m_outputState = FALSE;

	m_toolbarHeight = 0;

	if (m_pHorizon) {
		delete m_pHorizon;
	}
	m_pHorizon = new CHorizon;

	m_bDepthMode = FALSE;
	m_depthDatum = 0;

	m_10msLineLabels = FALSE;
	m_100msLineLabels = TRUE;
	m_500msLineLabels = TRUE;
	m_petrelTime = FALSE;
	m_petrelDatum = 0.0;
	m_labelInterval = 10;
	m_faciesHistogramMode = FALSE;
    m_attributeAdvisorMode = FALSE;

	m_pMapSelectDlg = NULL;
	m_mapSelectMode = FALSE;

	m_bInlineLR = TRUE;
	m_bXlineLR = TRUE;
	m_bUserlineLR = TRUE;
	m_bHighlightAll = TRUE;

	// destroy the user line
    for (int i = 0; i < m_userLineDataArray.GetCount(); i++) {
        CPointArray *pData = (CPointArray *)m_userLineDataArray[i];
        if (pData) {
            pData->RemoveAll();
            delete pData;
        }
    }
    for (int i = 0; i < m_userLineSmoothedCoordinateArray.GetCount(); i++) {
        CDoublePointArray *pDoubleData = (CDoublePointArray *)m_userLineSmoothedCoordinateArray[i];
        if (pDoubleData) {
            pDoubleData->RemoveAll();
            delete pDoubleData;
        }

	}
	m_userLineDataArray.RemoveAll();
	m_userLineNameArray.RemoveAll();
    m_userLineSmoothedCoordinateArray.RemoveAll();
	m_userLineSelected = 0;

	m_viewZoneArray.RemoveAll();

	m_whoHasFocus = -1;
	
	GetDefaultVolTypeList();
	BuildDefaultVirtualVolumes();

	// CSI...
	m_ampList = NULL;
	m_ampListSize = 0;
	m_ampListAllocSize = 0;
	m_pColorMapWnd = NULL;
	m_bMinimizeColorMap = TRUE;
	m_colorbarOpenedFromCSI = FALSE;

	m_arrDynamicSliders = NULL;
	m_nDynamicSliders = 0;
	m_bUpdateSliderEnabledFlag = TRUE;

	m_parmToolCount = 0;
	m_minimizedFlag = 0;
	m_pMainView = NULL;
	m_pCSIView = NULL;
	m_pColorBarView = NULL;
	m_viewInstance = -1;

	m_arrExportAttributeNames.RemoveAll();
	m_arrExportFileNames.RemoveAll();

	m_projectSaveAsName.Empty();

	m_lastSuccessfulExportedFile.Empty();
	m_bLastExportedFileReadyFlag = false;
    m_petrelProjectPath.Empty();

    m_AAEllipseCount = 0;

	// wiggle overlay
	m_wiggleInterpolationMode = 2;
	m_wiggleDrawingMode = 0;
	m_wiggleTraceExcursion = 1.5;
	m_wiggleSelectedAttribute = "";
	m_wiggleClassifiedVolumeCheck = FALSE;
	m_wiggleTraceClip = 3.0;
	m_wiggleTraceDecimation = 1;

	m_projectUnits = eUNDEF_UNITS;
	m_seiswareProjectFlag = FALSE;
	
	// headwave
	if (GetHeadwaveProjectFolder().IsEmpty()) {
		SetHeadwaveProjectFolder(HEADWAVE_PROJECT_FOLDER);
	}

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CIMACDoc serialization

void CIMACDoc::Serialize(CArchive& ar)
{
	int i;
	// The master ar file version. Increment this whenever a change is made to the file. 
	// This value will be used to check if a newer version of the program made the file.
	int nThisVersion = 80;
	double vers = QI_PRO_MAJOR_REVISION * 10000 + QI_PRO_MINOR_REVISION * 100 + QI_PRO_BUGFIX_REVISION;
	vers /= 10000;
	if (ar.IsStoring())
	{
		int nVersion = nThisVersion;
		ar << nVersion;
		ar << vers;
		ar << m_nFile;
		ar << m_nXplot;
		for (i=0; i<m_nFile; i++)
			ar << m_arrAttributePaths[i];

		for (i = 0; i < m_nFile; i++) {
			CSeisParms *pSeisParms = m_seisParmsList.GetAt(m_seisParmsList.FindIndex(i));
			pSeisParms->Serialize(ar);
		}

		// Volume list
		int volCount = (int) m_volTypeList.GetCount();
		ar << volCount;
		POSITION pos = m_volTypeList.GetHeadPosition();
		while (pos) {
			CVolType *pVolType = m_volTypeList.GetNext(pos);
			pVolType->Serialize(ar);
		}
		for (i = 0; i<m_nFile; i++)
			ar << m_favorite[i];
		for (i = 0; i < m_nFile; i++){
			ar << m_scanMinMax[i].min;
			ar << m_scanMinMax[i].max;
			ar << m_scanMinMax[i].bMinOverride;
			ar << m_scanMinMax[i].bMaxOverride;
		}
		for (i = 0; i<m_nFile; i++)
			GetSegyInPtr(i)->Serialize(ar);
		ar << m_nClass;
		for (i=0; i<m_nClass; i++) {
			ar << m_colorbar[i];
			ar << m_arrClassNames[i];
		}
		ar<<m_nHscale;
		ar<<m_fVscale;
		ar<<m_fWellWidth;
		ar<<m_fWellOffset;
		ar<<m_bWellBoldPen;
		ar<<m_nColorTrackWidth;
		ar<<m_nDisplayInline;
		ar<<m_nDisplayXline;
        ar<<m_nDisplayUserline;
		ar<<m_nStartTime;
		ar<<m_nEndTime;
		for (i=0; i<NXPLOT; i++)
			m_XplotParms[i].Serialize(ar);
		ar<<m_si;
		int tmp = 0;
		ar<<tmp;  // used to be nSamp. No longer needed.
		ar<<m_bDrawFlag;
		ar<<m_strOutFile;

		if (GetMainFrame()->IsFilelistPane()) {
			CRect tmpRect = m_rcClassifiedWin;
			tmpRect -= CPoint(FILEPANE_SIZE, 0);
			ar << tmpRect;
		}
		else {
			ar << m_rcClassifiedWin;
		}

		ar<<m_10msTLineMode;
		ar<<m_100msTLineMode;
		ar<<m_500msTLineMode;
		ar<<m_cursorPositionMode;
		ar<<m_inlineXlineMode;
        ar<<m_selectColor1;
        ar<<m_selectColor2;
        ar<<m_highliteDotSize;        
		AfxGetMainWnd()->GetWindowRect(m_rcParentWin);
		ar<<m_rcParentWin;

		ar << m_bDepthMode;
		ar << m_depthDatum;

		ar << m_10msLineLabels;
		ar << m_100msLineLabels;
		ar << m_500msLineLabels;
		ar << m_petrelTime;
		ar << m_petrelDatum;
		ar << m_labelInterval;
		ar << m_faciesHistogramMode;
		ar << m_mapSelectMode;
        ar << m_attributeAdvisorMode;
		ar << m_bInlineLR;
		ar << m_bXlineLR;
		ar << m_bUserlineLR;
		ar << m_bHighlightAll;
		ar << m_nDeviatedCurveView;
		ar << m_fDeviationCurveWindowSize;
		ar << m_flattenHorizonCheck;
		ar << m_flatteningDatum;
		ar << m_flatteningHorizon;
		ar << m_flatteningUseAverage;

		// serialize the master well list..
		WellList *pWellList = GetWellListPtr();
		int nCount = (int) pWellList->GetCount();
		ar << nCount;
		pos = pWellList->GetHeadPosition();
		while (pos) {
			CWell *pWell = pWellList->GetNext(pos);
			pWell->Serialize(ar);
		}
		// serialize the subset lists, if any.
		nCount = (int) m_wellSubListMgr.GetCount();
		ar << nCount;
		for (int i=0; i<nCount; i++) {
			m_wellSubListMgr.GetAt(m_wellSubListMgr.FindIndex(i))->Serialize(ar);
			ar << m_wellSubListNames.GetAt(m_wellSubListNames.FindIndex(i));
		}

		// serialize horizon data
		m_pHorizon->Serialize(ar);

		// serialize the time slice data
		m_timeSlice.Serialize(ar);

		// serialize the user lines
		int userLineCount = (int) m_userLineDataArray.GetCount();
		ar << userLineCount;
		if (userLineCount > 0) {
			ar << m_userLineSelected;
			for (int i=0; i<userLineCount; i++) {
				ar << m_userLineNameArray[i];
				CPointArray *pData = (CPointArray *) m_userLineDataArray[i];
				int iCount = (int)pData->GetCount();
				ar << iCount;
				for (int j=0; j<iCount; j++) {
					ar << pData->GetAt(j);
				}

                CDoublePointArray *pDoubleData = (CDoublePointArray *)m_userLineSmoothedCoordinateArray[i];
                iCount = (int)pDoubleData->GetCount();
                ar << iCount;
                for (int j = 0; j<iCount; j++) {
                    pDoubleData->GetAt(j).Serialize(ar);
                }
			}
		}

		// serialize viewZones
		nCount = (int)m_viewZoneArray.GetCount();
		ar << nCount;
		for (int i=0; i<nCount; i++) {
			m_viewZoneArray[i].Serialize(ar);
		}

		// serialize the virtual volume equations
		int vvCount = GetVVAttributeCount();
		ar << vvCount;
		for (int i = 0; i < vvCount; i++){
			CVVAttribute &vvAttr = GetVVAttributeRef(i);
			vvAttr.Serialize(ar);
		}

		ar << m_parmToolCount;
		for (int i = 0; i<m_parmToolCount; i++) {
			m_parmToolDataArray[i]->Serialize(ar);
		}
		for (int i = 0; i < NXPLOT*MAXCBSIZE; i++) {
			ar << m_thirdAttributeBar[i];
		}
		for (int i = 0; i < NXPLOT; i++) {
			ar << m_thirdAttributBarSize[i];
		}
        ar << m_suppressPolygonMessages;
        ar << m_suppressEllipseMessages;

        // Highlite regions
        CRect region = GetHighliteRegion1();
        ar << region;
        region = GetHighliteRegion2();
        ar << region;
        ar << m_highliteLine;
        ar << m_highliteLineMode;

        // Attribute advisor
        int aaCount = GetAASelectedAttributeCount();
        ar << aaCount;
        for (int i = 0; i < aaCount; i++) {
            CString aaName = GetAASelectedAttribute(i);
            ar << aaName;
        }
        CAADialogParms *pAADialogParms;
        CAADialogParms dialogParms;
        if (aaCount > 0) {
            pAADialogParms = GetAADialogParmsPtr();
        } else {
            pAADialogParms = &dialogParms;
        }
        pAADialogParms->Serialize(ar);

		// wiggle overlay
		ar << m_wiggleInterpolationMode;
		ar << m_wiggleDrawingMode;
		ar << m_wiggleTraceExcursion;
		ar << m_wiggleSelectedAttribute;
		ar << m_wiggleClassifiedVolumeCheck;
		ar << m_wiggleTraceClip;
		ar << m_wiggleTraceDecimation;

		ar << (int) m_projectUnits;
		ar << m_seiswareProjectFlag;

		// Classified volume toolbar toggles
		ar << m_horizonDisplayToggle;
		ar << m_wiggleDisplayToggle;
		ar << m_flatteningDisplayToggle;
		ar << m_wellDisplayToggle;
		ar << m_wellLogDisplayToggle;
		ar << m_wellTopDisplayToggle;
		ar << m_displayLinesDisplayToggle;

		// Head wave
		ar << GetHeadwaveProjectFolder();
		ar << GetHeadwaveOutputFolder();
	}
	else
	{
		int nVersion;
		ar >> nVersion;		// ar version info for application use
		if (nVersion>5) {
			ar >> vers;
			vers *= 10000;
			vers = round(vers);
		} else {
			vers = 0;
		}
		if (nVersion>nThisVersion) {
			CString strVersion;
			if (vers < 10) {
				// old encoding of the version number (it was not correctly done, missing the bugFix version)
				int major = (int)vers;
				int minor = (int)((vers - major) * 100);
				strVersion.Format("%d.%d", major, minor);
			} else {
				int major = (int)vers / 10000;
				int minor = (int)(vers / 100) - (major * 100);
				int bugFix = (int)(vers)-(minor * 100) - (major * 10000);
				strVersion.Format("%d.%d.%d", major, minor, bugFix);
			}
			CString msg("Cannot load this file. It was created with a newer version of the program. Version ");
			msg += strVersion;
			AfxMessageBox(msg);
			OnNewDocument();
			return;
		}
		ar >> m_nFile;
		ar >> m_nXplot;
		if (m_nFile) bMenuParms[0]=TRUE;
		for (i=0; i<m_nFile; i++) {
			ar >> m_arrAttributePaths[i];
		}

		// remove the existing SeisParm list and build a new one.
		DestroySeisParmList();
		for (i = 0; i < m_nFile; i++) {
			CSeisParms *pSeisParms = new CSeisParms;
			if (nVersion < 44) {
				CString tmp;
				ar >> tmp;
				pSeisParms->SetAttrName(tmp);
			} else {
				pSeisParms->Serialize(ar);
			}
			m_seisParmsList.AddTail(pSeisParms);
			m_arrAttributeNames[i] = pSeisParms->GetAttrName();
		}

		// remove and rebuild the Volume list
		if (nVersion >= 44){
			DestroyVolTypeList();
			GetDefaultVolTypeList();
			int nDefaultCount = (int)m_volTypeList.GetCount();
			int nCount;
			ar >> nCount;			
			for (int i = 0; i < nCount; i++) {
				CVolType volType;
				volType.Serialize(ar);
				// Check if the volume type is one of the default types
				BOOL bFound = FALSE;
				CVolType *pDef;
				for (int j = 0; j < nDefaultCount; j++) {
					pDef = m_volTypeList.GetAt(m_volTypeList.FindIndex(j));
					if (pDef->GetVolTypeName() == volType.GetVolTypeName()){
						bFound = TRUE;
						// copy the data with copy constructor
						*pDef = volType;
						pDef->SetRequired();
						break;
					}
				}
				if (!bFound) {
					// create new node on the list
					CVolType *pVol = new CVolType;
					*pVol = volType;   // use copy constructor
					m_volTypeList.AddTail(pVol);				
				}
				
				// For each Volume Type - populate the color bar min and max with defaults if they haven't been defined.
				// ToDo: Add proper support for color range limits.
				/*float cbmin, cbmax;
				pVolType->GetColorBarMinMax(cbmin, cbmax);
				if (cbmin == 0.0 && cbmax == 0.0) {
				cbmin = m_plotParmData.m_colorBarMin;
				cbmax = m_plotParmData.m_colorBarMax;
				pVolType->SetColorBarMinMax(cbmin, cbmax);
				}*/
			}			
		}
		// if the volume list is empty, use the default list.
		if (m_volTypeList.GetCount() == 0){
			GetDefaultVolTypeList();
		}
		if (nVersion > 41) {
			for (i = 0; i<m_nFile; i++)
				ar >> m_favorite[i];
		} else {
			for (i = 0; i<m_nFile; i++)
				m_favorite[i] = 1;
		}
		if (nVersion > 42){
			for (i = 0; i<m_nFile; i++){
				ar >> m_scanMinMax[i].min;
				ar >> m_scanMinMax[i].max;
				m_scanMinMax[i].bMinOverride = FALSE;
				m_scanMinMax[i].bMaxOverride = FALSE;
				if (nVersion > 46){
					ar >> m_scanMinMax[i].bMinOverride;
					ar >> m_scanMinMax[i].bMaxOverride;
				}
			}
		} else {
			for (i = 0; i<m_nFile; i++){
				m_scanMinMax[i].min = 0;
				m_scanMinMax[i].max = 0;
				m_scanMinMax[i].bMinOverride = FALSE;
				m_scanMinMax[i].bMaxOverride = FALSE;
			}
		}
		if (nVersion > 12) {
			for (i=0; i<m_nFile; i++)
				GetSegyInPtr(i)->Serialize(ar);
		}
		ar >> m_nClass;
		if (nVersion<7) {
			for (i=0; i<OLDMAXCLASS; i++)
				ar >> m_colorbar[i];
		} else {
			for (i=0; i<m_nClass; i++) {
				ar >> m_colorbar[i];
				if (nVersion > 28) {
					ar >> m_arrClassNames[i];
				}
			}
		}
		ar>>m_nHscale;
		if (nVersion<11) {
			int ijunk;
			ar>>ijunk;
			m_fVscale = 10.0;
		} else {
			ar>>m_fVscale;
		}
		if (nVersion < 33) {
			m_fWellWidth = 0.5;
		} else {
			ar>>m_fWellWidth;
		}
		if (nVersion < 36) {
			m_fWellOffset = 0.5;
			m_bWellBoldPen = TRUE;
		} else {
			ar>>m_fWellOffset;
			ar>>m_bWellBoldPen;
		}
		if (nVersion < 40) {
			m_nColorTrackWidth = 3;
		} else {
			ar >> m_nColorTrackWidth;
		}
		ar>>m_nDisplayInline;
		if (nVersion >= 18 ) {
			ar>>m_nDisplayXline;
		} else {
			m_nDisplayXline = 0;
		}
        if (nVersion >= 60) {
            ar >> m_nDisplayUserline;
        }
        else {
            m_nDisplayUserline = 0;
        }
		ar>>m_nStartTime;
		ar>>m_nEndTime;
		int cdpix, inlineix, xlineix;
		if (nVersion < 12) {
			ar>>cdpix;
			ar>>inlineix;
			ar>>xlineix;
		}

		for (i=0; i<NXPLOT; i++) {
			m_XplotParms[i].Serialize(ar);
			if (!m_XplotParms[i].m_strXAttr.IsEmpty() &&
				!m_XplotParms[i].m_strXAttr.IsEmpty()) {
				if (i<NXPLOT-1) bMenuParms[i+1]=TRUE;
				bMenuXPlots[i]=TRUE;
			} else {
				if (i<NXPLOT-1) bMenuParms[i+1]=FALSE;
				bMenuXPlots[i]=FALSE;
                // set the default scatter.
                m_XplotParms[i].m_nScatter = 1;
			}
			m_initializeXplotView[i]=FALSE;
		}

		ar>>m_si;
		int tmp;
		ar>>tmp;  // used to be nSamp. No longer needed.
		ar>>m_bDrawFlag;
		ar>>m_strOutFile;
		// the dimensions and placement of the classified window...
		if (nVersion>1) {
			ar >> m_rcClassifiedWin;
		} else {
			m_rcClassifiedWin.SetRectEmpty();
		}
		int cdpSize, inlineSize, xlineSize, inlineXlineMode;
		if (nVersion < 12) {
			ar>>cdpSize;
			ar>>inlineSize;
			ar>>xlineSize;
		}
		if (nVersion>3) {
			ar>>m_10msTLineMode;
			m_100msTLineMode = TRUE;
			m_500msTLineMode = TRUE;
			if (nVersion > 62) {
				ar >> m_100msTLineMode;
				ar >> m_500msTLineMode;
			}
			ar>>m_cursorPositionMode;
			ar>>inlineXlineMode;
			m_inlineXlineMode = (eLineMode)inlineXlineMode;
			if(nVersion<38 && inlineXlineMode != eINLINE) {
				// Older versions stored m_nDisplayLine and m_nAlternativeLine. If the inlineXlineMode 
				// is eXLINE, swap the display lines. cnelson 2013-11-13.
				int temp = m_nDisplayInline;
				m_nDisplayInline = m_nDisplayXline;
				m_nDisplayXline = temp;
			}
			if (nVersion < 78) {
				// get color from class 
				int colorIndex;
				ar >> colorIndex;
				COLORREF* pColorbar = GetColorBarPtr();
				if (pColorbar[colorIndex] == NOCOLOR) m_selectColor1 = RGB(255, 255, 255);
				else m_selectColor1 = pColorbar[colorIndex];

				m_selectColor2 = RGB(255, 255, 255);
				if (nVersion > 52) {
					ar >> colorIndex;
					if (pColorbar[colorIndex] == NOCOLOR) m_selectColor2 = RGB(255, 255, 255);
					else m_selectColor2 = pColorbar[colorIndex];
				}
			}
			else {
				ar >> m_selectColor1;
				ar >> m_selectColor2;
			}
		} else {
			m_10msTLineMode=FALSE;
			m_100msTLineMode = TRUE;
			m_500msTLineMode = TRUE;
			m_cursorPositionMode=FALSE;
			m_inlineXlineMode=eINLINE;
			m_selectColor1 = RGB(255, 255, 255);
			m_selectColor2 = RGB(255, 255, 255);
        }
		if (nVersion>4) {
			ar>>m_highliteDotSize;
		} else {
			m_highliteDotSize=1;
		}
		if (nVersion < 49){
			if (nVersion > 8) {
				int tmp;
				ar >> tmp;
		}
		}
		if (nVersion >= 12 && nVersion < 46) {
			m_headerMap.Serialize(ar);
			// The legacy code had a global headermap.  The header map is now always local. So copy it to the Segy object if necessary.
			for (i = 0; i < m_nFile; i++) {
				if (!GetSegyInPtr(i)->isLocalHeaderMap()){
					GetSegyInPtr(i)->SetHeaderMap(&m_headerMap);
				}
			}
		}

		if (nVersion >= 14) {
			ar >> m_rcParentWin;
			
			// The project may have been saved from a workstation with a larger desktop, if so adjust the windows to fit.

			int cxOrigin = GetSystemMetrics(SM_XVIRTUALSCREEN);
			int cyOrigin = GetSystemMetrics(SM_YVIRTUALSCREEN);
			int cxSize   = GetSystemMetrics(SM_CXVIRTUALSCREEN);
			int cySize   = GetSystemMetrics(SM_CYVIRTUALSCREEN);
			int cxFrame  = GetSystemMetrics(SM_CXFRAME);
			int cyFrame  = GetSystemMetrics(SM_CYFRAME);
			int cxExtent = cxOrigin + cxSize;
			int cyExtent = cyOrigin + cySize;
			CRect mainWnd;
			CRect clientWnd;
			AfxGetMainWnd()->GetWindowRect(&mainWnd);
			AfxGetMainWnd()->GetClientRect(&clientWnd);
			int xBias = cxFrame;
			int yBias = mainWnd.Height() - clientWnd.Height()  - cyFrame;

			// main window
			CRect parentSave = m_rcParentWin;
			if (m_rcParentWin.left < cxOrigin)  {
				m_rcParentWin.right = cxOrigin + m_rcParentWin.Width();
				m_rcParentWin.left = cxOrigin;
			}
			if (m_rcParentWin.right > cxExtent)  {
				m_rcParentWin.left = cxExtent - m_rcParentWin.Width();
				m_rcParentWin.right = cxExtent;
			}
			if (m_rcParentWin.top < cyOrigin) {
				m_rcParentWin.bottom = cyOrigin + m_rcParentWin.Height();;
				m_rcParentWin.top = cyOrigin;
			}
			if (m_rcParentWin.bottom > cyExtent) {
				m_rcParentWin.top = cyExtent - m_rcParentWin.Height();;
				m_rcParentWin.bottom = cyExtent;
			}
			if (m_rcParentWin.Height() > cySize) {
				m_rcParentWin.top = cyOrigin;
				m_rcParentWin.bottom = cyExtent;
			}
			if (m_rcParentWin.Width() > cxSize) {
				m_rcParentWin.left = cxOrigin;
				m_rcParentWin.right = cxExtent;
			}
			int deltaX = m_rcParentWin.left - parentSave.left; 
			int deltaY = m_rcParentWin.top  - parentSave.top;
			int clientXOrigin = m_rcParentWin.left + xBias;
			int clientXExtent = m_rcParentWin.right - cxFrame;
			int clientYOrigin = m_rcParentWin.top + yBias;
			int clientYExtent = m_rcParentWin.bottom - cyFrame;

			// Classified window
			m_rcClassifiedWin += CPoint(deltaX, deltaY);
			if (m_rcClassifiedWin.left < clientXOrigin || m_rcClassifiedWin.left > (clientXExtent - 100)) {
				m_rcClassifiedWin.right = clientXOrigin + m_rcClassifiedWin.Width();
				m_rcClassifiedWin.left = clientXOrigin;
			}
			if (m_rcClassifiedWin.top < clientYOrigin || m_rcClassifiedWin.top > (clientYExtent - 100)) {
				m_rcClassifiedWin.bottom = clientYOrigin + (m_rcParentWin.Height() / 2) + m_rcClassifiedWin.Height();
				m_rcClassifiedWin.top = clientYOrigin + (m_rcParentWin.Height() / 2);
			}

			// restore the window position
			AfxGetMainWnd()->SetWindowPos(0, m_rcParentWin.left, m_rcParentWin.top,  
				m_rcParentWin.Width(), m_rcParentWin.Height(), 0);
			CMainFrame *pMainFrame;
			pMainFrame = (CMainFrame *) AfxGetMainWnd();
			m_toolbarHeight =  pMainFrame->GetToolBarHeight();
		} else {
			m_rcParentWin = CRect(0, 0, 0, 0);
		}
				
		if (nVersion >= 22) {
			ar >> m_bDepthMode;
			ar >> m_depthDatum;
		} else {
			m_bDepthMode = FALSE;
			m_depthDatum = 0;
		}

		if (nVersion >= 25) {
			ar >> m_10msLineLabels;
			m_100msLineLabels = TRUE;
			m_500msLineLabels = TRUE;
			if (nVersion > 62) {
				ar >> m_100msLineLabels;
				ar >> m_500msLineLabels;
			}
			m_petrelTime = FALSE;
			m_petrelDatum = 0.0;
			if (nVersion > 65) {
				ar >> m_petrelTime;
			}
			if (nVersion > 75) {
				ar >> m_petrelDatum;
			}
			ar >> m_labelInterval;
			ar >> m_faciesHistogramMode;
			ar >> m_mapSelectMode;
		} else {
			m_10msLineLabels = FALSE;
			m_100msLineLabels = TRUE;
			m_500msLineLabels = TRUE;
			m_petrelTime = FALSE;
			m_labelInterval = 10;
			m_faciesHistogramMode = FALSE;
			m_mapSelectMode = FALSE;
		}

		CIMACApp *pApp = (CIMACApp *)AfxGetApp();
		m_petrelTime = pApp->IsServerMode();

        if (nVersion >= 56) {
//            ar >> m_attributeAdvisorMode;
            int dummy;
            ar >> dummy;
        }
        m_attributeAdvisorMode = FALSE;

		if (nVersion >= 27) {
			ar >> m_bInlineLR;
			ar >> m_bXlineLR;
			ar >> m_bUserlineLR;
		} else {
			m_bInlineLR = TRUE;
			m_bXlineLR = TRUE;
			m_bUserlineLR = TRUE;
		}

		if (nVersion >= 35) {
			ar >> m_bHighlightAll;
		} else {
			m_bHighlightAll = TRUE;
		}
		if (nVersion >= 71) {
			ar >> m_nDeviatedCurveView;
		}
		else {
			m_nDeviatedCurveView = eFLAT_CURVE_VIEW;
		}
		if (nVersion >= 72) {
			ar >> m_fDeviationCurveWindowSize;
		}
		else {
			m_fDeviationCurveWindowSize = 1.0f;
		}
		if (nVersion >= 77) {
			ar >> m_flattenHorizonCheck;
			ar >> m_flatteningDatum;
			ar >> m_flatteningHorizon;
			ar >> m_flatteningUseAverage;
		}
		else {
			m_flattenHorizonCheck = FALSE;
			m_flatteningDatum = 0;
			m_flatteningHorizon = "";
			m_flatteningUseAverage = TRUE;
		}
		

		// wells and well lists
		if (nVersion >= 15) {
			DestroyWellData();
			WellList *pWellList = GetWellListPtr();
			int nCount;
			ar >> nCount;

			// check for demo mode
			CIMACApp *pApp = (CIMACApp *) AfxGetApp();
			if ( MAX_DEMO_WELLS >= 0 ) {
				if (pApp->IsDemoMode()) {
					pApp->ShowTrialMessage();
				}
			}

			CWell *pWell;
			for (int i=0; i<nCount; i++) {
				pWell = new CWell;
				pWell->Serialize(ar);

				if (pApp->IsDemoMode() && MAX_DEMO_WELLS >= 0 && i >= MAX_DEMO_WELLS) {
					delete pWell;
				} else {
					pWellList->AddTail(pWell);
					DWORD inLine, xLine;
					pWell->GetInlineXline(inLine, xLine);
					if (inLine == -1 && xLine == -1) {
						CSegy *pSegy = this->GetSegyInPtr(0);
						if (pSegy) pSegy->FindWellInlineXline(pWell);
					}
				}			
			}

			// well lists
			ar >> nCount;
			for (int i=0; i<nCount; i++) {
				WellSubList *pSubList = new WellSubList;
				pSubList->Serialize(ar);
				m_wellSubListMgr.AddTail(pSubList);
				CString name;
				ar >> name;
				m_wellSubListNames.AddTail(name);
			}
			
			float depthDatum;
			BOOL  bDepthMode = GetWellDepthMode(depthDatum);
			CWellUtil::ProcessDepthTimeCurves(GetWellListPtr(), bDepthMode, depthDatum);
		} else {
			InitWellDatabase();
		}

		// horizon data
		if (m_pHorizon == NULL) {
			m_pHorizon = new CHorizon;
		} else {
			m_pHorizon->DestroyData();
		}
		if (nVersion >= 16) {
			m_pHorizon->Serialize(ar);
			if (nVersion < 24) {
				// convert color index to raw color
				for (int i=0; i<m_pHorizon->GetHorizonCount(); i++) {
					COLORREF horColor = m_pHorizon->GetLineColor(i);
					if ((int)horColor < m_nClass) {
						horColor = m_colorbar[horColor];
					} else {
						horColor = NOCOLOR;
					}
					m_pHorizon->SetLineColor(i, horColor);
				}
			}
		}

		// Time Slice
		if (nVersion >= 26) {
			m_timeSlice.Serialize(ar);
		} else {
			m_timeSlice.Destroy();
			m_timeSlice.Initalize();
		}

	

		// serialize the user lines
		if (nVersion >= 28) {
			int userLineCount;
			ar >> userLineCount;
			if (userLineCount > 0) {
				ar >> m_userLineSelected;
				for (int i=0; i<userLineCount; i++) {
					CString name;
					ar >> name;
					m_userLineNameArray.SetAtGrow(i, name);
					int iCount;
					ar >> iCount;
					CPointArray *pData = new CPointArray;
					pData->SetSize(0, 1000);
					for (int j=0; j<iCount; j++) {
						CPoint point;
						ar >> point;
						pData->SetAtGrow(j, point);
					}
					m_userLineDataArray.SetAtGrow(i, (void *) pData);

                    CDoublePointArray *pDoubleData = new CDoublePointArray;
                    pDoubleData->SetSize(0, 1000);
					if (nVersion >= 52) {
						iCount;
						ar >> iCount;
						for (int j = 0; j<iCount; j++) {
							CDoublePoint doublePoint;
							doublePoint.Serialize(ar);
							pDoubleData->SetAtGrow(j, doublePoint);
						}


					}
					m_userLineSmoothedCoordinateArray.SetAtGrow(i, (void *)pDoubleData);
                }
			}
		}
		
		//serialize the viewZones
		if(nVersion >= 32) {
			CViewZone newZone;
			int zoneCount;
			ar >> zoneCount;
			for (int i=0; i<zoneCount; i++) {
				newZone.Serialize(ar);
				m_viewZoneArray.Add(newZone);
			}
		}

		// serialize the virtual volume equations
		if (nVersion >= 45) {
			int vvCount;
			ar >> vvCount;
			for (int i = 0; i < vvCount; i++) {
				// Virtual volumes weren't released until QI-Pro v4.1.0. Throw away any VV info in projects prior to that release.
				if (vers >= 40100.0) {
					CVVAttribute &vvAttr = GetVVAttributeRef(i);
					vvAttr.Serialize(ar);
				}
				else {
					CVVAttribute vvAttr;
					vvAttr.Init();
					vvAttr.Serialize(ar);
				}
			}
		}
		if (nVersion < 45 || vers < 40100.0){
			BuildDefaultVirtualVolumes();
		}

		// parameter tool
		if (nVersion >= 48){
			for (int i = 0; i<m_parmToolCount; i++) {
				delete m_parmToolDataArray[i];
			}
			ar >> m_parmToolCount;
			int ix = 0;
			for (int i = 0; i<m_parmToolCount; i++) {
				CParmToolData *pParmToolData = new CParmToolData;
				pParmToolData->Serialize(ar);
				m_parmToolDataArray.SetAtGrow(ix++, pParmToolData);			
			}
			m_parmToolCount = ix;
		} else {
			m_parmToolCount = 0;
		}

		if (nVersion >= 50) {
			for (int i = 0; i < NXPLOT*MAXCBSIZE; i++) {
				ar >> m_thirdAttributeBar[i];
			}
			for (int i = 0; i < NXPLOT; i++) {
				ar >> m_thirdAttributBarSize[i];
			}
		} else {
			GenerateThirdAttributeColorbar();
		}

        if (nVersion >= 54) {
            ar >> m_suppressPolygonMessages;
            ar >> m_suppressEllipseMessages;
        } else {
            m_suppressPolygonMessages = FALSE;
            m_suppressEllipseMessages = FALSE;
        }

        // Highlite regions
        m_initialSelect = FALSE;
        SetHighliteRegion1Null();
        SetHighliteRegion2Null();
        if (nVersion >= 57) {
            CRect region;
            ar >> region;
            SetHighliteRegion1(region);           
            ar >> region;
            SetHighliteRegion2(region);
            if (!IsHighliteRegion1Null() || !IsHighliteRegion2Null()) {
                m_initialSelect = TRUE;
            }
        }
        m_highliteLine = 0;
        m_highliteLineMode = 0;
        if (nVersion >= 59) {
            ar >> m_highliteLine;
            ar >> m_highliteLineMode;

        }

        // Attribute advisor
        if (nVersion >= 58) {
            int aaCount;
            ar >> aaCount;
            for (int i = 0; i < aaCount; i++) {
                CString aaName;
                ar >> aaName;
                SetAASelectedAttribute(aaName, i);
            }
        }
        if (nVersion >= 62) {
            CAADialogParms *pAADialogParms = GetAADialogParmsPtr();
            pAADialogParms->Serialize(ar);
        }

		// wiggle overlay
		if (nVersion >= 65) {
			ar >> m_wiggleInterpolationMode;
			ar >> m_wiggleDrawingMode;
			ar >> m_wiggleTraceExcursion;
			ar >> m_wiggleSelectedAttribute;
			ar >> m_wiggleClassifiedVolumeCheck;
			if (nVersion > 66) {
				ar >> m_wiggleTraceClip;
				ar >> m_wiggleTraceDecimation;
			}
		}
		else {
			m_wiggleInterpolationMode = 2;
			m_wiggleDrawingMode = 0;
			m_wiggleTraceExcursion = 1.5;
			m_wiggleSelectedAttribute = "";
			m_wiggleClassifiedVolumeCheck = FALSE;
			m_wiggleTraceClip = 3;
			m_wiggleTraceDecimation = 1;
		}
		if (nVersion >= 75) {
			int units;
			ar >> units;
			m_projectUnits = (eUnits)units;
		}
		else {
			m_projectUnits = eUNDEF_UNITS;
		}

		if (nVersion >= 74) {
			ar >> m_seiswareProjectFlag;
		} else {
			m_seiswareProjectFlag = FALSE;
		}


		// Classified volume toolbar toggles
		if (nVersion >= 79) {
			ar >> m_horizonDisplayToggle;
			ar >> m_wiggleDisplayToggle;
			ar >> m_flatteningDisplayToggle;
			ar >> m_wellDisplayToggle;
			ar >> m_wellLogDisplayToggle;
			ar >> m_wellTopDisplayToggle;
			ar >> m_displayLinesDisplayToggle;
		} 
		else {
			m_horizonDisplayToggle = TRUE;
			m_wiggleDisplayToggle = TRUE;
			m_flatteningDisplayToggle = TRUE;
			m_wellDisplayToggle = TRUE;
			m_wellLogDisplayToggle = TRUE;
			m_wellTopDisplayToggle = TRUE;
			m_displayLinesDisplayToggle = TRUE;
		}
		// headwave
		if (nVersion >= 78) {
			CString tmp;
			ar >> tmp;
			if (!tmp.IsEmpty()) {
				SetHeadwaveProjectFolder(tmp);
			}
			ar >> tmp;
			if (!tmp.IsEmpty()) {
				SetHeadwaveOutputFolder(tmp);
			}
		}

		//DumpLists();

		  ///////////////\\\\\\\\\\\\\\\\\\\\\\
		////// end of serialize from file \\\\\\\\
      ////////////////////\\\\\\\\\\\\\\\\\\\\\\\\\\\

		// if there are no input files, then there's not much to do, just return.
		if (m_nFile == 0) {
			m_bDrawFlag = FALSE;
			m_bReadyToCompute = FALSE;
			return; 
		}

		// Validate seismic attribute paths. These often become invalid when the project moves.
		CStringArray paths;
		for (int ix=0; ix<m_nFile; ix++) {
			paths.Add(m_arrAttributePaths[ix]);
		}
		ValidatePaths(paths);
		for (int ix = 0; ix < m_nFile; ix++) {
			m_arrAttributePaths[ix] = paths[ix];
		}

		// If the user clicked the delete button, remove those attribues now.
		for (int ix=m_nFile-1; ix >= 0; ix--) {
			if (paths[ix] == "null") {
				RemoveAttribute(ix);
			}
		}

		// Validate reference template paths. These often become invalid when the project moves.
		paths.RemoveAll();
		for (int ix=0; ix<NXPLOT; ix++) {
			paths.Add(m_XplotParms[ix].m_strImageFile);
		}
		ValidatePaths(paths);
		for (int ix=0; ix<NXPLOT; ix++) {
			if (paths[ix] != "null") {
				m_XplotParms[ix].m_strImageFile = paths[ix];
			} else {
				m_XplotParms[ix].m_strImageFile.Empty();
			}
		}

		ValidateZones();
		ValidateTimeslice();

        ValidateSampleInterval();

		// In depth mode we need the tvd. in versions before 4.1.0 the TVD wasn't saved. So we'll check for older versions
		// if necessary issue a warning.
		if (GetWellDepthMode()) {
			BOOL warning = FALSE;
			CString warningList = "\n";
			WellList *pWellList = GetWellListPtr();
			POSITION pos = pWellList->GetHeadPosition();
			while (pos) {
				CWell *pWell = pWellList->GetNext(pos);
				if (pWell->GetDeviatedPointCount()>0 && pWell->GetDeviatedPointArVersion() < 4) {
					warning = TRUE;
					warningList += pWell->wellName;
					warningList += "\n";
				}
			}
			if (warning) {
				CString msg = "Some enhancements have been made to this version of QI-Pro. Deviated wells are now displayed more accurately.\n";
				msg += "In order to properly represent the deviated wells it is necessary to reload the deviated surveys for the following wells:\n";
				msg += warningList;
				AfxMessageBox(msg);
			}
		}

		TRACE("Loading data...\n");
		if (LoadData() < 0) {
			if (AfxMessageBox("An error has occured. Abort?", MB_YESNO)==IDYES) exit(0);
		}
		TRACE("Done Loading data.\n");

		m_bDrawFlag=TRUE;
		m_bNewColorFlag=0xffffffff;
		m_bReadyToCompute = TRUE;
		m_minimizedFlag = 0;

		// turn on update flag for all displays
		for (int i=0; i<GetXplotCount()+1; i++) {
			m_bReadyToDisplay[i] = TRUE;
		}
		for (int i = 0; i<NXPLOT; i++) {
			m_pCrossPlotView[i]  = NULL;
		}
		SetUpdateXplotPaneFlagsAll(TRUE);
		SetOutputState(FALSE);
		GetMainFrame()->DestroyFilelistPane(); // the filelist might still exist if a previous project was open

		// validate the project units
		if (GetProjectUnits() == eUNDEF_UNITS) {
			int status = CrossCheckCoordinateUnits();
			if (status == -1 || status == 0) {
				SetProjectUnits(eUNDEF_UNITS);
				CString text;
				text = "The project units cannot be detected from the input seg-y files.\n";
				text += "Please check your measurment units on the Input Attribute Dialog.\n";
				text += "Look for the variable named 'Coordinate Units' on the Binary Header tab.";
				AfxMessageBox(text);
			} else {
				SetProjectUnits((eUnits)status);
				CString text = (status == 1) ? "Metric" : "Imperial";
				text = "Project measurment units have been set to: " + text;
				text += "\n\n";
				text += "'Project Units' is a new feature in QI-Pro. You won't see this message again for this project.\n";
				text += "You can change the 'Project Units' using the Input Attribute Dialog and adjusting the Seg-Y header mapping.";
				AfxMessageBox(text);
			}
		}

		// CSI..
		m_viewIndex = 0;
		m_ampListAllocSize = 0;
		m_ampList = NULL;
		m_arrDynamicSliders = NULL;
		m_nDynamicSliders = 0;

		m_viewInstance = -1;
		m_pMainView = NULL;
		m_pCSIView = NULL;
		m_pColorBarView = NULL;

		m_arrExportAttributeNames.RemoveAll();
		m_arrExportFileNames.RemoveAll();

		m_lastSuccessfulExportedFile.Empty();
		m_bLastExportedFileReadyFlag = false;
        m_petrelProjectPath.Empty();

		// open Headwave project
#if 0
		if (pApp->IsHeadwaveMode()) {
			CString hwProjectFolder = GetHeadwaveProjectFolder();
			ValidatePath(&hwProjectFolder);
			CString projectName = m_tempPathName.Mid(m_tempPathName.ReverseFind('\\') + 1);
			CString hwProjectName = BuildHWProjectName(&projectName);
			OpenOrCreateHWProject(hwProjectFolder, hwProjectName);
		}
#endif
		UpdateViews();
	}
}


void CIMACDoc::DestroySeisParmList()
{
	// destroy the SeisParm list
	POSITION pos = m_seisParmsList.GetHeadPosition();
	while (pos) {
		CSeisParms *pSeisParms = m_seisParmsList.GetNext(pos);
		delete pSeisParms;
	}
	m_seisParmsList.RemoveAll();
}

void CIMACDoc::DestroyVolTypeList()
{
	//  destroy the volType list
	POSITION pos = m_volTypeList.GetHeadPosition();
	while (pos) {
		CVolType *pVolType = m_volTypeList.GetNext(pos);
		delete pVolType;
	}
	m_volTypeList.RemoveAll();
}

void CIMACDoc::GenerateThirdAttributeColorbar()
{
	for (int j = 0; j < NXPLOT; j++) {
		// make a r-w-b default color bar
		for (int i = 0; i < MAXCBSIZE; i++) m_thirdAttributeBar[i + j * MAXCBSIZE] = NOCOLOR;
		m_thirdAttributBarSize[j] = 21;
		m_thirdAttributeBar[0 + j * MAXCBSIZE] = RGB(255, 0, 0);
		m_thirdAttributeBar[10 + j * MAXCBSIZE] = RGB(255, 255, 255);
		m_thirdAttributeBar[20 + j * MAXCBSIZE] = RGB(0, 0, 255);
		InterpolateColorbar(&m_thirdAttributeBar[j*MAXCBSIZE], 21);
	}
}
/**
* Checks if all the files exist. If they don't, prompt the user to correct the path. 
* If they can't be corrected, throw a CFileException. 
* The user has the option to remove the attribute if it's not in use
**/
void CIMACDoc::ValidatePaths(CStringArray& paths) {
	CFileException e;
	char errmsg[255];
	CString msg, lastValidDir, dir, file;
	CFile f;
	int iSlash, len;
	for (int i=0; i<paths.GetSize(); i++) {
		if (paths[i].IsEmpty()) continue;
		BOOL bOK = FALSE;
		while (!bOK) {
			// check if we can open the file
			if (!f.Open(paths[i], CFile::modeRead,&e)) {
				// Failed to open the file.
				iSlash = paths[i].ReverseFind('\\');
				len = paths[i].GetLength();
				dir = paths[i].Left(iSlash);
				file = paths[i].Right(len-iSlash-1);
				if (!lastValidDir.IsEmpty() && dir != lastValidDir) {
					// Try looking in the folder of the last valid file. Reset the path and try again.
					paths[i].Format("%s\\%s", lastValidDir, file);
					continue;
				}

				// We've tried opening the file at the orignal path, and at the last valid path. 
				// Now ask user to find the correct path.
				e.GetErrorMessage(errmsg,255);
				msg = errmsg;
				msg += "\n\nPlease specify the correct file path or Cancel.";
				CNewPathDlg dlg;
				dlg.m_strMessage=msg;
				dlg.m_strNewPath=paths[i];
				dlg.m_attributeIndex = i;
				if (dlg.DoModal()==IDOK) {
					// User gave us a new path. Reset the path and try again.
					if (!dlg.m_bRemovedPath) {
						paths[i] = dlg.m_strNewPath;
					}
					else {
						paths[i] = "null";
						bOK = TRUE;
					}
				} else {
					// User Cancelled. Bail.
					throw new CFileException(e.m_cause, e.m_lOsError, e.m_strFileName);
				}
			} else {
				// Succeeded in opening the file. It's valid. Save the lastValidPath and move on 
				// to the next file.
				f.Close();
				bOK = TRUE;
				iSlash = paths[i].ReverseFind('\\');
				lastValidDir = paths[i].Left(iSlash);
			}
		}
	}
}

/////////////////////////////////////////////////////////////////////////////
// CIMACDoc diagnostics

#ifdef _DEBUG
void CIMACDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CIMACDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
void CIMACDoc::DumpLists()
{
	DumpLists("");
}
void CIMACDoc::DumpLists(CString str)
{
	CString buffer, tmp;
	if (str.IsEmpty())
		tmp.Format("\n------------ List Dump -------------\n");
	else
		tmp.Format("\n------------ %s -------------\n", str);
	buffer += tmp;
	int nCount = (int) m_seisParmsList.GetCount();

	tmp.Format("seisParmsList %d\n", nCount);
	buffer += tmp;
	for (int j = 0; j < nCount; j++){
		CSeisParms *pSeis = m_seisParmsList.GetAt(m_seisParmsList.FindIndex(j));
		tmp.Format("Attribute=%15s volType=%10s count=%d values=",
			pSeis->GetAttrName(), pSeis->GetVolType(), pSeis->GetParmCount());
		buffer += tmp;
		for (int i = 0; i < pSeis->GetParmCount(); i++) {
			tmp.Format("%4d", (int)pSeis->GetParmValue(i));
			buffer += tmp;
		}
		tmp.Format("\n");
		buffer += tmp;
	}
	tmp.Format("volTypeList %d\n", m_volTypeList.GetCount());
	buffer += tmp;

	POSITION pos = m_volTypeList.GetHeadPosition();
	while (pos) {
		CVolType *pVol = m_volTypeList.GetNext(pos);
		tmp.Format("name=%15s count=%d names(enabled)=", pVol->GetVolTypeName(), pVol->GetParmNamesCount());
		buffer += tmp;
		for (int i = 0; i<pVol->GetParmNamesCount(); i++) {
			tmp.Format("%s(%d), ", pVol->GetParmName(i), pVol->GetParmEnabled(i));
			buffer += tmp;
		}
		tmp.Format("\n");
		buffer += tmp;
	}
	tmp.Format("----------- Done --------------\n");
	buffer += tmp;
	TRACE(buffer);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CIMACDoc commands

CString CIMACDoc::GetProjectName() 
{
	CString projectName = m_strPathName.Mid(m_strPathName.ReverseFind('\\') + 1);
	return projectName;
}
CString CIMACDoc::GetProjectPath()
{
	CString projectPath = m_strPathName.Left(m_strPathName.ReverseFind('\\') + 1);
	return projectPath;
}
CString CIMACDoc::GetProjectFullPath()
{
	return m_strPathName;
}

void CIMACDoc::GenerateNewPallet()
{
	int i, j, colorCode1, colorCode2, c1, c2, c3, dcc;
	dcc=256/NCOL;
	colorCode1=256;
	colorCode2=0;

	// first fill in the full intensity colors, every NCOL slot
	for (i=0; i<NCOL; i++, colorCode1-=dcc, colorCode2+=dcc) {
		c1 = (colorCode1==256)?255:colorCode1;
		c2 = (colorCode2==256)?255:colorCode2;
		m_pallet[0*NCOL*NCOL + i*NCOL] = RGB(255,  c2,   0);  // Red
		m_pallet[1*NCOL*NCOL + i*NCOL] = RGB( c1, 255,   0);  // Yellow
		m_pallet[2*NCOL*NCOL + i*NCOL] = RGB(  0, 255,  c2);  // Green
		m_pallet[3*NCOL*NCOL + i*NCOL] = RGB(  0,  c1, 255);  // Cyan
		m_pallet[4*NCOL*NCOL + i*NCOL] = RGB( c2,   0, 255);  // Blue
		m_pallet[5*NCOL*NCOL + i*NCOL] = RGB(255,   0,  c1);  // Magenta
				
	}
	//  fade the full intensity colors to white... RGB(255,255,255)
	for (i=0; i<NCOL*NCOL*6; i+=NCOL) {
		c1 = GetRValue(m_pallet[i]);
		c2 = GetGValue(m_pallet[i]);
		c3 = GetBValue(m_pallet[i]);
		c1 = (c1==255)?256:c1;
		c2 = (c2==255)?256:c2;
		c3 = (c3==255)?256:c3;
		int dc1 = (256-c1)/NCOL;
		int dc2 = (256-c2)/NCOL;
		int dc3 = (256-c3)/NCOL;
		for (j=1; j<NCOL; j++) {
			c1+=dc1;
			c2+=dc2;
			c3+=dc3;
			c1 = (c1==256)?255:c1;
			c2 = (c2==256)?255:c2;
			c3 = (c3==256)?255:c3;
			m_pallet[i+j] = RGB(c1, c2, c3);
		}
	}
}

void CIMACDoc::GenerateDensityColorBar()
{
	int i, cc1, cc2;
	cc1=DEN_INCREMENT;
	cc2=DEN_INCREMENT*(DEN_NCOLOR-1);
	// hard code the full on colors
	m_densitybar[0*DEN_NCOLOR] = RGB(  0,   0, 255); // blue
	m_densitybar[1*DEN_NCOLOR] = RGB(  0, 255, 255); // cyan
	m_densitybar[2*DEN_NCOLOR] = RGB(  0, 255,   0); // green
	m_densitybar[3*DEN_NCOLOR] = RGB(255, 255,   0); // yellow
	m_densitybar[4*DEN_NCOLOR] = RGB(255,   0,   0); // red
	// fill in the interpolated colors
	for (i=1; i<DEN_NCOLOR; i++, cc1+=DEN_INCREMENT, cc2-=DEN_INCREMENT) {
		m_densitybar[i+(0*DEN_NCOLOR)]=RGB(0,cc1,255);
		m_densitybar[i+(1*DEN_NCOLOR)]=RGB(0,255,cc2);
		m_densitybar[i+(2*DEN_NCOLOR)]=RGB(cc1,255,0);
		m_densitybar[i+(3*DEN_NCOLOR)]=RGB(255,cc2,0);
	}
}

void CIMACDoc::SetInlineXlineMode(eLineMode nMode)
{
	m_inlineXlineMode = nMode;
}

// Getters...

CSegy* CIMACDoc::GetSegyOutPtr()
{ 
	return &m_segyOut; 
}

void CIMACDoc::RemoveVVAttribute(CString attribute)
{
	for (int i = 0; i < GetVVAttributeCount(); i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		if (vvAttr.GetBaseName() == attribute) {
			m_vvAttributeArray.RemoveAt(i);
			break;
		}
	}
}

int CIMACDoc::GetVirtualVolumeCount()
{
	int fileCount = 0;
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++){
		CVVAttribute &vvAttr = GetVVAttributeRef(i);
		fileCount += vvAttr.GetVVCount();
	}
	return fileCount; 
}

CString CIMACDoc::GetFile(int n)
{
	if (n< m_nFile) return m_arrAttributePaths[n];
	return "";
}

CString CIMACDoc::GetAttr(int n)
{
	CString strRet;
	if (n < m_nFile) {
		strRet = m_arrAttributeNames[n];
	}
	return strRet;
}

CString CIMACDoc::GetVirtualVolumeAttributeName(int n)
{
	CString strRet;
	if (n < GetVirtualVolumeCount()){
		int vCount = 0;
		int vvCount = GetVVAttributeCount();
		for (int i = 0; i < vvCount; i++){
			CVVAttribute &vvAttr = GetVVAttributeRef(i);
			if (vCount + vvAttr.GetVVCount() <= n){
				vCount += vvAttr.GetVVCount();
			} else {
				strRet = vvAttr.GetVVName(n - vCount);
				break;
			}
		}
	}
	return strRet;
}

CString CIMACDoc::GetVirtualVolumeType(int n)
{
	CString strRet;
	if (n < GetVirtualVolumeCount()){
		int vCount = 0;
		int vvCount = GetVVAttributeCount();
		for (int i = 0; i < vvCount; i++){
			CVVAttribute &vvAttr = GetVVAttributeRef(i);
			if (vCount + vvAttr.GetVVCount() <= n){
				vCount += vvAttr.GetVVCount();
			} else {
				strRet = vvAttr.GetVVolumeType();
				break;
			}
		}
	}
	return strRet;
}

MIN_MAX CIMACDoc::GetVirtualVolumeMinMax(CString attribute)
{
	MIN_MAX minmax;
	memset(&minmax, 0, sizeof(MIN_MAX));
	BOOL found = FALSE;
	for (int i = 0; i < GetVVAttributeCount(); i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			if (vvAttr.GetVVName(j) == attribute) {
				minmax = vvAttr.GetVVMinMax(j);
				found = TRUE;
				break;
			}
		}
		if (found) break;
	}
	return minmax;
}

int CIMACDoc::GetVirtualVolumeFavorite(int n)
{
	int iRet = 0;
	if (n < GetVirtualVolumeCount()){
		int vCount = 0;
		int vvCount = GetVVAttributeCount();
		for (int i = 0; i < vvCount; i++){
			CVVAttribute &vvAttr = GetVVAttributeRef(i);
			if (vCount + vvAttr.GetVVCount() <= n){
				vCount += vvAttr.GetVVCount();
			} else {
				iRet = vvAttr.GetFavorite(n - vCount);
				break;
			}
		}
	}
	return iRet;
}

void CIMACDoc::SetVirtualVolumeFavorite(int favorite, int n)
{
	if (n < GetVirtualVolumeCount()){
		int vCount = 0;
		int vvCount = GetVVAttributeCount();
		for (int i = 0; i < vvCount; i++){
			CVVAttribute &vvAttr = GetVVAttributeRef(i);
			if (vCount + vvAttr.GetVVCount() <= n){
				vCount += vvAttr.GetVVCount();
			} else {
				vvAttr.SetFavorite(n - vCount, favorite);
				break;
			}
		}
	}
}

CSegy *CIMACDoc::GetVirtualVolumeSegyPtr(int n)
{
	CSegy *pSegy = NULL;
	if (n < GetVirtualVolumeCount()){
		int vCount = 0;
		int vvCount = GetVVAttributeCount();
		for (int i = 0; i < vvCount; i++){
			CVVAttribute &vvAttr = GetVVAttributeRef(i);
			if (vCount + vvAttr.GetVVCount() <= n){
				vCount += vvAttr.GetVVCount();
			} else {
				CSegy &segyRef = vvAttr.GetSegyRef(n - vCount);
				pSegy = &segyRef;
				break;
			}
		}
	}
	return pSegy;
}

CSegy* CIMACDoc::GetVirtualVolumeSegyPtr(CString attribute)
{
	CSegy* pSegy = NULL;
	BOOL found = FALSE;
	for (int i = 0; i < GetVVAttributeCount(); i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			CString name = vvAttr.GetVVName(j);
			if (vvAttr.GetVVName(j) == attribute) {
				CSegy& segyRef = vvAttr.GetSegyRef(j);
				pSegy = &segyRef;
				found = TRUE;
				break;
			}
		}
		if (found) break;
	}
	return pSegy;
}


CVVEquation &CIMACDoc::GetVirtualVolumeEquation(int n)
{	
	if (n < GetVirtualVolumeCount()){
		int vCount = 0;
		int vvCount = GetVVAttributeCount();
		for (int i = 0; i < vvCount; i++){
			CVVAttribute &vvAttr = GetVVAttributeRef(i);
			if (vCount + vvAttr.GetVVCount() <= n){
				vCount += vvAttr.GetVVCount();
			} else {
				return vvAttr.GetVVEquation(n - vCount);
			}
		}
	}
	CVVAttribute nullvvAttr;
	return nullvvAttr.GetVVNullEquation();
}

CSegy *CIMACDoc::GetSegyPtrFromAttrName(CString attr)
{
	CSegy *pSegy = NULL;

	// check physical volumes
	for (int j = 0; j<GetFileCount(); j++) {
		if (attr == GetAttr(j)) {
			pSegy = GetSegyInPtr(j);
			break;
		}
	}

	// check virtual volumes
	if (!pSegy) {
		for (int j = 0; j < GetVirtualVolumeCount(); j++){
			if (attr == GetVirtualVolumeAttributeName(j)) {
				pSegy = GetVirtualVolumeSegyPtr(j);
				break;
			}
		}
	}
	return pSegy;
}

void CIMACDoc::SetAASelectedAttribute(CString name, int n)
{
	if (n < NFILE) {
        m_AASelectedAttributeNames[n] = name;
        int count = GetAASelectedAttributeCount();
        SetAASelectedAttributeCount(count+1);
	}
}

void CIMACDoc::SetAttr(CString name, int n)
{
    if (n < NFILE) {
        m_arrAttributeNames[n] = name;
        int count = (int)m_seisParmsList.GetCount();
        while (count <= n) {
            CSeisParms *pSeisParms = new CSeisParms;
            m_seisParmsList.AddTail(pSeisParms);
            count++;
        }

        CSeisParms *pSeisParms = m_seisParmsList.GetAt(m_seisParmsList.FindIndex(n));
        pSeisParms->SetAttrName(name);
    }
}

void CIMACDoc::SetFavorite(int favorite, int n)
{
	if (n < NFILE){
		if (n < m_nFile){
			m_favorite[n] = favorite;
		} else {
			n -= m_nFile;
			SetVirtualVolumeFavorite(favorite, n);
		}
	}
}

void CIMACDoc::SetVolType(CString name, int n)
{
//	if (n < m_nFile) {
		CSeisParms *pSeisParms = m_seisParmsList.GetAt(m_seisParmsList.FindIndex(n));
	if (pSeisParms){
		pSeisParms->SetVolType(name);
	}
}
int CIMACDoc::GetFavorite(int n)
{
	if (n < NFILE) return m_favorite[n];
	return 0;
}

CString CIMACDoc::GetVolumeType(int n)
{
	CString strRet;
	if (n < m_nFile) {
		CSeisParms *pSeisParms = m_seisParmsList.GetAt(m_seisParmsList.FindIndex(n));
		strRet = pSeisParms->GetVolType();
	}
	return strRet;
}

CXplotParms* CIMACDoc::GetXplotParms(int n)
{
	if (n<NXPLOT) return &m_XplotParms[n];
	return NULL;
}

CSegy* CIMACDoc::GetSegyInPtr(int n)
{
	if (n<NFILE) return m_Segy[n];
	return NULL;
}

void CIMACDoc::SetSegyInPtr(CSegy *ptr, int i)
{
	if (i < NFILE) m_Segy[i] = ptr;
}
	
CSegy* CIMACDoc::GetFirstLoadedSegyPtr()
{
	CSegy* returnPtr = NULL;
	for (int i = 0; i < NFILE; i++) {
		returnPtr = GetSegyInPtr(i);
		if (returnPtr->GetTraceCount() > 0 &&
			returnPtr->GetSampleCount() > 0){
			break;		
		}
	}
	return returnPtr;
}

// Is the class used in any cutoff of any crossplot
BOOL CIMACDoc::IsClassActiveGlobal( int classInQuestion )
{
	if (classInQuestion < 0 || classInQuestion >= GetClassCount()) return FALSE;

	for (int j=0; j<GetXplotCount(); j++) {
		if (IsClassActiveLocal(classInQuestion, j) == TRUE) return TRUE;
	}
	// we didn't find it...
	return FALSE;
}

// is the class used in any specific crossplot
BOOL CIMACDoc::IsClassActiveLocal( int classInQuestion, int crossplotInQuestion )
{
	if (classInQuestion < 0 || classInQuestion >= GetClassCount()) return FALSE;

	CXplotParms *pXp = GetXplotParms(crossplotInQuestion);

	for (int i=0; i<GetClassCount(); i++) {
		for (int ix=0; ix<pXp->GetCutoffCount(); ix++) {
			CCutoffParms *pCutoff = pXp->CutoffParmsGetAt(ix);
			if (pCutoff->m_nClassAbove == classInQuestion) return TRUE;
			if (pCutoff->m_nClassBelow == classInQuestion) return TRUE;
            if (pCutoff->m_applyTo == classInQuestion) return TRUE;
        }
	}
	// we didn't find it...
	return FALSE;
}

void CIMACDoc::SetTimeSliceParms(int time, CString ref) 
{ 
	m_timeSlice.SetSliceTime(time); 
	m_timeSlice.SetSliceReference(ref); 
	m_timeSlice.SetShowSliceFlag(TRUE); 
	m_timeSlice.SetLoadSliceFlag(TRUE);
	m_timeSlice.SetActiveFlag(TRUE);
}

void CIMACDoc::GetSliceParms(BOOL &bShow, BOOL &bLoad, int &time, CString &ref)
{
	bShow = m_timeSlice.isShowSliceFlag(); 
	bLoad = m_timeSlice.isLoadSliceFlag();
	time  = m_timeSlice.GetSliceTime(); 
	ref   = m_timeSlice.GetSliceReference();
}

BOOL CIMACDoc::LoadProjectIndexes()
{
	// if necessary load the segy index for each file if it hasn't already been done.
	BOOL bNewLoad = FALSE;
	int nFile = GetFileCount();
	if (nFile == 0) return bNewLoad;

	for (int i=0; i<nFile; i++) {
		CSegy *pSegy=GetSegyInPtr(i);
		if (!pSegy->isIndexLoaded()) {
			pSegy->LoadIndex(this->GetFile(i), AfxGetMainWnd()->GetSafeHwnd());  
			bNewLoad = TRUE;
		}
		if (!pSegy->isSampleIntervalLoaded()) {
			pSegy->LoadSampleInterval(this->GetFile(i));
		}
		if (!pSegy->GetSegyIndexPtr()->IsIgnoreListValid()) bNewLoad = FALSE;
	}
	return bNewLoad;
}

int CIMACDoc::GetWellWidthPixels(CWell *pWell)
{ 
	float width = 0;
	if (pWell != NULL && pWell->GetCurveWidth() > 0) {
		width = pWell->GetCurveWidth();
	} else {
		width = m_fWellWidth;
	}
	return (int) (width * (float)DPI);
}

int CIMACDoc::GetWellOffsetPixels(CWell *pWell)
{ 
	float offset = 0;
	if (pWell != NULL && pWell->GetCurveOffset() > 0) {
		offset = pWell->GetCurveOffset();
	} else {
		offset = m_fWellOffset;
	}
	return (int) (offset * (float)DPI);
}

/////////////
// CrossCheckIndexes - Ignore the traces that aren't common to all segy files. 
// Those traces will be flagged inside the respective SegyIndex object.
int CIMACDoc::CrossCheckIndexes(HWND hParentWnd, CSegyIndex *pSegyIndex[], int indexCount)
{
	if (indexCount <= 1) return -1;

	CROSSCHECK_PARM taskparm;
	taskparm.pSegyIndex = pSegyIndex;
	taskparm.indexCount = indexCount;
	CUPDialog progressDlg(hParentWnd, CrossCheckIndexesTask, &taskparm,  _T("Finding Common Traces..."), true);

	int nResult = (int) progressDlg.DoModal();

	int nReturn = -1;
	if(nResult == IDOK) {
		nReturn = 0;
	} else {
		// operation was aborted or had error so restore the state
		for (int i=0; i<indexCount; i++) {
			pSegyIndex[i]->RestoreIgnoreList();
		}
		nReturn = -1;
	}

	return nReturn;
}

// static method run in the progress dialog thread
bool CrossCheckIndexesTask(const CUPDUPDATA* pCUPDUPData)
{
	CROSSCHECK_PARM *pTaskparm = (CROSSCHECK_PARM *) pCUPDUPData->GetAppData();
	CSegyIndex **pSegyIndex = pTaskparm->pSegyIndex;
	int indexCount = pTaskparm->indexCount;

	int  iStart[NFILE];
	int  iStat [NFILE];
	for (int i=0; i<indexCount; i++) {
		iStart[i] = -1;
		iStat [i] = 0;
		pSegyIndex[i]->SaveIgnoreList();
		pSegyIndex[i]->ClearIgnoreList();
	}

	int ntrace = pSegyIndex[0]->GetTraceCount();
	DWORD updateInterval = ntrace / 100;
	if (updateInterval == 0) updateInterval = 1;

	for (int i=0; i<ntrace && !pCUPDUPData->ShouldTerminate(); i++) {
		// update the progress
		if (i > (int) updateInterval) {
			int count = (i*100)/ntrace;
			pCUPDUPData->SetProgress(count);
			updateInterval += ntrace / 100;
		}

		int inLine = pSegyIndex[0]->GetInline(i);
		int xLine  = pSegyIndex[0]->GetCrossline(i);
		iStart[0] = i;
		BOOL bFoundinAll = TRUE;
		for (int j=1; j<indexCount && !pCUPDUPData->ShouldTerminate(); j++) {
			iStat[j] = pSegyIndex[j]->KillToTrace(iStart[j], inLine, xLine);
			if (iStat[j]<0) bFoundinAll = FALSE;
		}
		if (!bFoundinAll) {
			for (int j=0; j<indexCount && !pCUPDUPData->ShouldTerminate(); j++) {
				if (iStat[j] == 0) {
					pSegyIndex[j]->SetIgnore(iStart[j]);
				}
			}
		}
	}

	// kill any remaining traces in those files that are longer than the one at index [0]
	for (int j=0; j<indexCount && !pCUPDUPData->ShouldTerminate(); j++) {
		pSegyIndex[j]->KillToEnd(iStart[j] + 1);
		pSegyIndex[j]->GenLiveLineNumbers();
	}

	return TRUE;
}

int CIMACDoc::GetDisplayLine()
{
	switch(m_inlineXlineMode)
	{
	case eINLINE:
		return m_nDisplayInline;
	case eXLINE:
		return m_nDisplayXline;
    case eUSERLINE:
        return m_nDisplayUserline;
	default:
		return 0;
	}
}

void CIMACDoc::SetDisplayLine(int line)
{ 
	switch(m_inlineXlineMode)
	{
	case eINLINE:
		m_nDisplayInline = line; 
		break;
	case eXLINE:
		m_nDisplayXline = line; 
		break;
    case eUSERLINE:
        m_nDisplayUserline = line;
        break;
	default:
		break;
	}
}

void CIMACDoc::SetStartEndTimes(int startTime, int endTime)
{
	int maxStartTime, minEndTime;
	GetMaxStartMinEndTime(maxStartTime, minEndTime);
	
	m_nStartTime = max(maxStartTime, startTime);
	m_nEndTime = min(minEndTime, endTime);
}

void CIMACDoc::GetMaxStartMinEndTime(int &maxStartTime, int &minEndTime) 
{
	CSegyIndex *pSegyIndex[NFILE];
	for (int i=0; i<m_nFile; i++) {
		pSegyIndex[i] = GetSegyInPtr(i)->GetSegyIndexPtr();
	}

	GetMaxStartMinEndTime(pSegyIndex, m_nFile, maxStartTime, minEndTime); 
}

// Return the max start time and min end time common to all input attributes
void CIMACDoc::GetMaxStartMinEndTime(CSegyIndex *pSegyIndex[], int indexCount, int &maxStartTime, int &minEndTime)
{
//	TRACE("UpdateStartEndTimes pSegyIndex = %x\n", pSegyIndex);
	maxStartTime = INT_MIN;
	minEndTime = INT_MAX;
	for(int i=0; i < indexCount; i++) {
		CSegyIndex* pIndex = pSegyIndex[i];
		maxStartTime = max(maxStartTime, pIndex->GetStartTime());
		minEndTime = min(minEndTime, pIndex->GetEndTime());
	}
}

// after switching line modes, reset all loaded data. Necessary for the Attribute Advisor.
void CIMACDoc::ResetAllLines()
{
    int fileCount = GetFileCount();
    if (fileCount == 0) return;

    for (int i = 0; i < fileCount; i++) {
        CSegy *pSegy = GetSegyInPtr(i);
        pSegy->Reset();
    }
}

// Read the Segy data into memory for one segy line.
int CIMACDoc::LoadData()
{
	int i;
	int fileCount = GetFileCount();
	if (fileCount == 0) return 0;

#ifdef DEBUG
    clock_t start, finish, intervalStart;
	start = clock();
#endif

	BOOL bNewLoad = LoadProjectIndexes();
	if  (bNewLoad)  {
		CSegyIndex *pSegyIndex[NFILE];

		for (int i=0; i<fileCount; i++) {
			pSegyIndex[i] = GetSegyInPtr(i)->GetSegyIndexPtr();
		}
		CrossCheckIndexes(AfxGetMainWnd()->GetSafeHwnd(), pSegyIndex, fileCount);
	}

	// check if the requested line exists and is in range.
	if (GetInlineXlineMode() != eUSERLINE) {
		CSegyIndex *pSegyIndex = GetSegyInPtr(0)->GetSegyIndexPtr();
		if ( !pSegyIndex->LineExists(GetDisplayLine(), GetInlineXlineMode()) ) {
			CString txt, line;
			line = GetInlineXlineMode() == eINLINE ? "inline" : "crossline";
			txt.Format("There has been an error: The %s %d was not found in the file. The display inline and crossline will be reset.", line, GetDisplayLine());
			AfxMessageBox(txt);

			ResetDisplayLines();
		}
	}
	
	CModelessInfoDlg infoDlg;
	infoDlg.ShowMessage("Loading data...");

	// find the segy that has the latest start time, we'll use it for output.
	int segyToUseForOutput = GetSegyToUse();

	// If the line has changed then load appropriate data
	if (GetInlineXlineMode() != eUSERLINE) {
		for (i = 0; i < fileCount; i++) {
			CSegy *pSegy = GetSegyInPtr(i);
			if (pSegy->GetTraceCount() == 0 ||
				GetDisplayLine() != pSegy->GetCurrentLineNumber() ||
				GetInlineXlineMode() != pSegy->GetInlineXlineMode())
			{
				CString attrName = GetAttr(i);

				// skip loading if this attribute doesn't appear on any xplot.
				if (!IsAttributeInUse(attrName) && i != segyToUseForOutput) {
					// check if the attribute is needed for a virtual volume
					if (!IsAttributeInVirtualVolumeInUse(attrName)) {
						continue;
					}
				}
#ifdef DEBUG
                intervalStart = clock();
#endif
				infoDlg.AddString(attrName);
				pSegy->Reset();
				int ntrace = pSegy->Create(GetDisplayLine(), GetInlineXlineMode(), pSegy->GetSegyIndexPtr()->GetSampleCount());
				if (pSegy->LoadIndexedLine(GetFile(i), GetDisplayLine(), GetInlineXlineMode()) != ntrace) {
					CString msg;
					msg.Format("problem loading line %d from file %s", GetDisplayLine(), GetFile(i));
					AfxMessageBox(msg);
					return -1;
				}
#ifdef DEBUG
				TRACE("LoadData File=%s time=%f\n", GetFile(i), (double)(clock() - intervalStart) / CLOCKS_PER_SEC);
#endif
			}
		}

	} else {
		// load user line

		CPointArray* pData = GetCurrentUserLinePtr();
		if (pData == NULL) {
			AfxMessageBox("No Userline has been selected");
			return -1;
		}

		for (i=0; i<fileCount; i++) {
			CSegy* pSegy = GetSegyInPtr(i);
			if (!pSegy->isUserLineLoaded(pData)) {

				CString attrName = GetAttr(i);

				// skip loading if this attribute doesn't appear on any xplot.
				if (!IsAttributeInUse(attrName) && i != segyToUseForOutput) {
					// check if the attribute is needed for a virtual volume
					if (!IsAttributeInVirtualVolumeInUse(attrName)) {
						continue;
					}
				}

				infoDlg.AddString(attrName);
				pSegy->Reset();
				int ntrace = (int) pData->GetCount();
				pSegy->Create(ntrace, pSegy->GetSegyIndexPtr()->GetSampleCount());
				if (pSegy->LoadIndexedLine(GetFile(i), 0, GetInlineXlineMode(), pData) < 0) {
					return -1;
				}
			}
		}
	}

	LoadVirtualVolumes(&infoDlg, NULL);

	infoDlg.DestroyWindow();

#ifdef DEBUG
    intervalStart = clock();
#endif
	// Create the output volume (in memory) if it hasn't been done already.
	CSegy *pSegyOut = GetSegyOutPtr();
	int ntrace = pSegyOut->GetTraceCount();
	if (  GetDisplayLine()==0 || ntrace==0 || (ntrace>0 &&
		(GetDisplayLine() != pSegyOut->GetCurrentLineNumber() ||
		GetInlineXlineMode() != pSegyOut->GetInlineXlineMode() )))
	{

		*pSegyOut = GetSegyInPtr(segyToUseForOutput);  // invoke the = operator. Copy the data from the first segy.

		for (i=0; i<pSegyOut->GetTraceCount(); i++) {
			float *pData=pSegyOut->GetTraceDataPtr(i);
			for (int j=0; j<pSegyOut->GetSampleCount(); j++) {
				pData[j]=UNCLASSIFIED;
			}
		}
		ntrace = pSegyOut->GetTraceCount();
	}

    if (GetInlineXlineMode() == eUSERLINE) {
        pSegyOut->SetUserLinePtr(GetCurrentUserLinePtr());
        pSegyOut->SetUserLineSmoothedCoordinatePtr(GetCurrentUserLineSmoothedCoordinatePtr());
    } else {
        pSegyOut->SetUserLinePtr(NULL);
        pSegyOut->SetUserLineSmoothedCoordinatePtr(NULL);
    }

#ifdef DEBUG
    TRACE("Create output volume time=%f\n", (double)(clock() - intervalStart) / CLOCKS_PER_SEC);
#endif

	// loop through the list of wells and project any deviation data onto the current line.
	ProjectWellsToCurrentLine();

#ifdef DEBUG
	finish = clock();
	double duration = (double)(finish-start) / CLOCKS_PER_SEC;
	TRACE("LoadData Total time=%f\n", duration);
#endif

	SetDensityModeUpdateFlag(TRUE);

    // the view class takes care of inserting the select codes into the output volume.
    SetInitialSelect(TRUE);
	
    return ntrace;
}

void CIMACDoc::ProjectWellsToCurrentLine()
{
	CSegy *pSegyOut = GetSegyOutPtr();

	// loop through the list of wells and project any deviation data onto the current line.
	WellList *pWellList = GetWellListPtr();
	POSITION pos = pWellList->GetHeadPosition();
	while (pos) {
		CWell *pWell = pWellList->GetNext(pos);

		// Project the deviation onto the current line.
		pSegyOut->ComputeDeviatedProjection(pWell);
	}
}

int CIMACDoc::LoadSegy(CString attribute)
{
	int index = GetAttributeIndex(attribute);
	if (index < 0) return -1;


	CSegy* pSegy = GetSegyPtrFromAttrName(attribute);

	// load segy if not loaded already
	if (GetInlineXlineMode() != eUSERLINE) {
		if (pSegy->GetTraceCount() == 0 ||
			GetDisplayLine() != pSegy->GetCurrentLineNumber() ||
			GetInlineXlineMode() != pSegy->GetInlineXlineMode())
		{
			pSegy->Reset();
			int ntrace = pSegy->Create(GetDisplayLine(), GetInlineXlineMode(), pSegy->GetSegyIndexPtr()->GetSampleCount());
			if (pSegy->LoadIndexedLine(GetFile(index), GetDisplayLine(), GetInlineXlineMode()) != ntrace) {
				return -1;
			}
		}
	}
	else {
		CPointArray* pData = GetCurrentUserLinePtr();
		if (pData == NULL) {
			AfxMessageBox("No Userline has been selected");
			return 0;
		}
		if (!pSegy->isUserLineLoaded(pData)) {
			pSegy->Reset();
			int ntrace = (int)pData->GetCount();
			pSegy->Create(ntrace, pSegy->GetSegyIndexPtr()->GetSampleCount());
			if (pSegy->LoadIndexedLine(GetFile(index), 0, GetInlineXlineMode(), pData) < 0) {
				return -1;
			}
		}
	}
	return 0;
}

// find Segy with latest start time.
int CIMACDoc::GetSegyToUse()
{
	int startTime = GetSegyInPtr(0)->GetSegyIndexPtr()->GetStartTime();
	int segyToUseForOutput = 0;
	for (int i = 1; i < GetFileCount(); i++) {
		int nextStartTime = GetSegyInPtr(i)->GetSegyIndexPtr()->GetStartTime();
		if (nextStartTime > startTime) {
			segyToUseForOutput = i;
			startTime = nextStartTime;
		}
	}
	return segyToUseForOutput;
}

// Load virtual volumes
// if *attributeName is NULL then load all the volumes that are in use.
void CIMACDoc::LoadVirtualVolumes(CModelessInfoDlg *pInfoDlg, const CUPDUPDATA *pCUPDUPData, CString *attributeName)
{
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount && !ShouldTerminate(pCUPDUPData); i++){
		CVVAttribute &vvAttr = GetVVAttributeRef(i);
		CIntArray fileIndexes;

		for (int j = 0; j < vvAttr.GetVVCount() && !ShouldTerminate(pCUPDUPData); j++){
			CString vvName = vvAttr.GetVVName(j);
			if (attributeName==NULL && !IsAttributeInUse(vvName)){
				continue;
			}
			if (attributeName && *attributeName != vvName) {
				continue;
			}

			clock_t start = clock();

			if (pInfoDlg) pInfoDlg->AddString(vvName);

			// get the list of substituted attributes to be used in the equation. Store 
			// their file indexes for later.

			// create completely expanded (substituted) equation of equation
			// NOTE:	GetSubstitutedEquation() replaces all attributes with a random variable and stores those attributes
			//			in a separate external list to save them. This is done so that the parsing will work accurately, in
			//			case there are 'illegal' characters in the attribute names. To get the variables, we use GetSubstitutedVariables()
			CVVEquation vvEquationRef(vvAttr.GetVVEquation(j).GetSubstitutedEquation());
			vvEquationRef.Parse();
			CStringArray *pVariableArray = vvAttr.GetVVEquation(j).GetSubstitutedVariables(); // NOTE: Get SubstitutedEquation must be called first for this to work

			BOOL unableToLoad = FALSE;
			fileIndexes.RemoveAll();
			for (int k = 0; k < pVariableArray->GetCount() && !ShouldTerminate(pCUPDUPData); k++){
				if (LoadSegy(pVariableArray->GetAt(k)) < 0) {
					unableToLoad = TRUE;
					break;
				}
				fileIndexes.Add(GetAttributeIndex(pVariableArray->GetAt(k)));
			}
			if (ShouldTerminate(pCUPDUPData)) break;
			if (unableToLoad) {
				CString msg;
				msg.Format("No data found. The Virtual Volume %s has not been loaded.", vvName);
				AfxMessageBox(msg);
				continue;
			}

			// create a segy clone, use the same segy that was used when creating the classified segy.
			int segyToUseForOutput = GetSegyToUse();
			CSegy *pClone = GetSegyInPtr(segyToUseForOutput);
			CSegy &virtualSegy = vvAttr.GetSegyRef(j);
			virtualSegy = pClone;

			// with the cloned segy, the equation, and the attribute indexes to use, create
			// the virtual volume.
			CreateVirtualVolume(virtualSegy, vvEquationRef, &fileIndexes, pCUPDUPData);

			TRACE("%s computed in %5.3f seconds\n", vvName, (double)(clock() - start) / CLOCKS_PER_SEC);
		}
	}
}

// Looks at all the crossplots, checks if this attribute is in use. Also checks if it's currently displayed in CSI window.
BOOL CIMACDoc::IsAttributeInUse(CString checkAttr)
{
	if (IsAttributeInCrossPlot(checkAttr)) {
		return TRUE;
	}
	if (IsAttributeOnDisplayInCSI(checkAttr)) {
		return TRUE;
	}
	if (IsAttributeOnExportList(checkAttr)) {
		return TRUE;
	}
	if (IsAttributeOnWiggleOverlay(checkAttr)) {
		return TRUE;
	}

	return FALSE;
}

BOOL CIMACDoc::IsAttributeOnWiggleOverlay(CString checkAttr)
{
	if (GetWiggleDrawingMode() > eNO_WIGGLE && !GetWiggleClassifiedVolumeCheck()) {
		if (checkAttr == GetWiggleSelectedAttribute()) {
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CIMACDoc::IsAttributeInCrossPlot(CString checkAttr)
{
	for (int i = 0; i < GetXplotCount(); i++) {
		CXplotParms* pXp;
		pXp = GetXplotParms(i);
		if (pXp->m_strXAttr == checkAttr ||
			pXp->m_strYAttr == checkAttr ||
			(pXp->m_strColorAttr == checkAttr && pXp->IsThirdAttributeMode()))
		{
			return TRUE;
		}
	}
	return FALSE;
}

BOOL CIMACDoc::IsAttributeOnDisplayInCSI(CString checkAttr)
{
	// check if this attribute is currently displayed in the CSI window.
	if (IsCSIMode()){
		if (m_viewIndex < 0) return FALSE;
		SeisParmsList* pSeisParmsList = GetSeisParmsListPtr();
		CSeisParms* pSeisParms = pSeisParmsList->GetAt(pSeisParmsList->FindIndex(m_viewIndex));
		CString strName = pSeisParms->GetAttrName();
		if (checkAttr == strName){
			return TRUE;
		}
	}

	return FALSE;
}

BOOL CIMACDoc::IsAttributeOnExportList(CString checkAttr)
{
	// if export mode, check if the attribute is on the export list.
	if (IsOutputState()){
		CStringArray* pExportAttrs = GetExportAttributeNamesPtr();
		for (int i = 0; i < pExportAttrs->GetCount(); i++) {
			CString strName = pExportAttrs->GetAt(i);
			if (checkAttr == strName){
				return TRUE;
			}
		}
	}
	return FALSE;
}

BOOL CIMACDoc::IsAttributeInVirtualVolumeOnWiggleOverlay(CString checkAttr)
{
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			std::vector<CVVEquation> equations;
			equations.push_back(vvAttr.GetVVEquation(j));
			if (isInNestedEQ(checkAttr, equations) && IsAttributeOnWiggleOverlay(vvAttr.GetVVName(j))) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

BOOL CIMACDoc::IsAttributeInVirtualVolumeInCrossPlot(CString checkAttr)
{
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			std::vector<CVVEquation> equations;
			equations.push_back(vvAttr.GetVVEquation(j));
			if (isInNestedEQ(checkAttr, equations) && IsAttributeInCrossPlot(vvAttr.GetVVName(j))) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

BOOL CIMACDoc::IsAttributeInVirtualVolumeOnDisplayInCSI(CString checkAttr)
{
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			std::vector<CVVEquation> equations;
			equations.push_back(vvAttr.GetVVEquation(j));
			if (isInNestedEQ(checkAttr, equations) && IsAttributeOnDisplayInCSI(vvAttr.GetVVName(j))) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

BOOL CIMACDoc::IsAttributeInVirtualVolumeOnExportList(CString checkAttr)
{
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			std::vector<CVVEquation> equations;
			equations.push_back(vvAttr.GetVVEquation(j));
			if (isInNestedEQ(checkAttr, equations) && IsAttributeOnExportList(vvAttr.GetVVName(j))) {
				return TRUE;
			}
		}
	}
	return FALSE;
}

bool CIMACDoc::isInNestedEQ(CString checkAttr, std::vector<CVVEquation> equations)
{
	BOOL found = false;

	CVVEquation eq = equations[0];
	CStringArray* variables = eq.GetVariables();
	for (int i = 0; i < variables->GetCount(); i++) {
		if (variables->GetAt(i) == checkAttr) {
			found = TRUE;
			break;
		}

		// if variable is itself a vvAttr, append their equation to the end of the list
		for (int p = 0; p < GetVVAttributeCount(); p++) {
			CVVAttribute& vvAttr = GetVVAttributeRef(p);
			for (int j = 0; j < vvAttr.GetVVCount(); j++) {
				CString volumeName = vvAttr.GetVVName(j);
				for (int k = 0; k < variables->GetCount(); k++) {
					if (volumeName == variables->GetAt(k)) {
						equations.push_back(vvAttr.GetVVEquation(j));
					}
				}
			}
		}
	}

	if (found) return true;
	else if (equations.size() == 1) return false;

	equations.erase(equations.begin()); // remove the first element of the list that we just checked
	return isInNestedEQ(checkAttr, equations);
}

BOOL CIMACDoc::IsAttributeInVirtualVolume(CString checkAttr, CString vvName)
{
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++){
		CVVAttribute &vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++){
			// get the list of substituted attributes to be used in the equation. 
			CVVEquation &eq = vvAttr.GetVVEquation(j);
			CStringArray *pArray = eq.GetVariables();
			for (int k = 0; k < pArray->GetCount(); k++){
				if (checkAttr == pArray->GetAt(k)) {
					if (!vvName.IsEmpty()) {
						if (vvAttr.GetVVName(j) == vvName)
							return TRUE;
					}
					else
						return TRUE;
				}
			}
		}
	}
	return FALSE;
}

BOOL CIMACDoc::IsAttributeInVirtualVolumeInUse(CString checkAttr, CString vvName)
{
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++) {
		CVVAttribute& vvAttr = GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			std::vector<CVVEquation> equations;
			equations.push_back(vvAttr.GetVVEquation(j));
			if (isInNestedEQ(checkAttr, equations) && IsAttributeInUse(vvAttr.GetVVName(j))) {
				if (!vvName.IsEmpty()) {
					if (vvAttr.GetVVName(j) == vvName)
						return TRUE;
				}
				else 
					return TRUE;
			}
		}
	}
	return FALSE;
}

// scan virtual volume for min max
int CIMACDoc::ScanVirtualVolume(CString attribute, int count, float *min, float *max)
{
	int index = -1;
	*min = 0;
	*max = 0;
	int tracesScanned = 0;
	for (int i = 0; i < GetVirtualVolumeCount(); i++){
		if (GetVirtualVolumeAttributeName(i) == attribute){
			index = i;
			break;
		}
	}
	if (index < 0) return -1;

	int si = GetSI();
	int startTime = GetStartTime();
	int endTime = GetEndTime();
	int nsamps = Time2Index((endTime - startTime), si) + 1;
	CSegy *pSegy = GetVirtualVolumeSegyPtr(attribute);
	if (nsamps > pSegy->GetSampleCount()) nsamps = pSegy->GetSampleCount();
	
	for (int i = 0; i < pSegy->GetTraceCount(); i++){
		if (count > 0 && i == count) break;

		float *pData = pSegy->GetTraceDataPtr(i, startTime);
		for (int j = 0; j < nsamps; j++) {
			if (pData[j] < *min) *min = pData[j];
			if (pData[j] > *max) *max = pData[j];
		}

		tracesScanned = i + 1;
	}

	return tracesScanned;
}

// loop through the attribute list, return the index of the given attribute
int CIMACDoc::GetAttributeIndex(CString attr)
{
	int iret = -1;
	for (int i = 0; i < GetFileCount(); i++) {
		if (GetAttr(i) == attr){
			iret = i;
			break;
		}
	}
	return iret;
}
// loop through the virtual volume list, return the index of the given attribute
int CIMACDoc::GetVirtualVolumeIndex(CString name)
{
	int iret = -1;
	for (int i = 0; i < GetVirtualVolumeCount(); i++) {
		if (GetVirtualVolumeAttributeName(i) == name) {
			iret = i;
			break;
		}
	}
	return iret;
}

int CIMACDoc::GetFlatteningHorizonIndex()
{
	int index = -1;
	if (GetFlattenHorizonCheck()) {
		CHorizon* pHorizon = GetHorizonDataPtr();
		int nHor = pHorizon->GetHorizonCount();
		for (int i = 0; i < nHor; i++) {
			if (pHorizon->GetName(i) == GetFlatteningHorizon()) {
				index = i;
				break;
			}
		}
	}
	return index;
}

std::vector<float> CIMACDoc::GetFlatteningOffsets(CSegy* pSegy, int firstTr, int nTrace, int incrementTr)
{
	std::vector<float> flatteningOffsets(nTrace, 0); // initialize to zero
	if (GetFlatteningDisplayToggle() && GetFlattenHorizonCheck()) {
		// Get horizon name and horizon index
		int horizonIndex = GetFlatteningHorizonIndex();
		if (horizonIndex > -1) {
			// iterate through number of traces
			for (int i = 0, jtr = 0, trnum = firstTr; i < nTrace; i++, jtr++, trnum += incrementTr) {
				int inLine = pSegy->GetInline(trnum);
				int xLine = pSegy->GetCrossline(trnum);
				CHorizon* pHorizon = GetHorizonDataPtr();
				float* pHor = pHorizon->GetHorizonDataPtr(horizonIndex);
				int dataIndex = 0;
				if (pHorizon->FindIndex(inLine, xLine, dataIndex) < 0) {
					flatteningOffsets[jtr] = NULL_HORIZON_VALUE;
				}
				else {
					if (pHor[dataIndex] == NULL_HORIZON_VALUE) {
						flatteningOffsets[jtr] = NULL_HORIZON_VALUE;
						continue;
					}
					float offset = GetFlatteningDatum() - pHor[dataIndex];
					if (IsPetrelTimeMode()) offset = -offset;
					flatteningOffsets[jtr] = offset;
				}
			}
		}
	}
	return flatteningOffsets;
}

float CIMACDoc::GetFlatteningOffsetForTrace(CSegy* pSegy, int traceIndex)
{
	float flatteningOffset = 0;
	if (!GetFlatteningDisplayToggle()) return flatteningOffset;

	int inLine = pSegy->GetInline(traceIndex);
	int xLine = pSegy->GetCrossline(traceIndex);
	CHorizon* pHorizon = GetHorizonDataPtr();
	if (GetFlattenHorizonCheck()) {
		int horizonIndex = GetFlatteningHorizonIndex();
		if (horizonIndex > -1) {
			float* pHor = pHorizon->GetHorizonDataPtr(horizonIndex);
			int dataIndex = 0;
			if (pHorizon->FindIndex(inLine, xLine, dataIndex) < 0) {
				flatteningOffset = NULL_HORIZON_VALUE;
			}
			else {
				if (pHor[dataIndex] == NULL_HORIZON_VALUE) {
					flatteningOffset = NULL_HORIZON_VALUE;
				}
				else
					flatteningOffset = GetFlatteningDatum() - pHor[dataIndex];
					if (IsPetrelTimeMode()) flatteningOffset = -flatteningOffset;
			}
		}
	}
	return flatteningOffset;
}

// loop through the file list, return the index of the given file
int CIMACDoc::GetFileIndex(CString filename)
{
	int iret = -1;
	for (int i = 0; i < GetFileCount(); i++) {
		if (GetFile(i) == filename){
			iret = i;
			break;
		}
	}
	return iret;
}

void CIMACDoc::CreateVirtualVolume(CSegy &virtualSegy, CVVEquation &vvEquationRef, CIntArray *pFileIndexs, const CUPDUPDATA *pCUPDUPData)
{
	// Get processing limits
	int startTime = GetStartTime();
	int endTime = GetEndTime();
	int nsamps = Time2Index((endTime - startTime), GetSI()) + 1;

	CPointerArray pInData;
	// get pointers to input volumes
	int fileCount = (int) pFileIndexs->GetCount();
	for (int j = 0; j < fileCount; j++){
		pInData.SetAtGrow(j, GetSegyInPtr(pFileIndexs->GetAt(j)));
	}

	int traceStart = 0;
	int traceEnd = virtualSegy.GetTraceCount()-1;

	// setup for threading
	int nThreads = m_numberOfProcessors;
	int nchunk = traceEnd / nThreads;

	VIRTUAL_VOLUME_PARM *taskparm = vvparm;

	for (int i = 0; i<nThreads; i++) {
		taskparm[i].traceStart = i * nchunk;
		taskparm[i].traceEnd = ((i + 1)*nchunk) - 1;
		taskparm[i].startTime = startTime;
		taskparm[i].nsamps = nsamps;
		taskparm[i].virtualSegy = (CSegy *)&virtualSegy;
		taskparm[i].vvEquation = vvEquationRef;
		taskparm[i].pCUPDUPData = pCUPDUPData;
		taskparm[i].pData = &pInData;
	}
	taskparm[nThreads - 1].traceEnd = traceEnd;

	// start the threads
	for (int i = 0; i<nThreads; i++) {
		pThreads[i] = AfxBeginThread(CreateVirtualVolumeThreadTask, &taskparm[i], THREAD_PRIORITY_NORMAL, 1024, CREATE_SUSPENDED);
		if (pThreads[i] == NULL) {
			AfxMessageBox("failed to start thread");
		} else {
			handles[i] = pThreads[i]->m_hThread;
			// we need to start the threads this way due to a bug in WaitForMultipleObjects
			pThreads[i]->m_bAutoDelete = FALSE;
			pThreads[i]->ResumeThread();
		}
	}

	DWORD istat = WaitForMultipleObjects(nThreads, handles, TRUE, INFINITE);
	if (istat != WAIT_OBJECT_0) {
		AfxMessageBox("Error waiting for threads");
	}

	//delete the thread objects
	for (int i = 0; i<nThreads; i++) {
		delete(pThreads[i]);
	}

	
}

UINT __cdecl CIMACDoc::CreateVirtualVolumeThreadTask(LPVOID pParm)
{
	VIRTUAL_VOLUME_PARM *pData = (VIRTUAL_VOLUME_PARM *)pParm;
	int traceStart = pData->traceStart;
	int traceEnd = pData->traceEnd;
	int startTime = pData->startTime;
	int nsamps = pData->nsamps;
	CSegy *virtualSegy = pData->virtualSegy;
	CVVEquation *vvEquationRef = &pData->vvEquation;
	void *pInData = pData->pData;
	const CUPDUPDATA *pCUPDUPData = pData->pCUPDUPData;
	CIMACDoc::CreateVirtualVolumeTask(startTime, traceStart, traceEnd, nsamps, virtualSegy, vvEquationRef, pInData, pCUPDUPData);
	return 0;
}

void CIMACDoc::CreateVirtualVolumeTask(int startTime, int traceStart, int traceEnd, int nsamps, CSegy *virtualSegy, CVVEquation *vvEquationRef, void *pData, const CUPDUPDATA *pCUPDUPData)
{
	CPointerArray *pInData = (CPointerArray *)pData;
	// initalize the arrays.
	CFloatArray values;
	CPointerArray arrTracePtrs;
	int fileCount = (int) pInData->GetCount();
	for (int i = 0; i < fileCount && !ShouldTerminate(pCUPDUPData); i++){
		values.SetAtGrow(i, 0.0);
		arrTracePtrs.SetAtGrow(i, NULL);
	}
	if (ShouldTerminate(pCUPDUPData)) return;

	for (int i = traceStart; i<=traceEnd && !ShouldTerminate(pCUPDUPData); i++) {
		for (int k = 0; k < fileCount && !ShouldTerminate(pCUPDUPData); k++){
			arrTracePtrs.SetAt(k, ((CSegy *)pInData->GetAt(k))->GetTraceDataPtr(i, startTime));
		}
		if (ShouldTerminate(pCUPDUPData)) return;
		float *pData = virtualSegy->GetTraceDataPtr(i, startTime);

		for (int j = 0; j<nsamps; j++) {
			// get input samples
			for (int k = 0; k < fileCount; k++){
				float *pTrace = (float *) arrTracePtrs.GetAt(k);
				values.SetAt(k, pTrace[j]);
			}
			// compute Virtual Volume data sample			
			pData[j] = vvEquationRef->Evaluate(&values);
		}
	}
}

void CIMACDoc::SetDensityModeUpdateFlag(BOOL flag)
{ 
	for (int i=0; i<GetXplotCount(); i++) {
		CXplotParms *pXp = GetXplotParms(i);
		pXp->SetDensityModeUpdateFlag(flag);
	}
}

void CIMACDoc::ResetDisplayLines()
{
	DWORD lineCount;
	DWORD* pLine;
	CSegyIndex* pSegyIndex = GetSegyInPtr(0)->GetSegyIndexPtr();

	pSegyIndex->GetLiveInlineNumbers(lineCount, &pLine);
	m_nDisplayInline = pLine[0];
	
	pSegyIndex->GetLiveXlineNumbers(lineCount, &pLine);
	m_nDisplayXline = pLine[0];

    m_nDisplayUserline = 0;
}

// load the time slice data.
BOOL CIMACDoc::LoadTimeSlice(CTimeSlice *pTimeSlice)
{
	int fileCount = GetFileCount();
	if (fileCount == 0) return FALSE;
	if (fileCount > pTimeSlice->GetMaxFileCount()) {
		AfxMessageBox("TimeSlice can only handle a maximum of 50 attributes for now.");
		return FALSE;
	}

	LOAD_TIMESLICE_PARM taskparm;
	taskparm.pDoc = this;
	taskparm.pTimeSlice = pTimeSlice;
	CUPDialog progressDlg(
		AfxGetMainWnd()->GetSafeHwnd(),
		LoadTimesliceTask, 
		&taskparm,  
		_T("Loading Timeslice data..."), 
		true);

	int nResult = (int) progressDlg.DoModal();
	if(nResult == IDOK) {
		return TRUE;
	} else {
		// operation was aborted or had error
		pTimeSlice->SetShowSliceFlag(false);
		return FALSE;
	}
}

// static method run in the progress dialog thread
bool LoadTimesliceTask(const CUPDUPDATA* pCUPDUPData)
{
	LOAD_TIMESLICE_PARM* pTaskparm = (LOAD_TIMESLICE_PARM*) pCUPDUPData->GetAppData();
	CIMACDoc* pDoc = pTaskparm->pDoc;
	CTimeSlice* pTimeSlice = pTaskparm->pTimeSlice;
	int fileCount = pDoc->GetFileCount();
	int volumeCount = fileCount;

	// Update the timeslice with the document data and count the number of unique attributes that 
	// need to be loaded (for the message).
	int attributeCount = 0;
	for (int i = 0; i<fileCount; i++) {
		CString sAttr = pDoc->GetAttr(i);
		if (pDoc->GetFile(i) != pTimeSlice->GetFileName(i)) {
			pTimeSlice->SetFileName(i, pDoc->GetFile(i));
			pTimeSlice->SetDataLoadedFlag(i, FALSE);
		}
		if (sAttr != pTimeSlice->GetAttrName(i)) {
			pTimeSlice->SetAttrName(i, sAttr);
		}

		// check if this attribute is active
		if( !pTimeSlice->IsDataLoaded(i) ) {
			// skip loading if this attribute isn't being used in crossplot
			if (pDoc->IsAttributeInCrossPlot(sAttr) || pDoc->IsAttributeInVirtualVolumeInCrossPlot(sAttr)) {
					attributeCount++;
			}
		}
	}
	// now update the timeslice with the virtual volume attributes
	for (int i = 0; i < pDoc->GetVirtualVolumeCount(); i++){
		CString sAttr = pDoc->GetVirtualVolumeAttributeName(i);
		if (sAttr != pTimeSlice->GetAttrName(volumeCount)){
			pTimeSlice->SetFileName(volumeCount, "");
			pTimeSlice->SetDataLoadedFlag(volumeCount, FALSE);
			pTimeSlice->SetAttrName(volumeCount, sAttr);
		}

		// check if the virtual volume is active
		if (!pTimeSlice->IsDataLoaded(volumeCount)) {
			// skip loading if this attribute isn't being used in crossplot
			if (pDoc->IsAttributeInCrossPlot(sAttr)) {
				attributeCount++;
			}
		}
		volumeCount++;
	}

	if (attributeCount == 0) return TRUE; // return if there are no attribute to load 

	pTimeSlice->SetVolumeCount(volumeCount);

	// Load slice data from active files.
	int currentAttribute = 0;
	for (int i = 0; i<fileCount && !pCUPDUPData->ShouldTerminate(); i++) {
		CSegy *pSegy=pDoc->GetSegyInPtr(i);
		CString sAttr = pDoc->GetAttr(i);

		// check if this attribute is active
		BOOL bLoad = FALSE;
		if ( pDoc->IsAttributeInCrossPlot(sAttr) || pDoc->IsAttributeInVirtualVolumeInCrossPlot(sAttr)) {
			bLoad = TRUE;
		}

		if (!bLoad || pTimeSlice->IsDataLoaded(i)) continue;

		CString msg;
		msg.Format("Loading Attribute %d of %d: %s", ++currentAttribute, attributeCount, sAttr);
		pCUPDUPData->SetProgress(msg);

		if (pSegy->LoadSliceData(i, pDoc->GetFile(i), pTimeSlice, pDoc->GetHorizonDataPtr(), pCUPDUPData) != 0) 
		{
			msg.Format("Unable to load time slice data for %d ms in file:\n %s\nPlease check that the time slice lies within the project start and end time.",
				pTimeSlice->GetSliceTime(), pDoc->GetFile(i));
			AfxMessageBox(msg);
			return FALSE;
		}
	}

	// compute the virtual time slices.
	int vvCount = -1;
	for (int i = 0; i < pDoc->GetVVAttributeCount(); i++) {
		CVVAttribute& vvAttr = pDoc->GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			CString sAttr = vvAttr.GetVVName(j);
			vvCount++;

			if (!pDoc->IsAttributeInCrossPlot(sAttr) || pTimeSlice->IsDataLoaded(vvCount + fileCount)) continue;

			CString msg;
			msg.Format("Loading Attribute %d of %d: %s", ++currentAttribute, attributeCount, sAttr);
			pCUPDUPData->SetProgress(msg);

			// create completely expanded (substituted) equation of equation
				// NOTE:	GetSubstitutedEquation() replaces all attributes with a random variable and stores those attributes
				//			in a separate external list to save them. This is done so that the parsing will work accurately, in
				//			case there are 'illegal' characters in the attribute names. To get the variables, we use GetSubstitutedVariables()
			CVVEquation vvEquationRef(vvAttr.GetVVEquation(j).GetSubstitutedEquation());
			vvEquationRef.Parse();
			CStringArray* pVariableArray = vvAttr.GetVVEquation(j).GetSubstitutedVariables(); // NOTE: Get SubstitutedEquation must be called first for this to work

			// get the list of attribute names and their corresponding file indexes
			CIntArray attributeIndexes;
			for (int k = 0; k < pVariableArray->GetCount(); k++) {
				attributeIndexes.Add(pDoc->GetAttributeIndex(pVariableArray->GetAt(k)));
			}

			// with the equation and list of indexes, we can now compute the virtual timeslice.
			pTimeSlice->ComputeVirtualTimeSlice(vvCount + fileCount, vvEquationRef, &attributeIndexes);
			
		}
	}

	return TRUE;
}

//
// Compute the result based on the settings of the cutoffs.
//
void CIMACDoc::ComputeEngine()
{
	int fileCount = GetFileCount();
	if (fileCount == 0) return;

	clock_t start = clock();

	CSegy *pSegyX;
	CSegy *pSegyY;
	CSegy *pSegyOut = GetSegyOutPtr();
	int i, j, k;
	float fSlope, fIntercept;
	float *pX, *pY, *pOut;

	if (!m_bReadyToCompute) return;

	// zap the histogram data
	for (i=0; i<MAXCLASS; i++){
		m_histoData[i] = 0;
		m_histoFlag[i] = 0;
	}

	int nxplot = GetXplotCount();
	if (nxplot == 0) {
		// show all data as unclassified.
		m_histoData[0] = 1;
		m_histoFlag[0] = 1;

		// if we have an output volume and no crossplots it means they were all deleted so zap the output data.
        // retain the embedded selection flags.
		if (pSegyOut != NULL) {
			int sampCount  = pSegyOut->GetSampleCount();
			int traceCount = pSegyOut->GetTraceCount();
			pOut = pSegyOut->GetTraceDataPtr(0);
			if (pOut == NULL) return;
			for (int i=0; i<traceCount; i++) {
				int traceIndex = i * sampCount;
				for (int j=0; j<sampCount; j++) {
                    if (pOut[traceIndex + j] >= (2 * SELECTION_BIAS)) {
                        pOut[traceIndex + j] = UNCLASSIFIED + (2 * SELECTION_BIAS);
                    }
                    else if (pOut[traceIndex + j] >= SELECTION_BIAS) {
                        pOut[traceIndex + j] = UNCLASSIFIED + SELECTION_BIAS;
                    }
                    else {
                        pOut[traceIndex + j] = UNCLASSIFIED;
                    }
				}
			}
		}
		return;
	}

	// TRACE("Computing...\n");
	for (i=0; i<nxplot; i++) {
		// find the segy pointers and store them for later.
		CXplotParms *pXp = GetXplotParms(i);
		if (pXp->m_strXAttr.IsEmpty() || pXp->m_strYAttr.IsEmpty()) break;
		pSegyX = NULL;
		pSegyY = NULL;
		if (pXp->GetCSIXMode() || pXp->GetCSIYMode()){
			// get the csi attribute.
			SeisParmsList *pSeisParmsList = GetSeisParmsListPtr();
			CSeisParms *pSeisParms = pSeisParmsList->GetAt(pSeisParmsList->FindIndex(m_viewIndex));
			CString strName = pSeisParms->GetAttrName();
			CSegy *pCSISegy = GetSegyPtrFromAttrName(strName);
			if (pXp->GetCSIXMode()) pSegyX = pCSISegy;
			if (pXp->GetCSIYMode()) pSegyY = pCSISegy;
		}
		for (j=0; j<fileCount; j++) {
			if (pSegyX == NULL && pXp->m_strXAttr == GetAttr(j)) pSegyX = GetSegyInPtr(j);
			if (pSegyY == NULL && pXp->m_strYAttr == GetAttr(j)) pSegyY = GetSegyInPtr(j);
			if (pSegyX && pSegyY) break;	
		}
		// search virtual volumes if attribute hasn't been located.
		if (pSegyX == NULL || pSegyY == NULL) {
			for (j = 0; j < GetVirtualVolumeCount(); j++){
				if (pSegyX == NULL && pXp->m_strXAttr == GetVirtualVolumeAttributeName(j)) pSegyX = GetVirtualVolumeSegyPtr(j);
				if (pSegyY == NULL && pXp->m_strYAttr == GetVirtualVolumeAttributeName(j)) pSegyY = GetVirtualVolumeSegyPtr(j);
				if (pSegyX && pSegyY) break;
			}
		}

		// Something went wrong, we couldn't find the attribute.
		if (pSegyX == NULL || pSegyY == NULL) {
			CString msg = "Cannot find data for attribute ";
			if (pSegyX == NULL) {
				msg += pXp->m_strXAttr;
			} else {
				msg += pXp->m_strYAttr;
			}
			msg += "\nProgram will now close.";
			AfxMessageBox(msg);
			exit(0);
		}
		pXp->pSegyX = pSegyX;
		pXp->pSegyY = pSegyY;

	}

	CSegy *pSegy = GetFirstLoadedSegyPtr();
	BYTE *pHdr = pSegy->GetHeader(0);

	int si = GetSI();			// si in us.
	if (si == 0) return;		// we need si. An error will be reported from the OnDraw method.

	int startTime = GetStartTime();
	int endTime   = GetEndTime();
	int nsamps = Time2Index((endTime - startTime), si) + 1;
	if (nsamps > pSegy->GetSampleCount()) nsamps = pSegy->GetSampleCount();

	// Loop through every crossplot 
	BOOL ifirst = true;
	for (i=0; i<nxplot; i++) {
		// get some parameters.
		CXplotParms *pXp=GetXplotParms(i);
		pSegyX = pXp->pSegyX;
		pSegyY = pXp->pSegyY;
		// loop through every cutoff
		for (int ix=0; ix<pXp->GetCutoffCount(); ix++) {
			CCutoffParms *pCutoff = pXp->CutoffParmsGetAt(ix);
								
			if (!pCutoff->m_bEnabled) continue;

			// skip ahead if the poly is being digitized.			
			if (pCutoff->m_cutoffType == ePOLY && pCutoff->m_bPolyCreated==FALSE) {
				continue;
			}

			fSlope = pCutoff->m_fSlope;
			fIntercept = pCutoff->m_fIntercept;
			BOOL bVertical = (pCutoff->lx1 == pCutoff->lx2)? TRUE: FALSE;
            int applyTo = (pCutoff->m_applyTo == 0) ? UNCLASSIFIED : pCutoff->m_applyTo;

			// for the histogram, keep track of which colors have been referenced
			m_histoFlag[pCutoff->m_nClassAbove]++;
			m_histoFlag[pCutoff->m_nClassBelow]++;

			//loop through all the traces and classify what we can.
			for (j=0; j<pSegyOut->GetTraceCount(); j++) {
				pX   = pSegyX->GetTraceDataPtr(j, startTime);
				pY   = pSegyY->GetTraceDataPtr(j, startTime);
				pOut = pSegyOut->GetTraceDataPtr(j, startTime);
				for (k=0; k<nsamps; k++) {
                    // Classify all the samples using the first crossplot, 
                    // after that only look at unclassified data.
                    int sampleValue = (int)pOut[k];
                    while (sampleValue >= SELECTION_BIAS) sampleValue -= SELECTION_BIAS;

                    if (ifirst || (!ifirst && sampleValue == applyTo)) {
                        // remove and save the selection flag.
                        int selected = 0;
                        if (pOut[k] >= (2 * SELECTION_BIAS)) {
                            selected = 2;
                            pOut[k] -= (2 * SELECTION_BIAS);
                        } else if (pOut[k] >= SELECTION_BIAS) {
                            selected = 1;
                            pOut[k] -= SELECTION_BIAS;
                        }
						// cutoff type is a line
						if (pCutoff->m_cutoffType == eLINE) {
							if (!bVertical) {
								double y = (double)fSlope * (double)pX[k] + (double)fIntercept;
								if ((double)pY[k] < y) {
									pOut[k] = (float)pCutoff->m_nClassBelow;
								} else {
									pOut[k] = (float)pCutoff->m_nClassAbove;
								}
							} else {
								float x=(float)(pCutoff->lx1-pXp->x1) /
										(float)(pXp->x2-pXp->x1) * 
										(pXp->m_fXMax-pXp->m_fXMin);
								x += pXp->m_fXMin;
								if (pX[k] < x) {
									pOut[k] = (float)pCutoff->m_nClassBelow;
								} else {
									pOut[k] = (float)pCutoff->m_nClassAbove;
								}
							}

						// cutoff type is a polygon or Ellipse
						} else if ((pCutoff->m_cutoffType == ePOLY && pCutoff->m_bPolyCreated ) ||
									pCutoff->m_cutoffType == eELLIPSE) {
							float scrnX, scrnY;

							// the objects are in screen coords.
							scrnX = (pX[k]-pXp->m_fXMin)/(pXp->m_fXMax-pXp->m_fXMin);
							scrnX = (scrnX * (float)(pXp->x2-pXp->x1)) + pXp->x1;
							scrnY = (pY[k]-pXp->m_fYMin)/(pXp->m_fYMax-pXp->m_fYMin);
							scrnY = (scrnY * (float)(pXp->y1-pXp->y2)) + pXp->y2;
							BOOL bInside;
							if (pCutoff->m_cutoffType == ePOLY) {
								bInside = pCutoff->polyRgn.PtInRegion((int)scrnX, (int)scrnY);

#if 0
								// test the std code, for headwave.
								if (pCutoff->m_stdPolyData.size() > 0) {
//									bInside = pCutoff->PtInStdRegion((int)scrnX, (int)scrnY);
									BOOL testStd = pCutoff->PtInStdRegion((int)scrnX, (int)scrnY);
									if (bInside != testStd) {
										TRACE("%d %d %d\n", (int)scrnX, (int)scrnY, bInside == testStd);
										pCutoff->PtInStdRegion((int)scrnX, (int)scrnY);
										pOut[k] += SELECTION_BIAS;
									}
								}
#endif
									
							} else {
								bInside = pCutoff->m_ellipse.PtInEllipse(CPoint((int)scrnX, (int)scrnY));
							}
							if (bInside) {
								pOut[k] = (float)pCutoff->m_nClassInside;
							} else {
								pOut[k] = (float)pCutoff->m_nClassOutside;
							}
						}

						if (pOut[k] == 0) pOut[k] = UNCLASSIFIED;
						if (selected > 0) {
                            pOut[k] += (selected * SELECTION_BIAS); // restore the selected state.
						}
					} // endif UNCLASSIFIED
				} // end k=all_samples
			} // end j=all_traces
			if (ifirst) ifirst = false;
		} // end ix=all_cutoffs
	} // end i=all_crossplots


	//clock_t start = clock();

	// Build the Facies histogram
	for (j=0; j<pSegyOut->GetTraceCount(); j++) {
		pOut=pSegyOut->GetTraceDataPtr(j, startTime);
		for (k=0; k<nsamps; k++) {
			int index = (int) pOut[k];
            while (index >= SELECTION_BIAS) {
                index -= SELECTION_BIAS;
            }
			if (index == UNCLASSIFIED) index = 0;
			// Add zone filter check here. KL
//			dbg break
			m_histoData[index]++;
		}
	}
	//TRACE("Facies Histogram computed in %5.3f seconds\n", (double) (clock()-start) / CLOCKS_PER_SEC);

	// If we are writing the data to an output file, then remove the internal flags
	if (IsOutputState()) {
		for (j=0; j<pSegyOut->GetTraceCount(); j++) {
			pOut=pSegyOut->GetTraceDataPtr(j, startTime);
			for (k=0; k<nsamps; k++) {
				if (pOut[k]<0) pOut[k] = -pOut[k];
				if (pOut[k] == UNCLASSIFIED) pOut[k] = 0;
			}
		}
	}
	m_bReadyToCompute=FALSE;
	
#if TIMERS == 1
	TRACE("\nClassifications computed in %5.3f seconds\n", (double) (clock()-start) / CLOCKS_PER_SEC);
#endif

	// compute the time slice.  
	// TODO: Turn this into a thread after it's debugged.
	ComputeSlice();
}


void CIMACDoc::ComputeSlice()
{ 
	clock_t start = clock();

	int fileCount = GetFileCount();
	if (fileCount == 0) return;

	CTimeSlice *pTimeSlice = GetTimeSlicePtr();
	if (!pTimeSlice->isShowSliceFlag() || pTimeSlice->isLoadSliceFlag()) return;
	float *pSlice = pTimeSlice->GetSlicePtr();
	if (pSlice == NULL) return;
	int i;
	DWORD j, k;
	float fSlope, fIntercept;
	float *pX, *pY;
	int nxplot = GetXplotCount();

	CSegy *pSegy= GetSegyInPtr(0);
	if (!pSegy->isIndexLoaded()) {
		// this is a show stopper, the index should be loaded by now.
		return;
	}
	DWORD inlineMin, inlineMax, xlineMin, xlineMax;
	CSegyIndex *pIndex = pSegy->GetSegyIndexPtr();
	pIndex->GetLineMinMax(inlineMin, inlineMax, xlineMin, xlineMax);

	//TRACE("Computing Slice...\n");
	for (i=0; i<nxplot; i++) {
		// find the segy pointers and store them for later.
		CXplotParms *pXp = GetXplotParms(i);
		if (pXp->m_strXAttr.IsEmpty() || pXp->m_strYAttr.IsEmpty()) break;
		int segyXindex = -1;
		int segyYindex = -1;
		for (j=0; j<(DWORD)fileCount; j++) {
			if (pXp->m_strXAttr == GetAttr(j)) segyXindex = j;
			if (pXp->m_strYAttr == GetAttr(j)) segyYindex = j;
			if (segyXindex >= 0 && segyYindex >= 0) break;	
		}
		// look at virtual volumes for missing index
		if (segyXindex < 0 || segyYindex < 0){
			for (j = 0; j < (DWORD) GetVirtualVolumeCount(); j++){
				if (pXp->m_strXAttr == GetVirtualVolumeAttributeName(j)) segyXindex = j + fileCount;
				if (pXp->m_strYAttr == GetVirtualVolumeAttributeName(j)) segyYindex = j + fileCount;
				if (segyXindex >= 0 && segyYindex >= 0) break;
			}
		}
		if (segyXindex < 0 || segyYindex < 0) return; // Something went wrong. We couldn't find the indexes
		pXp->segyXindex = segyXindex;
		pXp->segyYindex = segyYindex;
	}

	// Loop through every crossplot 
	BOOL ifirst = true;
	for (i=0; i<nxplot; i++) {
		// get some parameters.
		CXplotParms *pXp=GetXplotParms(i);
		pX = pTimeSlice->GetDataPtr(pXp->segyXindex);
		pY = pTimeSlice->GetDataPtr(pXp->segyYindex);
		// loop through every cutoff
		for (int ix=0; ix<pXp->GetCutoffCount(); ix++) {
			CCutoffParms *pCutoff = pXp->CutoffParmsGetAt(ix);	

			if (!pCutoff->m_bEnabled) continue;

			// skip ahead if the poly is being digitized.			
			if (pCutoff->m_cutoffType == ePOLY && pCutoff->m_bPolyCreated==FALSE) {
				continue;
			}

			fSlope = pCutoff->m_fSlope;
			fIntercept = pCutoff->m_fIntercept;
			BOOL bVertical = (pCutoff->lx1 == pCutoff->lx2)? TRUE: FALSE;
            int applyTo = (pCutoff->m_applyTo == 0) ? UNCLASSIFIED : pCutoff->m_applyTo;

			// for the histogram, keep track of which colors have been referenced
			m_histoFlag[pCutoff->m_nClassAbove]++;
			m_histoFlag[pCutoff->m_nClassBelow]++;

			//loop through all the samples and classify what we can.
			int sliceIndex = 0;
			for (j=inlineMin; j<inlineMax; j++) {
				for (k=xlineMin; k<xlineMax; k++, sliceIndex++) {
					// Classify all the samples using the first crossplot, 
					// after that only look at unclassified data.
					if (pSlice[sliceIndex] == NODATA) continue;
					if (ifirst || (!ifirst && abs((int)pSlice[sliceIndex]) == applyTo)) {	
						// cutoff type is a line
						if (pCutoff->m_cutoffType == eLINE) {
							if (!bVertical) {
								double y = (double)fSlope * (double)pX[sliceIndex] + (double)fIntercept;
								if ((double)pY[sliceIndex] < y) {
									pSlice[sliceIndex] = (float)pCutoff->m_nClassBelow;
								} else {
									pSlice[sliceIndex] = (float)pCutoff->m_nClassAbove;
								}
							} else {
								float x=(float)(pCutoff->lx1-pXp->x1) /
										(float)(pXp->x2-pXp->x1) * 
										(pXp->m_fXMax-pXp->m_fXMin);
								x += pXp->m_fXMin;
								if (pX[sliceIndex] < x) {
									pSlice[sliceIndex] = (float)pCutoff->m_nClassBelow;
								} else {
									pSlice[sliceIndex] = (float)pCutoff->m_nClassAbove;
								}
							}

						// cutoff type is a polygon or Ellipse
						} else if ((pCutoff->m_cutoffType == ePOLY && pCutoff->m_nPolyData>0) ||
									pCutoff->m_cutoffType == eELLIPSE) {
							float scrnX, scrnY;
							// the objects are in screen coords.
							scrnX = (pX[sliceIndex]-pXp->m_fXMin) / (pXp->m_fXMax-pXp->m_fXMin);
							scrnX = (scrnX * (float)(pXp->x2-pXp->x1)) + pXp->x1;
							scrnY = (pY[sliceIndex]-pXp->m_fYMin) / (pXp->m_fYMax-pXp->m_fYMin);
							scrnY = (scrnY * (float)(pXp->y1-pXp->y2)) + pXp->y2;
							BOOL bInside;
							if (pCutoff->m_cutoffType == ePOLY) {
								bInside = pCutoff->polyRgn.PtInRegion((int)scrnX, (int)scrnY);
							} else {
								bInside = pCutoff->m_ellipse.PtInEllipse(CPoint((int)scrnX, (int)scrnY));
							}
							if (bInside) {
								pSlice[sliceIndex] = (float)pCutoff->m_nClassInside;
							} else {
								pSlice[sliceIndex] = (float)pCutoff->m_nClassOutside;
							}
						}
						if (pSlice[sliceIndex] == 0) pSlice[sliceIndex] = UNCLASSIFIED;
					} // endif UNCLASSIFIED
				} // end k=all_xline
			} // end j=all_inlnie
			if (ifirst) ifirst = false;
		} // end ix=all_cutoffs
	} // end i=all_crossplots

	//clock_t start = clock();
	
#if TIMERS == 1
	TRACE("Time Slice computed in %5.3f seconds\n", (double) (clock()-start) / CLOCKS_PER_SEC);
#endif


}

void CIMACDoc::UpdateViews(BOOL bSkipCombo)
{
	if (!m_bDrawFlag) return;  // nothing do to
	CVolType *pVolType;
	POSITION pos;
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (pApp->IsFeature2()){
		// refresh the volume type combo box
		pApp->m_volTypeCombo->ResetContent();
		VolTypeList	*pVolTypeList = GetVolTypeListPtr();
		pos = pVolTypeList->GetHeadPosition();
		if (pos == NULL) {
			return;  // nothing to do, there is no volume type list.
		}
		while (pos) {
			pVolType = pVolTypeList->GetNext(pos);
			CString txt = pVolType->GetVolTypeName();
			pApp->m_volTypeCombo->AddString(txt);
		}
		pApp->m_volTypeCombo->SetCurSel(GetCurrentVolTypeIx());
		pVolType = pVolTypeList->GetAt(pVolTypeList->FindIndex(GetCurrentVolTypeIx()));
	}
	if (IsCSIMode()){
		// save the state of the slider controls.
		if (IsUpdateSliderEnabledFlag()) {
			int n = pVolType->GetParmNamesCount();
			for (int i = 0; i < pVolType->GetParmNamesCount(); i++) {
				if (m_arrDynamicSliders && m_arrDynamicSliders[i]) {
					CDynamicSlider *pDynamicSlider = m_arrDynamicSliders[i];
					pVolType->SetParmEnabled(i, pDynamicSlider->isEnabled());  // save the state of the slider
				}
			}
		}
		SetUpdateSliderEnabledFlag(TRUE);

		if (IsShowCSIPane()) {
			// rebuild the pane from scratch. Calls CCSIDoc::AllocateDynamicSliders()
			GetMainFrame()->ShowCSIPane();
		}

		if (m_pColorMapWnd && !m_bMinimizeColorMap) m_pColorMapWnd->Invalidate();

		// Find a volume that matches the slider settings.
		int ix = 0;
		m_viewIndex = -1;
		pos = m_seisParmsList.GetHeadPosition();
		while (pos) {
			CSeisParms *seisParms = m_seisParmsList.GetNext(pos);
			if (seisParms->GetVolType() == pVolType->GetVolTypeName() &&
				seisParms->GetParmCount() == pVolType->GetParmNamesCount()) {
				BOOL bAllMatch = TRUE;
				BOOL bNoActiveSliders = TRUE;
				for (int i = 0; i < seisParms->GetParmCount(); i++) {
					CDynamicSlider *pDynamicSlider = m_arrDynamicSliders[i];
					if (pDynamicSlider == NULL) {
						AfxMessageBox("UpdateViews NULL pointer found");
						return;
					}
					if (!pDynamicSlider->isEnabled()) continue;
					bNoActiveSliders = FALSE;
					int value = pDynamicSlider->GetValue();
					if (value != seisParms->GetParmValue(i)) {
						bAllMatch = FALSE;
						break;
					}
				}
				if (bAllMatch && !bNoActiveSliders) {
					// we found a volume that matches all the parameters.
					m_viewIndex = ix;
					break;
				}
			}
			ix++;
		}
	}

	// inline and crossline combo boxes...
	SetModifiedFlag();
	if (!bSkipCombo) {
		// refresh the line select combo boxes
		if (GetFileCount() > 0) {
			CSegy *pSegy = GetSegyInPtr(0);
			CSegyIndex *pIndex = pSegy->GetSegyIndexPtr();
			DWORD lineCount;
			DWORD *pLine;

			// Update Inline combobox
			pIndex->GetLiveInlineNumbers(lineCount, &pLine);
			UpdateCombobox(lineCount, pLine, pApp->m_cmbInline, m_nDisplayInline);

			// Update Xline combobox
			pIndex->GetLiveXlineNumbers(lineCount, &pLine);
			UpdateCombobox(lineCount, pLine, pApp->m_cmbXline, m_nDisplayXline);

            // Update Userline combobox
            UpdateUserlineCombobox(pApp->m_cmbUserline, m_nDisplayUserline);
		}

		pApp->m_btnInline->SetCheck(GetInlineXlineMode() == eINLINE);
		pApp->m_btnXline->SetCheck(GetInlineXlineMode() == eXLINE);
        pApp->m_btnUserline->SetCheck(GetInlineXlineMode() == eUSERLINE);
    }

	// Time Slice...
	if (m_timeSlice.isActive() && m_timeSlice.isShowSliceFlag()) {
		if (m_timeSlice.isLoadSliceFlag()) {
			if (!m_timeSlice.Create(GetFileCount()+GetVirtualVolumeCount(), GetSegyInPtr(0)->GetSegyIndexPtr())) {
				m_timeSlice.Destroy();
				m_timeSlice.SetShowSliceFlag(FALSE);
			}
		}
		LoadTimeSlice(&m_timeSlice);
		m_timeSlice.SetLoadSliceFlag(FALSE);
	}
	
	// update the dialogs in the CDockablePane's 
	AfxGetMainWnd()->Invalidate();

	// destroy and recreate the filelist pane.
	ShowFilelistPane();

	m_bReadyToCompute = TRUE;
	ComputeEngine();

	// turn on update flag for all displays
	for (int i=0; i<GetXplotCount()+1; i++) {
		m_bReadyToDisplay[i] = TRUE;
	}

	UpdateMapSelectDlg();
	CDocument::UpdateAllViews(NULL);
	//TRACE("Leaving CIMACDoc::UpdateViews()\n");
}

void CIMACDoc::ShowFilelistPane()
{
	// destroy and recreate the filelist pane.
	if (IsShowFilelist()) {
		GetMainFrame()->ShowFilelistPane();
	}
}

void CIMACDoc::UpdateCombobox(DWORD lineCount, DWORD* pLine, CLineSelectCombo *pCombo, int currentLine) 
{
	CString txt;
	pCombo->ResetContent();
	int currentIndex = 0;

	for (DWORD i=0; i<lineCount; i++) {
		txt.Format("%d", pLine[i]);
		if (pLine[i] == currentLine) currentIndex = i;
		int status = pCombo->AddString(txt);
		if (status == CB_ERR || status == CB_ERRSPACE) {
			AfxMessageBox("error creating inline/crossline combo");
			break;
		}
	}
	pCombo->SetCurSel(currentIndex);
}

void CIMACDoc::UpdateUserlineCombobox(CLineSelectCombo *pCombo, int currentLine)
{
    CString txt;
    pCombo->ResetContent();
    int currentIndex = 0;

    DWORD userLineCount = GetUserLineCount();
    for (DWORD i = 0; i < userLineCount; i++) {
        pCombo->AddString(GetUserLineName(i));
    }

    int iSelect = GetSelectedUserLineNumber();
    pCombo->SetCurSel(iSelect);
}

void CIMACDoc::CloseTheDocument()   
{
	CloseHeadwaveWorkspace();
	CDocument::OnFileClose();
	CMainFrame *pMainFrame;
	pMainFrame = (CMainFrame *)AfxGetMainWnd();
	pMainFrame->DestroyFilelistPane();
}

//////////////////////////////
// user line member functions

int CIMACDoc::SetCurrentUserLine(CPointArray *pDigitizedLine, CString name)
{
	return SetUserLine(m_userLineSelected, pDigitizedLine, name);
}

int CIMACDoc::SetNewUserLine(CPointArray *pUserLine, CString name)
{
	int nextIndex = GetUserLineCount();
	m_userLineNameArray.SetAtGrow(nextIndex, name);
	CPointArray *pData = new CPointArray;
	pData->SetSize(0, 1000);
	m_userLineDataArray.SetAtGrow(nextIndex, (void *) pData);

    CDoublePointArray *pDoubleData = new CDoublePointArray;
    pDoubleData->SetSize(0, 1000);
    m_userLineSmoothedCoordinateArray.SetAtGrow(nextIndex, (void *)pDoubleData);


	return SetUserLine(nextIndex, pUserLine, name);
}

// Interpolate the digitized line to the nominal spacing of unity.
// flag the interpolated points as negative numbers.
int CIMACDoc::SetUserLine(DWORD i, CPointArray *pDigitizedLine, CString name)
{
	if (i >= GetUserLineCount()) return -1;
	SetUserLineName(i, name);

	CPointArray *pData = GetUserLinePtr(i);
	pData->RemoveAll();
    CDoublePointArray *pDoubleData = GetUserLineSmoothedCoordinatePtr(i);
    pDoubleData->RemoveAll();

	int inputCount = (int) pDigitizedLine->GetCount();
	if (inputCount == 0) return 0;

    // get the segyindex pointer
    CSegy *pSegy = GetFirstLoadedSegyPtr();
    if (pSegy == NULL) return -1;
    CSegyIndex *pIndex = pSegy->GetSegyIndexPtr();
    if (pIndex == NULL) return -1;
    if (pIndex->GetTraceCount() == 0) return -1;

	int lineIndex = 0;
	TRACE("digitized line");

    double xcoord1 = 0, ycoord1 = 0;
    double xcoord2 = 0, ycoord2 = 0;

	for (int i=1; i<inputCount; i++) {

        // setup for interpolating the inline and crossline numbers
		int x1 = pDigitizedLine->GetAt(i-1).x;
		int y1 = pDigitizedLine->GetAt(i-1).y;
		int x2 = pDigitizedLine->GetAt(i).x;
		int y2 = pDigitizedLine->GetAt(i).y;
		int nLocn = Nint ( sqrt((double)((x2-x1)*(x2-x1)) + (double)((y2-y1)*(y2-y1))) );
		float deltaX = (float)(x2 - x1) / (float) nLocn;
		float deltaY = (float)(y2 - y1) / (float) nLocn;

        // setup for interpolating the coordinates
        pIndex->FindTraceCoordinates(x1, y1, xcoord1, ycoord1);
        pIndex->FindTraceCoordinates(x2, y2, xcoord2, ycoord2);
        double deltaXcoord = (xcoord2 - xcoord1) / (double)nLocn;
        double deltaYcoord = (ycoord2 - ycoord1) / (double)nLocn;

        // do the interploation
		for (int j=0; j<nLocn; j++) {
			int intX = Nint (x1 + deltaX * j);
			int intY = Nint (y1 + deltaY * j);
            double intXcoord = xcoord1 + deltaXcoord * j;
            double intYcoord = ycoord1 + deltaYcoord * j;

			// flag the interpolated points.
			if (j > 0) intX = -intX;

			if (lineIndex > 0 && pData->GetAt(lineIndex-1) == CPoint(intX, intY)) continue; // skip duplicates
			pData->SetAtGrow(lineIndex, CPoint(intX, intY));
            pDoubleData->SetAtGrow(lineIndex, CDoublePoint(intXcoord, intYcoord));

            lineIndex++;
		}

    }
	pData->SetAtGrow(lineIndex, pDigitizedLine->GetAt(inputCount-1));
    pDoubleData->SetAtGrow(lineIndex, CDoublePoint(xcoord2, ycoord2));
    lineIndex++;
    return 0;
}
	
int CIMACDoc::SetUserLineName(DWORD i, CString name)
{
	if (i >= GetUserLineCount()) return -1;
	m_userLineNameArray.SetAt(i, name);
	return 0;
}

CPointArray *CIMACDoc::GetCurrentUserLinePtr() 
{ 
	return GetUserLinePtr(m_userLineSelected); 
}

CDoublePointArray *CIMACDoc::GetCurrentUserLineSmoothedCoordinatePtr()
{
    return GetUserLineSmoothedCoordinatePtr(m_userLineSelected);
}

CPointArray *CIMACDoc::GetUserLinePtr(DWORD i) 
{
	CPointArray *pReturnVal = NULL;
	if (i < GetUserLineCount()) {
		pReturnVal = (CPointArray *) m_userLineDataArray.GetAt(i); 
	}
	return pReturnVal;
}

CDoublePointArray *CIMACDoc::GetUserLineSmoothedCoordinatePtr(DWORD i)
{
    CDoublePointArray *pReturnVal = NULL;
    if (i < GetUserLineCount()) {
        pReturnVal = (CDoublePointArray *)m_userLineSmoothedCoordinateArray.GetAt(i);
    }
    return pReturnVal;
}

CDoublePoint CIMACDoc::GetSmoothedUserLineCoordinates(int inLine, int xLine)
{
    CPointArray *pUserLine = GetCurrentUserLinePtr();
    CDoublePointArray *pSmoothedCoordinateArray = GetCurrentUserLineSmoothedCoordinatePtr();
    CDoublePoint smoothPoint;
    if (pUserLine->GetCount() == pSmoothedCoordinateArray->GetCount()) {
        for (int i = 0; i < pUserLine->GetCount(); i++) {
            CPoint point = pUserLine->GetAt(i);
            if (point.x < 0) point.x = -point.x;
            if (point.x == inLine && point.y == xLine) {
                smoothPoint = pSmoothedCoordinateArray->GetAt(i);
                break;
            }
        }
    }
    return smoothPoint;
}

CString CIMACDoc::GetCurrentUserLineName()
{
	return GetUserLineName(m_userLineSelected);
}

CString CIMACDoc::GetUserLineName(DWORD i)
{
	CString strReturn;
	if (i < GetUserLineCount()) {
		strReturn =  m_userLineNameArray.GetAt(i); 
	}
	return strReturn;
}

void CIMACDoc::DeleteCurrentUserLine()
{
	if (GetUserLineCount() == 0) return;

	int iDelete = GetSelectedUserLineNumber();

	CPointArray *pData = GetUserLinePtr (iDelete);
	pData->RemoveAll();
	m_userLineDataArray.RemoveAt(iDelete);
	m_userLineNameArray.RemoveAt(iDelete);
    m_userLineSmoothedCoordinateArray.RemoveAt(iDelete);

	m_userLineSelected = 0;
}

// return the corresponding control point, else return -1
int CIMACDoc::GetUserLineControlPoint(DWORD inLine, DWORD xLine)
{
	if (GetUserLineCount() == 0) return -1;

	CPointArray *pData = GetCurrentUserLinePtr();
	int count = (int) pData->GetCount();
	int ptNum = -1;
	int iRet  = -1;
	for (int i=0; i<count; i++) {
		CPoint pt = pData->GetAt(i);
		if (pt.x > 0) {
			ptNum ++;
			if (inLine == pt.x && xLine == pt.y) {
				iRet = ptNum;
				break;
			}
		}
	}
	return iRet;
}
//////////////////////////////////////////

void CIMACDoc::InterpolateColorbar(COLORREF *pColorbar, int nColor)
{
	int ixs, ixe, i;

	// copy the first color to the start
	ixs = 0;
	while (pColorbar[ixs] == NOCOLOR && ixs<nColor) ixs++;
	if (ixs == nColor) {
		AfxMessageBox("Nothing to do. No colors selected yet");
		return;
	}
	for (i=0; i<ixs; i++) {
		pColorbar[i] = pColorbar[ixs];
	}

	// copy the last color to the end
	ixe = nColor - 1;
	while (pColorbar[ixe] == NOCOLOR && ixe >= 0) ixe--;
	for (i = ixe + 1; i<nColor; i++) {
		pColorbar[i] = pColorbar[ixe];
	}

	// interpolate the spaces in the middle
	ixs=0;
	while (TRUE) {
		while (pColorbar[ixs] != NOCOLOR && ixs<nColor) ixs++;
		if (ixs == nColor) break;
		ixs--;
		ixe=ixs+1;
		while (pColorbar[ixe] == NOCOLOR) ixe++;
		for (i=ixs+1; i<ixe; i++) {
			int red1 = GetRValue(pColorbar[ixs]);
			int grn1 = GetGValue(pColorbar[ixs]);
			int blu1 = GetBValue(pColorbar[ixs]);
			int red2 = GetRValue(pColorbar[ixe]);
			int grn2 = GetGValue(pColorbar[ixe]);
			int blu2 = GetBValue(pColorbar[ixe]);
			float r = (float)(i-ixs)/(float)(ixe-ixs);
			int redx = (int)((red2-red1) * r) + red1;
			int grnx = (int)((grn2-grn1) * r) + grn1;
			int blux = (int)((blu2-blu1) * r) + blu1;
			pColorbar[i] = RGB(redx, grnx, blux);
		}
	}
}

//
// Return the index of the vertex if the point is within MERR units, otherwise return -1
//
int CIMACDoc::isPointNearPolyVertex(float x, float y, CCutoffParms *pCutoff)
{
	int nPoint = pCutoff->m_nPolyData;

	for (int i=0; i<nPoint-1; i++) {
		CPoint pt = pCutoff->m_arrPolyData[i];
		if (x > pt.x - MERR && x < pt.x + MERR &&
			y > pt.y - MERR && y < pt.y + MERR)
		{
			return i;
		}
	}
	return -1;
}

//
// Return the ellipse axis if the point is within MERR units, otherwise return -1
//
int CIMACDoc::isPointNearEllipseAxis(float x, float y, CCutoffParms *pCutoff)
{
	CPoint axis = pCutoff->m_ellipse.GetXAxisEndPoint();
	if (x > axis.x - MERR && x < axis.x + MERR &&
		y > axis.y - MERR && y < axis.y + MERR)
	{
		return 0;
	}

	axis = pCutoff->m_ellipse.GetYAxisEndPoint();
	if (x > axis.x - MERR && x < axis.x + MERR &&
		y > axis.y - MERR && y < axis.y + MERR)
	{
		return 1;
	}

	return -1;
}

void CIMACDoc::DeleteXplotParms(int n)
{
	CXplotParms *pCurr, *pNext;

	int nXplot = GetXplotCount();

	if (n < nXplot-1) {
		// copy the xplot parameters data from the next slot
		for (int i=n; i<nXplot-1; i++) {
			pCurr=GetXplotParms(i);
			pNext=GetXplotParms(i+1);

			*pCurr = *pNext;		// copy the entire contents. '=' operator

			pNext->ResetXplotVariables();

			SetInitializeXplotViewFlag(i, TRUE);
		}
	} else {
		// if it's the last xplot then just zap it's parameters
		pCurr = GetXplotParms(n);
		pCurr->ResetXplotVariables();
		SetInitializeXplotViewFlag(n, TRUE);
	}

	// all the xplot panes have to be refreshed
	SetUpdateXplotPaneFlagsAll(TRUE);

	//  disable the last menu.
	bMenuParms[nXplot-1]=FALSE;
	bMenuXPlots[nXplot-1]=FALSE;

	// keep track of how many crossplots we have.
	SetXplotCount(nXplot-1);

	// if HW mode then update the workflow
	CreateHeadwaveWorkflow();

	UpdateViews();
}

void CIMACDoc::ValidateZones()
{
	// loop backwards so removing zones doesn't mess us up.
	for(int i = (int) m_viewZoneArray.GetCount()-1; i >= 0; i--) {
		CViewZone zone = m_viewZoneArray[i];
		CString topHorizon = zone.GetZoneTopReference();
		CString bottomHorizon = zone.GetZoneBottomReference();
		if(!m_pHorizon->Contains(topHorizon) && topHorizon != CHorizon::TIME_ZERO) {
			TRACE("Removed Zone '%s' because reference to top Horizon '%s' is invalid.\n", zone.GetZoneName(), topHorizon);
			m_viewZoneArray.RemoveAt(i);
			SetUpdateXplotPaneFlagsAll(TRUE);
		} else if(!m_pHorizon->Contains(bottomHorizon) && bottomHorizon != CHorizon::TIME_ZERO) {
			TRACE("Removed Zone '%s' because reference to bottom Horizon '%s' is invalid.\n", zone.GetZoneName(), bottomHorizon);
			m_viewZoneArray.RemoveAt(i);
			SetUpdateXplotPaneFlagsAll(TRUE);
		}
	}
}

void CIMACDoc::ValidateTimeslice()
{
	CString horizon = m_timeSlice.GetSliceReference();
	if(!m_pHorizon->Contains(horizon) && horizon != CHorizon::TIME_ZERO) {
		TRACE("Removed Timeslice because reference to Horizon '%s' is invalid.\n", horizon);
		m_timeSlice.Destroy();
		m_timeSlice.Initalize();
		m_timeSlice.SetShowSliceFlag(FALSE);
		m_timeSlice.SetActiveFlag(FALSE);
	}
}

void CIMACDoc::ValidateSampleInterval()
{
    int sampleIntervalFromFiles = -1;
    while (sampleIntervalFromFiles == -1) {
        int sampleIntervalFromDoc = GetSI();
        for (int i = 0; i < GetFileCount(); i++) {
			CSegyIndex *pSegyIndex = GetSegyInPtr(i)->GetSegyIndexPtr();
            int sampleInterval = -1;
            if (pSegyIndex != NULL) {
                sampleInterval = GetSegyInPtr(i)->GetSegyIndexPtr()->GetSampleInterval();
            }
            if (i == 0) {
                sampleIntervalFromFiles = sampleInterval;
            }
            if (sampleIntervalFromFiles != sampleInterval) {
                sampleIntervalFromFiles = -1;
            }
        }

        // if all the files have the same sample interval and it's different from what the document has 
        // then update the document and carry on.
        if (sampleIntervalFromFiles != -1 && sampleIntervalFromFiles != sampleIntervalFromDoc) {
            CString msg;
            msg.Format("Updating Sample Interval to the value found in the input files: %d", sampleIntervalFromFiles);
            AfxMessageBox(msg);
            SetSI(sampleIntervalFromFiles);
        }

        // if the sample interval in the files is not consistant then we have a problem.
        if (sampleIntervalFromFiles == -1) {
            CString msg;
            msg = "A discrepancy was found with the Sample Interval values in the input files.\n\n";
            msg += "It is a requirement that the Sample Interval must be the same in all input files.\n\n";
            msg += "Please fix the input files so QI-Pro may continue.";
            AfxMessageBox(msg);

            CIMACApp *pApp = (CIMACApp *)AfxGetApp();
            pApp->OnEditParms();
        }
    }
}

void CIMACDoc::DestroyWellData()
{
	// destroy the well list
	WellList *pWellList = GetWellListPtr();
	CWell *pWell;
	POSITION pos = pWellList->GetHeadPosition();
	while (pos) {
		pWell = pWellList->GetNext(pos);
		pWell->Destroy();
		delete pWell;
	}
	pWellList->RemoveAll();
	
	// destroy all well sub lists and their names.
	WellSubListMgr  *pWellSubListMgr = GetWellListMgrPtr();
	pos = pWellSubListMgr->GetHeadPosition();
	while (pos) {
		WellSubList *pSubList = pWellSubListMgr->GetNext(pos);
		pSubList->RemoveAll();
		delete pSubList;
	}
	pWellSubListMgr->RemoveAll();
}

void CIMACDoc::InitWellDatabase()
{
	DestroyWellData();
	WellSubList *pSubList = new WellSubList;
	m_wellSubListMgr.AddHead(pSubList);
	CString name = "All Wells";
	m_wellSubListNames.AddHead(name);
}


//
// A static function to find the pointer to the current document. This is not a member of 
// the document object, rather it's used to find that object.
//
CIMACDoc * CIMACDoc::GetIMACDocPtr()
{
	POSITION pos = AfxGetApp()->GetFirstDocTemplatePosition();
	if (pos == NULL) return NULL;
	CDocTemplate* pDt = AfxGetApp()->GetNextDocTemplate(pos);
	POSITION pos2 = pDt->GetFirstDocPosition();
	if (pos2 == NULL) return NULL;
	return ((CIMACDoc *)pDt->GetNextDoc(pos2));
}

/* old and slow method, here for comparison purposes */
int CIMACDoc::ComputeDensityTable(int viewInstance, CSegy *pSegyX, CSegy *pSegyY, int startTime, int endTime, int **pDensityTable, int *denTableMax)
{
	clock_t start, finish;
	start = clock();

	int *densityTable;
	CXplotParms *pXpParms;
	pXpParms = GetXplotParms(viewInstance);

	if (pXpParms->m_binXsize == 0) {
		// use a reasonable default
		pXpParms->m_binXsize = (pXpParms->m_fXMax - pXpParms->m_fXMin) / 10.0f;
	}
	if (pXpParms->m_binYsize == 0) {
		// use a reasonable default
		pXpParms->m_binYsize = (pXpParms->m_fYMax - pXpParms->m_fYMin) / 10.0f;
	}

	float binX = pXpParms->m_binXsize;
	float binY = pXpParms->m_binYsize;

	float halfBinX = binX / 2;
	float halfBinY = binY / 2;

	int si = GetSI();			// note: si in MICRO seconds. 
	int nsamps = Time2Index((endTime - startTime), si) + 1;
	int nbin = pSegyX->GetTraceCount() * nsamps;

	*denTableMax = 0;
	*pDensityTable = new int[nbin];
	if (*pDensityTable == NULL) {
		AfxMessageBox("Error allocating Density Table");
		pXpParms->m_nScatterMode = eCLASS;
		return -1;
	}
	densityTable = *pDensityTable;
	int maxBinCount = 0;
	// initalize the table.
	for (int j = 0; j<nbin; j++) {
		densityTable[j] = 0;
	}

	int denIndex = 0;
	for (int j = 0; j<pSegyX->GetTraceCount(); j++) {
		float *pX = pSegyX->GetTraceDataPtr(j, startTime);
		float *pY = pSegyY->GetTraceDataPtr(j, startTime);
		for (int k = 0; k<nsamps; k++) {
			// for each sample look at all the data to find the number of points in range
			for (int itr = 0; itr<pSegyX->GetTraceCount(); itr++) {
				float *pXtmp = pSegyX->GetTraceDataPtr(itr, startTime);
				float *pYtmp = pSegyY->GetTraceDataPtr(itr, startTime);
				for (int isamp = 0; isamp<nsamps; isamp++) {
					if (pXtmp[isamp]>pX[k] - halfBinX && pXtmp[isamp]<pX[k] + halfBinX &&
						pYtmp[isamp]>pY[k] - halfBinY && pYtmp[isamp]<pY[k] + halfBinY)
					{
						densityTable[denIndex]++;
					}
				}
			}
			if (densityTable[denIndex] > maxBinCount) maxBinCount = densityTable[denIndex];
			denIndex++;
		}
	}
	if (pXpParms->m_colorBarMax != 0) {
		maxBinCount = pXpParms->m_colorBarMax;
	} else {
		pXpParms->m_colorBarMax = maxBinCount;
	}

	// map the points to colors
	float factor = (float)(DENSITYBARSIZE - 1) / (float)(maxBinCount - pXpParms->m_colorBarMin);
	for (int j = 0; j<nbin; j++) {
		densityTable[j] = (int)((float)(densityTable[j] - pXpParms->m_colorBarMin) * factor);
	}

	*denTableMax = maxBinCount;

	finish = clock();
	double duration = (double)(finish - start) / CLOCKS_PER_SEC;
	TRACE("Density table computed in %2.1f seconds\n", duration);

	return 0;
}

int CIMACDoc::ComputeDensityTableFast(int viewInstance, CSegy *pSegyX, CSegy *pSegyY, int startTime, int endTime, 
	int **pDensityTable, int *denTableMax, CViewZoneArray *viewZoneArray)
{
	clock_t start, sortTime, finish;
	start = clock();
	
	CModelessInfoDlg infoDlg;

	int *densityTable;
	int *sortedTable;
	DWORD *sortOrder;
	float *pBinX;
	float *pBinY;
	CXplotParms *pXpParms;
	pXpParms = GetXplotParms(viewInstance);

	if(pXpParms->m_binXsize == 0) {
		// use a reasonable default
		pXpParms->m_binXsize = (pXpParms->m_fXMax - pXpParms->m_fXMin) / 10.0f;
	}
	if(pXpParms->m_binYsize == 0) {
		// use a reasonable default
		pXpParms->m_binYsize = (pXpParms->m_fYMax - pXpParms->m_fYMin) / 10.0f;
	}

	float binXsize = pXpParms->m_binXsize;
	float binYsize = pXpParms->m_binYsize;
	float halfBinX = binXsize/2;
	float halfBinY = binYsize/2;

	// Allocate the memory
	int si = GetSI();			// note: si in MICRO seconds. 
	int nsamps = Time2Index((endTime - startTime), si) + 1; 
	int nbin = pSegyX->GetTraceCount() * nsamps;
	densityTable = new int[nbin];
	sortedTable = new int[nbin];
	sortOrder = new DWORD[nbin];
	pBinX = new float[nbin];
	pBinY = new float[nbin];
	if (densityTable==NULL ||sortedTable==NULL || sortOrder==NULL || pBinX==NULL || pBinY==NULL) {
		AfxMessageBox("Error allocating mamory for Density Table");
		pXpParms->m_nScatterMode = eCLASS;
		return -1;
	}

	// Get the thread info, tell the user.
	int nThreads = m_numberOfProcessors;
	int nchunk = nbin / nThreads;
	CString txt;
	txt.Format("Calculating points density.\n\n");				  infoDlg.ShowMessage(txt);
	txt.Format("          Number of points  = %d\n", nbin);		  infoDlg.AddString(txt);
	txt.Format("          Number of threads = %d\n", nThreads);   infoDlg.AddString(txt);
	txt.Format("          Points per thread = %d\n\n", nchunk);   infoDlg.AddString(txt);
	txt.Format("          X Bin Size = %5.2f\n", binXsize);       infoDlg.AddString(txt);
	txt.Format("          Y Bin Size = %5.2f\n\n", binYsize);     infoDlg.AddString(txt);
	txt.Format("Calculating...");
	infoDlg.AddString(txt);

	// get the data
	CHorizon *pHorizon = GetHorizonDataPtr();
	int denIndex = 0;
	int zoneCount = (int) viewZoneArray->GetCount();
	for (int j=0; j<pSegyX->GetTraceCount(); j++) {
		float *pX = pSegyX->GetTraceDataPtr(j, startTime);
		float *pY = pSegyY->GetTraceDataPtr(j, startTime);

		// load up the zone arrays for this trace
		for (int izone=0; izone<zoneCount; izone++) {
			viewZoneArray->GetAt(izone).SetRange(pSegyX->GetInline(j), pSegyX->GetCrossline(j), pHorizon);
		}

		for (int k=0; k<nsamps; k++) {
			pBinX[denIndex] = pX[k];
			pBinY[denIndex] = pY[k];

			// check if point is within a selected zone
			BOOL bZoneCheck = (zoneCount == 0);
			for (int izone=0; izone<zoneCount; izone++) {
				bZoneCheck = viewZoneArray->GetAt(izone).CheckRange(k);
				if(	bZoneCheck ) break;
			}
			if (bZoneCheck) {
				densityTable[denIndex] = 0;
			} else {
				densityTable[denIndex] = -1;  // flag indicates that sample not in a zone.
			}
			sortOrder[denIndex] = denIndex;
			denIndex++;
		}
	}

	// sort the X data, Y will follow. Keep track of sort order.
	QuickSort4ArgInplace(pBinX, pBinY, densityTable, sortOrder, nbin);

	sortTime = clock();

	// count the points that fall within each bin. Use threads for this.
	for (int i=0; i<nThreads; i++) {
		taskparm[i].nbin = nbin;
		taskparm[i].istart = i * nchunk;
		taskparm[i].iend = ((i+1) * nchunk)-1;
		taskparm[i].pBinX = pBinX;
		taskparm[i].pBinY = pBinY;
		taskparm[i].densityTable = densityTable;
		taskparm[i].halfBinX = halfBinX;
		taskparm[i].halfBinY = halfBinY;
	}
	taskparm[nThreads-1].iend = nbin-1;

	// start the threads
	for (int i=0; i<nThreads; i++) {
		pThreads[i] = AfxBeginThread(DensityTableThreadTask, &taskparm[i], THREAD_PRIORITY_NORMAL, 1024, CREATE_SUSPENDED);
		if (pThreads[i] == NULL) {
			AfxMessageBox("failed to start thread");
		} else {
			handles[i] = pThreads[i]->m_hThread;
			// we need to start the threads this way due to a bug in WaitForMultipleObjects
			pThreads[i]->m_bAutoDelete = FALSE;
			pThreads[i]->ResumeThread();
		}
	}

	DWORD istat = WaitForMultipleObjects(nThreads, handles, TRUE, INFINITE);
	if (istat != WAIT_OBJECT_0) {
			AfxMessageBox("Error waiting for threads");
	}

	//delete the thread objects
	for (int i=0; i<nThreads; i++) {
		delete(pThreads[i]);
	}

	int maxBinCount = 0;
	for (int i=0; i<nbin; i++) {
		if (densityTable[i] > maxBinCount) maxBinCount = densityTable[i];
	}

	// map the points to colors
	if (pXpParms->m_colorBarMax != 0) {
		maxBinCount = pXpParms->m_colorBarMax;
	} else {
		pXpParms->m_colorBarMax = maxBinCount;
	}

	float factor = (float)(DENSITYBARSIZE-1) / (float)(maxBinCount - pXpParms->m_colorBarMin);
	for (int j=0; j<nbin; j++) {
		if (densityTable[j] == -1) continue;
		densityTable[j] = (int) ( (float) (densityTable[j] - pXpParms->m_colorBarMin) * factor );
	}

	// we have to unscramble the data so it makes sense for the display.
	UnSort(densityTable, sortedTable, sortOrder, nbin);
	*denTableMax = maxBinCount;
	*pDensityTable = sortedTable;

	delete densityTable;
	delete sortOrder;
	delete pBinX;
	delete pBinY;

	finish = clock();
	double duration1 = (double) (sortTime-start) / CLOCKS_PER_SEC;
	double duration2 = (double) (finish-start) / CLOCKS_PER_SEC;
	TRACE("Density table. Sort %3.2f seconds. Threads %2.1f seconds.", duration1, duration2);

	infoDlg.DestroyWindow();

	return 0; 
}

UINT __cdecl CIMACDoc::DensityTableThreadTask(LPVOID pParm)
{
	PTS_DENSITY_PARM *pData = (PTS_DENSITY_PARM *) pParm;
	int nbin = pData->nbin;
	int istart = pData->istart;
	int iend = pData->iend;
	float *pBinX = pData->pBinX;
	float *pBinY = pData->pBinY;
	int *densityTable = pData->densityTable;
	float halfBinX = pData->halfBinX;
	float halfBinY = pData->halfBinY;
	CIMACDoc::CountBinPoints(nbin, istart, iend, pBinX, pBinY, densityTable, halfBinX, halfBinY);
	return 0;
}

#if 1
void CIMACDoc::CountBinPoints(int nbin, int istart, int iend, float *pBinX, float *pBinY, int *densityTable, float halfBinX, float halfBinY)
{
	// find the inital position of the x window
	float binXlow = pBinX[istart] - halfBinX;
	float binXhi = pBinX[istart] + halfBinX;
	float binYlow = pBinY[istart] - halfBinY;
	float binYhi = pBinY[istart] + halfBinY;
	int ixMin = istart;
	int ixMax = istart;
	while (ixMin > 0 && pBinX[ixMin] >= binXlow) ixMin--;
	while (ixMax < nbin - 1 && pBinX[ixMax] <= binXhi) ixMax++;
	if (ixMin < nbin - 1 && ixMin < istart) ixMin++;
	if (ixMax > 0 && ixMax > istart) ixMax--;

	for (int i = istart; i <= iend; i++) {
		// adjust the X window for each sample
		float binXlow = pBinX[i] - halfBinX;
		float binXhi = pBinX[i] + halfBinX;
		float binYlow = pBinY[i] - halfBinY;
		float binYhi = pBinY[i] + halfBinY;

		while (ixMin < nbin - 1 && pBinX[ixMin] < binXlow) ixMin++;
		if (ixMin > nbin - 1) ixMin = nbin - 1;

		while (ixMax < nbin  && pBinX[ixMax] < binXhi) ixMax++;
		if (ixMax >= nbin) ixMax = nbin - 1;

		// Search the X window counting samples that fall inside the Y bounds
		for (int j = ixMin; j <= ixMax; j++) {
			if (densityTable[i] == -1) continue;
			if (pBinY[j] >= binYlow && pBinY[j] <= binYhi && densityTable[j] > -1) densityTable[i]++;
		}

	}
}
#else
void CIMACDoc::CountBinPoints(int nbin, int istart, int iend, float *pBinX, float *pBinY, int *densityTable, float halfBinX, float halfBinY)
{
	for (int i = istart; i <= iend; i++) {
		// define the bin for this sample
		float binXlow = pBinX[i] - halfBinX;
		float binXhi = pBinX[i] + halfBinX;
		float binYlow = pBinY[i] - halfBinY;
		float binYhi = pBinY[i] + halfBinY;
		// find the start and end index in the X array
		int ixMin = i;
		int ixMax = i;
		while (ixMin > 0 && pBinX[ixMin] >= binXlow) ixMin--;
		while (ixMax < nbin - 1 && pBinX[ixMax] <= binXhi) ixMax++;
		if (ixMin >= 0 && ixMin < i) ixMin++;
		if (ixMax <= nbin - 1 && ixMax > i) ixMax--;
		// now look for samples that fall inside the Y bounds
		for (int j = ixMin; j <= ixMax; j++) {
			if (densityTable[i] == -1) continue;
			if (pBinY[j] >= binYlow && pBinY[j] <= binYhi && densityTable[j] > -1) densityTable[i]++;
		}

	}
}
#endif

int CIMACDoc::ComputeDensityNodeTable(int viewInstance, CSegy *pSegyX, CSegy *pSegyY, int startTime, int endTime,
	int **pDensityTable, int *denTableMax, CViewZoneArray *viewZoneArray, 
	MATRIX_NODE **pMatrix, DENSITY_NODE **pArrNodes, int *pDensityTable_size, int *pMatrix_size, int *pArrNodes_size)
{
	clock_t start, count, finish;
	start = clock();

	CModelessInfoDlg infoDlg;

	int *densityTable;
	CXplotParms *pXpParms;
	pXpParms = GetXplotParms(viewInstance);

	if (pXpParms->m_binXsize == 0) {
		// use a reasonable default
		pXpParms->m_binXsize = (pXpParms->m_fXMax - pXpParms->m_fXMin) / 25.0f;
	}
	if (pXpParms->m_binYsize == 0) {
		// use a reasonable default
		pXpParms->m_binYsize = (pXpParms->m_fYMax - pXpParms->m_fYMin) / 25.0f;
	}

	float binX = pXpParms->m_binXsize;
	float binY = pXpParms->m_binYsize;

	float halfBinX = binX / 2;
	float halfBinY = binY / 2;

	int si = GetSI();			// note: si in MICRO seconds. 
	int nsamps = Time2Index((endTime - startTime), si) + 1;
	int traceCount = pSegyX->GetTraceCount();
	int sampleCount = traceCount * nsamps;

	*denTableMax = 0;
	if (sampleCount > *pDensityTable_size){
		if (*pDensityTable) delete *pDensityTable;
	*pDensityTable = new int[sampleCount];
		*pDensityTable_size = sampleCount;
	}
	
	if (sampleCount > *pArrNodes_size){
		if (*pArrNodes) delete *pArrNodes;
		*pArrNodes = new DENSITY_NODE[sampleCount];
		*pArrNodes_size = sampleCount;
	}
	DENSITY_NODE *arrNodes = *pArrNodes;

	if (*pDensityTable == NULL) {
		AfxMessageBox("Error allocating Density Table");
		pXpParms->m_nScatterMode = eCLASS;
		return -1;
	}
	densityTable = *pDensityTable;

	// initalize..
	memset(densityTable, 0, sizeof(int)*sampleCount);
	memset(*pArrNodes, 0, sizeof(DENSITY_NODE)*sampleCount);

	// initalize min max
	float *pX = pSegyX->GetTraceDataPtr(0, startTime);
	float *pY = pSegyY->GetTraceDataPtr(0, startTime);
	float minx = pX[0];
	float maxx = pX[0];
	float miny = pY[0];
	float maxy = pY[0];

	// zone filter
	CHorizon *pHorizon = GetHorizonDataPtr();
	int denIndex = 0;
	int zoneCount = (int) viewZoneArray->GetCount();

	// Load the node array
	// The node array is the master list of points, contains the index back to the cell of the Matrix where it belongs
	// and a list of other points that belong to the same matrix node.  The head of the list is in the Matrix.
	DENSITY_NODE *pNode = arrNodes;
	for (int j = 0; j < traceCount; j++) {
		float *pX = pSegyX->GetTraceDataPtr(j, startTime);
		float *pY = pSegyY->GetTraceDataPtr(j, startTime);
		// load up the zone arrays for this trace
		for (int izone = 0; izone<zoneCount; izone++) {
			viewZoneArray->GetAt(izone).SetRange(pSegyX->GetInline(j), pSegyX->GetCrossline(j), pHorizon);
		}

		for (int k = 0; k < nsamps; k++) {

			// check if point is within a selected zone
			BOOL bZoneCheck = (zoneCount == 0);
			for (int izone = 0; izone<zoneCount; izone++) {
				bZoneCheck = viewZoneArray->GetAt(izone).CheckRange(k);
				if (bZoneCheck) break;
			}
			if (bZoneCheck) {
				densityTable[denIndex] = 0;
				pNode->ignore = FALSE;
			} else {
				densityTable[denIndex] = -1;  // flag indicates that sample not in a zone.
				pNode->ignore = TRUE;
			}

			// initalize node
			pNode->x = pX[k];
			if (pNode->x < minx) minx = pNode->x;
			if (pNode->x > maxx) maxx = pNode->x;
			pNode->y = pY[k];
			if (pNode->y < miny) miny = pNode->y;
			if (pNode->y > maxy) maxy = pNode->y;
			pNode->ignore = (densityTable[denIndex] == -1);
			pNode->pNext = NULL;
			pNode++;
		}
	}

	// Create the matrix, allocate an extra cell in each direction. Cell size is half a bin size.
	// The Matrix nodes contain a list to all the points in that cell as well as the count.
	int nbinx = (int)((maxx - minx) / halfBinX) + 3;
	int nbiny = (int)((maxy - miny) / halfBinY) + 3;
	int matrixCount = nbinx * nbiny;
	if (matrixCount > *pMatrix_size){
		if (*pMatrix) delete *pMatrix;
		*pMatrix = new MATRIX_NODE[matrixCount];
		*pMatrix_size = matrixCount;
	}
	memset(*pMatrix, 0, sizeof(MATRIX_NODE)*matrixCount);
	MATRIX_NODE *matrix = *pMatrix;

	// load the matrix
	for (int j = 0; j < sampleCount; j++){
		if (arrNodes[j].ignore) continue; // zone filter
		float localX = (arrNodes[j].x - minx) / halfBinX;
		float localY = (arrNodes[j].y - miny) / halfBinY;
		int ix = (int)localX + 1;
		int iy = (int)localY + 1;

		int mIndex = (iy*nbinx) + ix;
		ASSERT(mIndex >= nbinx);
		ASSERT(mIndex < matrixCount);
		arrNodes[j].index = mIndex;
		arrNodes[j].pNext = matrix[mIndex].ptr;
		if (mIndex == 201){
			mIndex = mIndex;
		}
		matrix[mIndex].ptr = &arrNodes[j];
		matrix[mIndex].count++;
		if (mIndex != 201){
			mIndex = mIndex;
		}
	}

	count = clock();
	// setup for running the counting threads
	SYSTEM_INFO sysInfo;
	GetSystemInfo(&sysInfo);
	int nThreads = sysInfo.dwNumberOfProcessors;

	// for debug, remove later
	// nThreads = 1;

	int nchunk = sampleCount / nThreads;
	CString txt;
	txt.Format("Calculating points density.\n\n");				  infoDlg.ShowMessage(txt);
	txt.Format("          Number of points  = %d\n", sampleCount); infoDlg.AddString(txt);
	txt.Format("          Number of threads = %d\n", nThreads);   infoDlg.AddString(txt);
	txt.Format("          Points per thread = %d\n\n", nchunk);   infoDlg.AddString(txt);
	txt.Format("          X Bin Size = %5.2f\n", binX);       infoDlg.AddString(txt);
	txt.Format("          Y Bin Size = %5.2f\n\n", binY);     infoDlg.AddString(txt);
	txt.Format("Calculating...");
	infoDlg.AddString(txt);

	NODE_DENSITY_PARM *taskparm = nodeparm;
	for (int i = 0; i<nThreads; i++) {
		taskparm[i].arrNodes = arrNodes;
		taskparm[i].matrix = matrix;
		taskparm[i].densityTable = densityTable;
		taskparm[i].istart = i * nchunk;
		taskparm[i].iend = ((i + 1) * nchunk) - 1;
		taskparm[i].nbinx = nbinx;
		taskparm[i].halfBinX = halfBinX;
		taskparm[i].halfBinY = halfBinY;
	}
	taskparm[nThreads - 1].iend = sampleCount - 1;

	// start the threads
	for (int i = 0; i<nThreads; i++) {
		pThreads[i] = AfxBeginThread(DensityNodeThreadTask, &taskparm[i], THREAD_PRIORITY_NORMAL, 1024, CREATE_SUSPENDED);
		if (pThreads[i] == NULL) {
			AfxMessageBox("failed to start thread");
		} else {
			handles[i] = pThreads[i]->m_hThread;
			// we need to start the threads this way due to a bug in WaitForMultipleObjects
			pThreads[i]->m_bAutoDelete = FALSE;
			pThreads[i]->ResumeThread();
		}
	}

	DWORD istat = WaitForMultipleObjects(nThreads, handles, TRUE, INFINITE);
	if (istat != WAIT_OBJECT_0) {
		AfxMessageBox("Error waiting for threads");
	}

	//delete the thread objects
	for (int i = 0; i<nThreads; i++) {
		delete(pThreads[i]);
	}

	int maxBinCount = 0;
	for (int i = 0; i<sampleCount; i++){
		if (densityTable[i] > maxBinCount) maxBinCount = densityTable[i];
	}

	if (pXpParms->m_colorBarMax != 0) {
		maxBinCount = pXpParms->m_colorBarMax;
	} else {
		pXpParms->m_colorBarMax = maxBinCount;
	}

	// map the points to colors
	float factor = (float)(DENSITYBARSIZE - 1) / (float)(maxBinCount - pXpParms->m_colorBarMin);
	for (int j = 0; j<sampleCount; j++) {
		densityTable[j] = (int)((float)(densityTable[j] - pXpParms->m_colorBarMin) * factor);
	}

	*denTableMax = maxBinCount;

	finish = clock();
	double duration = (double)(count - start) / CLOCKS_PER_SEC;
	TRACE("Density table initalize %f seconds\n", duration);
	duration = (double)(finish - count) / CLOCKS_PER_SEC;
	TRACE("Density table count %f seconds\n", duration);
	duration = (double)(finish - start) / CLOCKS_PER_SEC;
	TRACE("Density table computed in %f seconds\n", duration);

	return 0;
}

UINT __cdecl CIMACDoc::DensityNodeThreadTask(LPVOID pParm)
{
	NODE_DENSITY_PARM *pData = (NODE_DENSITY_PARM *)pParm;
	DENSITY_NODE *arrNodes = (DENSITY_NODE *)pData->arrNodes;
	MATRIX_NODE *matrix = (MATRIX_NODE *)pData->matrix;
	int *densityTable = pData->densityTable;
	int istart = pData->istart;
	int iend = pData->iend;
	int nbinx = pData->nbinx;
	float halfBinX = pData->halfBinX;
	float halfBinY = pData->halfBinY;
	CIMACDoc::CountNodeBinPoints(arrNodes, matrix, istart, iend, densityTable, nbinx, halfBinX, halfBinY);
	return 0;
}

void CIMACDoc::CountNodeBinPoints(DENSITY_NODE *arrNodes, MATRIX_NODE *matrix, int iStart, int iEnd, int *densityTable, int nbinx, float halfBinX, float halfBinY)
{
	for (int i = iStart; i <= iEnd; i++){
		if (densityTable[i] == -1) continue;
		if (arrNodes[i].ignore) continue;
		int nodeIndex = arrNodes[i].index;
		int nPoint = matrix[nodeIndex].count;

		int ixSearch = nodeIndex - nbinx - 1;
		nPoint += CountNodeList_SE(&arrNodes[i], (DENSITY_NODE *)matrix[ixSearch].ptr, halfBinX, halfBinY);
		nPoint += CountNodeList_S(&arrNodes[i], (DENSITY_NODE *)matrix[++ixSearch].ptr, halfBinX, halfBinY);
		nPoint += CountNodeList_SW(&arrNodes[i], (DENSITY_NODE *)matrix[++ixSearch].ptr, halfBinX, halfBinY);
		ixSearch = nodeIndex - 1;
		nPoint += CountNodeList_E(&arrNodes[i], (DENSITY_NODE *)matrix[ixSearch].ptr, halfBinX, halfBinY);
		nPoint += CountNodeList_W(&arrNodes[i], (DENSITY_NODE *)matrix[ixSearch + 2].ptr, halfBinX, halfBinY);
		ixSearch = nodeIndex + nbinx - 1;
		nPoint += CountNodeList_NE(&arrNodes[i], (DENSITY_NODE *)matrix[ixSearch].ptr, halfBinX, halfBinY);
		nPoint += CountNodeList_N(&arrNodes[i], (DENSITY_NODE *)matrix[++ixSearch].ptr, halfBinX, halfBinY);
		nPoint += CountNodeList_NW(&arrNodes[i], (DENSITY_NODE *)matrix[++ixSearch].ptr, halfBinX, halfBinY);

		densityTable[i] = nPoint;

	}
}

int  CIMACDoc::CountNodeList_NE(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float min = pNode->x - binx;
	float max = pNode->y + biny;
	while (pList != NULL){
		if (pList->x > min  && pList->y < max)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}
int  CIMACDoc::CountNodeList_N(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float max = pNode->y + biny;
	while (pList != NULL){
		if (pList->y < max)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}
int  CIMACDoc::CountNodeList_NW(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float maxx = pNode->x + binx;
	float maxy = pNode->y + biny;
	while (pList != NULL){
		if (pList->x < maxx && pList->y < maxy)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}
int  CIMACDoc::CountNodeList_E(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float min = pNode->x - binx;
	while (pList != NULL){
		if (pList->x > min)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}
int  CIMACDoc::CountNodeList_W(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float max = pNode->x + binx;
	while (pList != NULL){
		if (pList->x < max)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}
int  CIMACDoc::CountNodeList_SE(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float minx = pNode->x - binx;
	float miny = pNode->y - biny;
	while (pList != NULL){
		if (pList->x > minx && pList->y > miny)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}
int  CIMACDoc::CountNodeList_S(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float min = pNode->y - biny;
	while (pList != NULL){
		if (pList->y > min)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}
int  CIMACDoc::CountNodeList_SW(DENSITY_NODE *pNode, DENSITY_NODE *pList, float binx, float biny)
{
	int count = 0;
	float min = pNode->y - biny;
	float max = pNode->x + binx;
	while (pList != NULL){
		if (pList->x < max && pList->y > min)
			count++;
		pList = (DENSITY_NODE *)pList->pNext;
	}
	return count;
}

BOOL CIMACDoc::OnSaveDocument(LPCTSTR lpszPathName)
{
	return CDocument::OnSaveDocument(lpszPathName);
}
BOOL CIMACDoc::OnOpenDocument(LPCTSTR lpszPathName)
{
	m_tempPathName = lpszPathName;
	return CDocument::OnOpenDocument(lpszPathName);
}
void CIMACDoc::OnFileSave()
{
	CDocument::OnFileSave();
}

void CIMACDoc::OnFileSaveAs()
{
	CDocument::DoSave(GetProjectSaveAsName());
}

BOOL CIMACDoc::FileSaveAs()
{
	return CDocument::DoSave(GetProjectSaveAsName());
}

int CIMACDoc::DoFileExportSegy(CString segyExportFilename)
{
	int returnStatus = 0;
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();

	if (pApp->IsDemoMode()) {
		pApp->ShowTrialMessage();
	} else {
		CSegyOutDlg SegyOutDlg;
		SegyOutDlg.SetOutFile(segyExportFilename);

		CIMACDoc* pDoc = this;
		SegyOutDlg.m_pDoc = pDoc;

		returnStatus = SegyOutDlg.DoModal() == IDOK ? 0 : 1;	
	}
	return returnStatus;
}

BOOL CIMACDoc::AppendAttributeFile(CString attributePath, CString attributeName)
{
	CModelessInfoDlg modelessDlg;
	BOOL status = true;
	CSegyUtil segyUtil;
	DWORD nsamp;
	DWORD si;
	double size;
    CHeaderMap headerMap;
	eEndian endian;
	DWORD formatCode;

	modelessDlg.ShowMessage("Loading Seg-Y data file:");
	modelessDlg.AddString(" ");
	modelessDlg.AddString(attributePath);
	modelessDlg.AddString(" ");
	modelessDlg.AddString("Attribute name: " + attributeName);

	// Check for duplicate attribute name
	for (int i = 0; i < GetFileCount(); i++) {
		if (attributeName == GetAttr(i)) {
			AfxMessageBox("Duplicate Attribute Name not allowed: " + attributeName);
			status = false;
			break;
		}
	}
 
	if (status) {
		// Check if the file appears to be a valid segy file.
		status = segyUtil.ReadSegyProperties(attributePath, &nsamp, &si, &size, &formatCode, &endian, &headerMap) == 0;
		if (nsamp == 0 || si == 0 || size < 3600) {
			status = false;
		}
		if (GetSI() == 0) {
			SetSI(si);
		}
	}
 
	int fileIndex = GetFileCount();
	if (fileIndex >=  NFILE - 1) {
		status = false;
	}

	if (status) {
		CSegy *pSegy = GetSegyInPtr(fileIndex);		
		pSegy->Reset();
		pSegy->GetSegyIndexPtr()->Destroy();
		pSegy->SetHeaderMap(&headerMap); // A note on above in serialize that says "The header map is now always local. So copy it to the Segy object if necessary."
		if (pSegy->LoadIndex(attributePath, AfxGetMainWnd()->GetSafeHwnd()) == 0) {
			CSegyUtil SegyUtil;
			float min, max;
			SegyUtil.file_min_max(attributePath, &headerMap, 0, &min, &max);
			MIN_MAX minMaxValue = { min, max, 0, 0 };
			SetScanMinMax(minMaxValue, fileIndex);

			// cross check for common traces, unless there is only one file.
			if (fileIndex > 0) {
				CSegyIndex *pSegyIndex[NFILE];
				int fileCount = m_nFile + 1;
				for (int i = 0; i < fileCount; i++) {
					pSegyIndex[i] = GetSegyInPtr(i)->GetSegyIndexPtr();
				}
				HWND hParentWnd = AfxGetMainWnd()->GetSafeHwnd();
				status = CIMACDoc::CrossCheckIndexes(hParentWnd, pSegyIndex, fileCount) == 0;
			}

			if (status) {
				SetFileCount(fileIndex + 1);
				SetFile(attributePath, fileIndex);
				SetAttr(attributeName, fileIndex);
				SetVolType("", fileIndex);
				SetFavorite(1, fileIndex);

				status = (LoadData() > 0);
				if (status) {
					m_bDrawFlag = TRUE;
					UpdateViews();
				}				
			}
		}
		else {
			status = false;
		}
	}
	modelessDlg.DestroyWindow();
	return status;
}

BOOL CIMACDoc::AppendWellFile(CString strWellFile, CString defaultWellName)
{
	BOOL status = true;
	BOOL duplicate = false;
	CStdioFile wellFile;
	CFileException ex;

	CSegy *pSegy = GetSegyInPtr(0);
	WellList *pWellList = GetWellListPtr();
	WellSubList	*pWellSubList = GetWellSubListPtr(0);
	CWell *pWellDuplicate = NULL;

	// check if the well already has an entry
	for (int i = 0; i < pWellList->GetCount(); i++) {
		pWellDuplicate = pWellList->GetAt(pWellList->FindIndex(i));
		if (pWellDuplicate->wellName == defaultWellName) {
			duplicate = true;
			break;
		}
	}

	if (!duplicate) {
		// load a new well entry into the database
		CModelessInfoDlg modelessDlg;
		modelessDlg.ShowMessage("Loading imported well " + strWellFile);
		CWell *pWell = new CWell;
		if (pWell->LoadLasFile(strWellFile, defaultWellName) < 0) {
			delete pWell;
			status = false;
		}
		else {
			// convert well units to project units
			pWell->ConvertUnits(GetProjectUnits());

			pWell->InterpolateNulls();
			if (pSegy != NULL) {
				pSegy->FindWellInlineXline(pWell);
			}
			if (pWellList != NULL) {
				pWellList->AddTail(pWell);

				if (pWellSubList != NULL) {
					pWellSubList->AddTail((int)pWellList->GetCount() - 1);
				}
				UpdateViews();
			}
		}
		modelessDlg.DestroyWindow();
	}
	else {
		// This well already exists. Append the curves to the exiting well.
		if (pWellDuplicate->GetDepthLogIndex() == -1) {
			CString msg = "The well " + pWellDuplicate->wellName + " does not have a 'DEPTH' curve\n";
			msg += "Please open the Depth Curve section on the well tree, right click on the depth curve, and select 'DEPTH' from the popup menu.";
			msg += "Then try the append again.";
			AfxMessageBox(msg);
			status = false;
		}
		else {
			CModelessInfoDlg modelessDlg;
			modelessDlg.ShowMessage("Appending curves from imported well " + strWellFile);

			CWell *pWell = new CWell;
			if (pWell->LoadLasFile(strWellFile) < 0) {
				status = false;
			}
			else {
				// convert well units to project units
				pWell->ConvertUnits(GetProjectUnits());

				// select all the curves
				for (int i = 0; i < pWell->GetCurvesCount(); i++) {
					if (pWell->GetCurveSelectState(i) != eDEPTH) {
						pWell->SetCurveSelectState(i, eSELECTED);
					}
				}
				// copy the curves in
				*pWellDuplicate += *pWell;
			}
			delete pWell;
			modelessDlg.DestroyWindow();
		}
	}

	return status;
}

BOOL CIMACDoc::AppendTopsFile(CString strWellFile, CString wellName)
{
    BOOL status = true;
    BOOL found = false;
    CStdioFile wellFile;
    CFileException ex;

    CSegy *pSegy = GetSegyInPtr(0);
    WellList *pWellList = GetWellListPtr();

    CModelessInfoDlg modelessDlg;
    modelessDlg.ShowMessage("Loading tops " + strWellFile + " to well " + wellName);

    POSITION pos = pWellList->GetHeadPosition();
    while (pos) {
        CWell *pWell = pWellList->GetNext(pos);
        if (pWell->wellName == wellName) {
            found = true;

			// if necessary, convert tops units to well units.
			eUnits wellUnits = pWell->GetOriginalUnits();
			eUnits convertedUnits = pWell->GetConvertedUnits();
			if (wellUnits == eUNDEF_UNITS || convertedUnits == eUNDEF_UNITS || wellUnits == convertedUnits) {
				// no conversion necessary
				convertedUnits = eUNDEF_UNITS;
			}

            pWell->LoadTopsTextFile(strWellFile, convertedUnits);
            break;
        }
    }    

    if (found) {
        float depthDatum;
        BOOL  bDepthMode = GetWellDepthMode(depthDatum);
		if (IsPetrelTimeMode()) depthDatum = CalculatePetrelOffset(depthDatum);
        CWellUtil::ProcessDepthTimeCurves(GetWellListPtr(), bDepthMode, depthDatum);
    } else {
        CString msg;
        msg.Format("Well %s not found. No tops have been loaded.", wellName);
        AfxMessageBox(msg);
    }

    modelessDlg.DestroyWindow();
    UpdateViews();
    return status;
}

BOOL CIMACDoc::AppendCurveFile(CString strWellFile, CString wellName)
{
    BOOL status = true;
    BOOL found = false;
    CStdioFile wellFile;
    CFileException ex;

    CSegy *pSegy = GetSegyInPtr(0);
    WellList *pWellList = GetWellListPtr();

    CModelessInfoDlg modelessDlg;
    modelessDlg.ShowMessage("Loading curve " + strWellFile + " to well " + wellName);

    POSITION pos = pWellList->GetHeadPosition();
    while (pos) {
        CWell *pWell = pWellList->GetNext(pos);
        if (pWell->wellName == wellName) {
            found = true;
            CWell *pNewWell = pWell->LoadCurveTextFile(strWellFile);
            if (pNewWell) {
#if 0
				// convert well units to project units
				eUnits wellUnits = pWell->GetConvertedUnits();
				eUnits projectUnits = GetProjectUnits();
				if (wellUnits != eUNDEF_UNITS && projectUnits != eUNDEF_UNITS ) {
					pNewWell->ConvertUnits(wellUnits);
				}
#endif
                *pWell += *pNewWell;
            }
            break;
        }
    }

    if (found) {
        float depthDatum;
        BOOL  bDepthMode = GetWellDepthMode(depthDatum);
		if (IsPetrelTimeMode()) depthDatum = CalculatePetrelOffset(depthDatum);
        CWellUtil::ProcessDepthTimeCurves(GetWellListPtr(), bDepthMode, depthDatum);
    } else {
        CString msg;
        msg.Format("Well %s not found. Curve has not been loaded.", wellName);
        AfxMessageBox(msg);
    }

    modelessDlg.DestroyWindow();
    UpdateViews();
    return status;
}

BOOL CIMACDoc::AppendDeviationSurveyFile(CString strWellFile, int dataType, CString wellName)
{
    BOOL status = true;
    BOOL found = false;
    CStdioFile wellFile;
    CFileException ex;

    CSegy *pSegy = GetSegyInPtr(0);
    WellList *pWellList = GetWellListPtr();

    CModelessInfoDlg modelessDlg;
    modelessDlg.ShowMessage("Loading Deviation Survey " + strWellFile + " to well " + wellName);

    CWell *pWell = NULL;
    POSITION pos = pWellList->GetHeadPosition();
    while (pos) {
        pWell = pWellList->GetNext(pos);
        if (pWell->wellName == wellName) {
            found = true;
            break;
        }
    }

    if (found) {
        pWell->LoadDeviationSurveyTextFile(strWellFile, dataType);

		// if necessary, convert deviated units to well units.
		eUnits wellUnits = pWell->GetOriginalUnits();
		eUnits convertedUnits = pWell->GetConvertedUnits();
		if (wellUnits != eUNDEF_UNITS && convertedUnits != eUNDEF_UNITS && wellUnits != convertedUnits) {
			pWell->ConvertDeviationSurveyUnits(convertedUnits);
		}

		if (dataType == 0) {
			pWell->ComputeXYfromDxDy();
		}
		else {
			pWell->ComputeXYfromInclinationAzimuth();
		}

        int nDeviatedPts = pWell->GetDeviatedPointCount();
        if (nDeviatedPts > 0) {
            DWORD prevInLine = 0;
            DWORD prevXLine = 0;
			pWell->SetDeviatedInlineXlineCount(0);
            CSegy *pSegy = GetFirstLoadedSegyPtr();
            for (int i = 0; i < nDeviatedPts; i++) {
                CDeviatedPoint *data = pWell->GetDeviatedPoint(i);
                pSegy->FindInlineXline(data->m_x, data->m_y, data->m_inline, data->m_xline);
                if (data->m_inline != prevInLine || data->m_xline != prevXLine) {
                    // save the point for later.  We need the list of inline crosslines to compare against when a new line is loaded.
                    CPoint point;
                    point.x = data->m_inline;
                    point.y = data->m_xline;
                    pWell->AddDeviatedInlineXlineToList(point);

                    prevInLine = data->m_inline;
                    prevXLine = data->m_xline;
                }
            }
            pWell->SortInlineXlineList();

			float depthDatum;
			BOOL  bDepthMode = GetWellDepthMode(depthDatum);
			if (IsPetrelTimeMode()) depthDatum = CalculatePetrelOffset(depthDatum);
			CWellUtil::ProcessDepthTimeCurves(GetWellListPtr(), bDepthMode, depthDatum);

            if (LoadData()<0) {
                if (AfxMessageBox("An error has occured. Abort?", MB_YESNO) == IDYES) exit(0);
            }
        }
       
    } else {
        CString msg;
        msg.Format("Well %s not found. Deviation Survey has not been loaded.", wellName);
        AfxMessageBox(msg);
    }

    modelessDlg.DestroyWindow();
    UpdateViews();
    return status;
}

BOOL CIMACDoc::AppendHorizonFile(CString strHorizonFile)
{
	BOOL status = true;
	CStdioFile horizonFile;
	CFileException ex;
	CModelessInfoDlg modelessDlg;

	// open the horizon file, abort on error.
	if (!horizonFile.Open(strHorizonFile, CStdioFile::modeRead, &ex)) {
		TCHAR message[1024];
		ex.GetErrorMessage(message, 1024);
		AfxMessageBox("Could not open horizon file: " + CString(message));
		return FALSE;
	}

	modelessDlg.ShowMessage("Loading horizon file: " + strHorizonFile);

	// get the header from the horizon file. 
	CString headerString;
	horizonFile.ReadString(headerString);
	horizonFile.Close();

	// Parse the title
	CStringArray arrWords;
	ParseHorizonTitle(headerString, arrWords);

	// Load the horizon data
	CHorizon *pNewHor = new CHorizon;
	pNewHor->LoadTxtFile(strHorizonFile, 1, (int) arrWords.GetCount(), &arrWords);

	CHorizon *pExistingHor = GetHorizonDataPtr();
	if (pExistingHor->GetHorizonCount() > 0) {
		*pExistingHor += *pNewHor;
        pNewHor->DestroyData();
		delete pNewHor;
	}
	else {
		SetHorizonDataPtr(pNewHor);
	}

	modelessDlg.DestroyWindow();
	UpdateViews();
	return status;
}

void CIMACDoc::ParseHorizonTitle(CString title, CStringArray &arrWords)
{
	CString strLeftDelimiter = "<";
	CString strRightDelimiter = ">";
	CString singleWord;
	int curPos = 0;
	int wordCount = 0;

	singleWord = title.Tokenize(strLeftDelimiter, curPos);
	while (!singleWord.IsEmpty()) {
		int rightPos = singleWord.Find(strRightDelimiter);
		if (rightPos > 0) {
			singleWord = singleWord.Left(rightPos);
		}
		arrWords.SetAtGrow(wordCount++, singleWord);
		singleWord = title.Tokenize(strLeftDelimiter, curPos);
	}
}

void CIMACDoc::UpdateMapSelectDlg()
{
	CMapSelectDlg *pMap = GetMapSelectPtr();

	// check for no data condition
	CSegy *pSegy = GetFirstLoadedSegyPtr();
	if (pSegy == NULL || pSegy->GetTraceCount() == 0) {
		// AfxMessageBox("Cannot display map before seismic attribute data is loaded.");
		return;
	}

	// The MapSelect window has been closed, clean up
	if (!GetMapSelectMode() && pMap != NULL)
	{
		delete pMap;
		SetMapSelectPtr(NULL);
	}

	// Create the mapselect window
	if (GetMapSelectMode() && pMap == NULL) {	
		pMap = new CMapSelectDlg();
		pMap->pDoc = this;
//		pMap->Create(IDD_MAP_SELECT, CWnd::GetDesktopWindow());
        pMap->Create(IDD_MAP_SELECT);
		pMap->ShowWindow(SW_SHOW);
		SetMapSelectPtr(pMap);		
	
	// update the mapselect window
	} else if (GetMapSelectMode() && pMap != NULL) {
//		Removed by KL. The ResetContent() method of the combo boxes killed the update of the view classes 
//      when in fine tune mode.  Strange but true.  I suspect some kind of bug or usage error with those combos.
//		pMap->UpdateControls();
		pMap->UpdateSelectMode();
		pMap->Invalidate(FALSE);
	}

}

int CIMACDoc::ScanMinMax(CString attribute, int count, float* min, float* max, int sampleCount)
{
	int index = GetAttributeIndex(attribute);
	if (index < 0) return 0;

	*min = 0;
	*max = 0;
	int tracesScanned = 0;


	if (LoadSegy(attribute) < 0) return 0;
	CSegy* pSegy = GetSegyPtrFromAttrName(attribute);


	// calculate min max
	int si = GetSI();
	int startTime = GetStartTime();
	int endTime = GetEndTime();
	int nsamps = Time2Index((endTime - startTime), si) + 1;
	if (sampleCount != -1) nsamps = sampleCount;
	if (nsamps > pSegy->GetSampleCount()) nsamps = pSegy->GetSampleCount();

	for (int i = 0; i < pSegy->GetTraceCount(); i++) {
		if (count > 0 && i == count) break;

		float* pData = pSegy->GetTraceDataPtr(i, startTime);
		for (int j = 0; j < nsamps; j++) {
			if (pData[j] < *min)* min = pData[j];
			if (pData[j] > * max)* max = pData[j];
		}

		tracesScanned = i + 1;
	}

	return tracesScanned;
}

//
// look at the coordinate unit setting in all binary headers. 
// Return as follows:
// -1 = mixed flags.
//  0 = all headers are undefined
//  1 = all headers are metric
//  2 = all headers are imperial
int CIMACDoc::CrossCheckCoordinateUnits()
{
	CSegyUtil segyUtil;
	BYTE ebcdic[3200];
	BYTE binary[400];
	int metricUnitCount = 0;
	int imperialUnitCount = 0;
	int undefinedUnitCount = 0;
	for (int i = 0; i < GetFileCount(); i++) {
		CSegy *pSegy = GetSegyInPtr(i);
		CHeaderMap *pMap = pSegy->GetHeaderMap();
		CFile cfile;
		CString segyFile = GetFile(i);
		if (segyUtil.OpenSegyFile(segyFile, &cfile)) continue;

		// Coordinate units
		segyUtil.GetSegyLineHeaders(&cfile, ebcdic, binary);
		int coordinateUnits = (int)pMap->coordUnits.GetValue(binary);

		if (coordinateUnits == 1) metricUnitCount++;
		else if (coordinateUnits == 2) imperialUnitCount++;
		else undefinedUnitCount++;

		cfile.Close();
	}

	if (undefinedUnitCount > 0 && metricUnitCount == 0 && imperialUnitCount == 0) return 0;
	if (metricUnitCount > 0 && undefinedUnitCount == 0 && imperialUnitCount == 0) return 1;
	if (imperialUnitCount > 0 && undefinedUnitCount == 0 && metricUnitCount == 0) return 2;
	return -1;
}

void CIMACDoc::RemoveAttribute(int nItem)
{
	int attributeCount = GetFileCount();
	if (attributeCount <= 0 || nItem < 0 || nItem >= attributeCount) return;
		
	//shuffle the data down one slot
	for (int i = nItem; i < attributeCount-1; i++) {
		SetFile(GetFile(i + 1), i);
		SetAttr(GetAttr(i + 1), i);
		SetVolType(GetVolumeType(i + 1), i);
		SetScanMinMax(GetScanMinMax(i + 1), i);
		SetFavorite(GetFavorite(i + 1), i);
		CSegy *ptr = GetSegyInPtr(i);
		SetSegyInPtr(GetSegyInPtr(i + 1), i);
		SetSegyInPtr(ptr, i + 1);
	}
	// remove the last element
	int i = attributeCount - 1;
	SetFile(CString(), i);
	SetAttr(CString(), i);
	SetVolType(CString(), i);
	MIN_MAX minMaxValue = { 0, 0, 0, 0 };
	SetScanMinMax(minMaxValue, i);
	SetFavorite(0, i);
	GetSegyInPtr(i)->Reset();

	SetFileCount(attributeCount - 1);
}

void CIMACDoc::SetUpdateXplotPaneFlagsAll(BOOL flag)
{
	for (int i=0; i<NXPLOT; i++) {
		SetUpdateXplotPaneFlag(i, flag);
	}
}


// When the main frame is moved and there is no instance of a crossplot view class, this function will update the coords.
void CIMACDoc::MoveClosedXplotWindows(CPoint delta)
{
	CRect parentRect;
	AfxGetMainWnd()->GetWindowRect(parentRect);
	for (int i = 0; i < NXPLOT; i++) {
		CXplotParms *pXplot = GetXplotParms(i);
		if ( GetCrossPlotViewPtr(i) == NULL && pXplot->IsXplotActive() ) {
			pXplot->rcWinFrame += delta;
			if (!pXplot->m_rcParentWin.IsRectNull()) {
				pXplot->m_rcParentWin += delta;
			}
		}
	}
}

void CIMACDoc::CascadeImacWindows()
{
	DoCascadeOrTile(TRUE);
}

void CIMACDoc::TileImacWindows()
{
	DoCascadeOrTile(FALSE);
}

void CIMACDoc::DoCascadeOrTile(BOOL mode)
{
	CPoint delta, origin;

	CMainFrame *pMainFrame;
	pMainFrame = (CMainFrame *) AfxGetMainWnd();
	int toolbarHeight = pMainFrame->GetToolBarHeight();

	CRect clientRect = this->GetParentWinRect();
	AfxGetMainWnd()->GetClientRect(clientRect);
	AfxGetMainWnd()->ClientToScreen(clientRect);
	origin.x = clientRect.left;
	origin.y = clientRect.top + toolbarHeight + 5;
	delta = origin;

	for (int i = 0; i < NXPLOT; i++) {
		CXplotParms *pXplot = GetXplotParms(i);
		CView *pView = GetCrossPlotViewPtr(i);
		if ( pView != NULL && pXplot->IsXplotActive() ) {
			CRect tmpRect = pXplot->rcWinFrame;
			pXplot->rcWinFrame.left = delta.x;
			pXplot->rcWinFrame.top  = delta.y;
			pXplot->rcWinFrame.right = delta.x + tmpRect.Width();
			pXplot->rcWinFrame.bottom = delta.y + tmpRect.Height();
			//SetInitializeXplotViewFlag(i, TRUE);
			if (mode) {
				delta += CPoint(50, 50);
			} else {
				delta.x += tmpRect.Width();
				// if the next tile isn't visible, wrap back to the left side.
				if(delta.x > (clientRect.right - 100)) {
					delta.x = origin.x;
					delta.y += 200;
				}
			}
			CRect rc = pXplot->rcWinFrame;
			// have to add an adjustment
			CPoint adjustment = CPoint(2, 5);
			adjustment.y += GetToolbarHeight();
			rc -= adjustment;
			AfxGetMainWnd()->ScreenToClient(rc);
			pView->GetParentFrame()->SetWindowPos(0, rc.left, rc.top, rc.Width(), rc.Height(), 0);
		}
	}

	CRect winRect = this->GetClassifiedWinRect();
	CRect tmpRect = winRect;
	winRect.left = origin.x;
	winRect.right = origin.x + tmpRect.Width();
	winRect.bottom = clientRect.bottom;
	winRect.top = winRect.bottom - tmpRect.Height();

	CRect restoreRect = winRect;
	CPoint adjustment = CPoint(2, 5);
	adjustment.y += GetToolbarHeight();
	restoreRect -= adjustment;
	AfxGetMainWnd()->ScreenToClient(restoreRect);
	GetMainViewPtr()->GetParentFrame()->SetWindowPos(0, restoreRect.left, restoreRect.top, restoreRect.Width(), restoreRect.Height(), 0);
}

HCURSOR CIMACDoc::MakeCustomCursor(CString strItem)
{
	int nBmpSize;
	CWindowDC hDC(AfxGetMainWnd());
	CDC memDC;
	memDC.CreateCompatibleDC(&hDC);

	CFont stockFont, newFont;
	LOGFONT logFont;
	stockFont.CreatePointFont(90, "MS Shell Dlg");
	stockFont.GetLogFont(&logFont);
	logFont.lfWeight = FW_BOLD;
	newFont.CreateFontIndirect(&logFont);
	CFont *pOldFont = memDC.SelectObject(&newFont);

	// get text extent, add space for the arrow, round the scan length up to next DWORD size
	CSize txtSize = memDC.GetTextExtent(strItem) + CSize(16, 0);
	txtSize.cx = (txtSize.cx / 16 * 16) != txtSize.cx ? (txtSize.cx / 16 + 1) * 16 : txtSize.cx;

	CBitmap bm;
	bm.CreateBitmap(txtSize.cx, txtSize.cy, 1, 1, NULL);
	CBitmap *pOldBM = memDC.SelectObject(&bm);
	nBmpSize = (txtSize.cx / 8) * txtSize.cy;

	//std::shared_ptr<unsigned char> pCursorAND( new unsigned char[nBmpSize]);
	//std::shared_ptr<unsigned char> pCursorXOR( new unsigned char[nBmpSize]);
	pCursorAND = new unsigned char[nBmpSize];
	pCursorXOR = new unsigned char[nBmpSize];

	memDC.SetTextColor(RGB(255, 255, 255));
	memDC.SetBkMode(TRANSPARENT);
	memDC.TextOut(16, 0, strItem, strItem.GetLength());

	// the cursor is made with 2 bitmasks as follows
	// AND XOR Pixel
	//  0   0  black
	//  0   1  white
	//  1   0  transparent
	//  1   1  inverted
	//
	// According to the above table, set the background to 1, 0 and the data to 0, 0.
	memset(pCursorXOR, 0x00, nBmpSize);
	bm.GetBitmapBits(nBmpSize, pCursorAND);

	// draw the arrow.
	int iscan = txtSize.cx / 8;
	pCursorAND[iscan] = 64;
	pCursorAND[iscan * 2] = 96;
	pCursorAND[iscan * 3] = 112;
	pCursorAND[iscan * 4] = 120;
	pCursorAND[iscan * 5] = 124;
	pCursorAND[iscan * 6] = 126;
	pCursorAND[iscan * 7] = 127;
	pCursorAND[iscan * 8] = 127; pCursorAND[(iscan * 8) + 1] = 128;
	pCursorAND[iscan * 9] = 127; pCursorAND[(iscan * 9) + 1] = 192;
	pCursorAND[iscan * 10] = 126;
	pCursorAND[iscan * 11] = 127;
	pCursorAND[iscan * 12] = 103;
	pCursorAND[iscan * 13] = 7; pCursorAND[(iscan * 13) + 1] = 128;
	pCursorAND[iscan * 14] = 3;
	// flip the bits
	for (int i = 0; i < nBmpSize; i++){
		pCursorAND[i] = ~pCursorAND[i];
	}

	m_hCustomCursor = CreateCursor(AfxGetInstanceHandle(), 0, 0, txtSize.cx, txtSize.cy, pCursorAND, pCursorXOR);

	memDC.SelectObject(pOldFont);
	memDC.SelectObject(pOldBM);
	memDC.DeleteDC();
	DeleteObject(newFont);
	DeleteObject(stockFont);
	DeleteObject(bm);

	return m_hCustomCursor;
}

void CIMACDoc::DestroyCustomCursor()
{
	DestroyCursor(m_hCustomCursor);
}

void CIMACDoc::GetDefaultVolTypeList()
{
	CString strDefaultString;
	strDefaultString.LoadString(IDS_VOLUME_TYPE_LIST);
	int curPos = 0;
	CString strItem;
	strItem = strDefaultString.Tokenize(";", curPos);
	while (strItem != "") {
		CVolType *pVol = new CVolType;
		pVol->SetVolTypeName(strItem);
		pVol->SetRequired();
		m_volTypeList.AddTail(pVol);
		strItem = strDefaultString.Tokenize(";", curPos);
	}
}

void CIMACDoc::BuildDefaultVirtualVolumes()
{
	DWORD i = 0;
	CString strName, strEqu, strType;
	int iStat = GetVirtualVolumeEquation(i, strName, strEqu, strType);
	while (iStat == 0) {
		CVVAttribute &vvAttr = GetVVAttributeRef(i);
		vvAttr.SetEquation(strEqu);
		vvAttr.SetBaseName(strName);
		vvAttr.SetVolumeType(strType);
		iStat = GetVirtualVolumeEquation(++i, strName, strEqu, strType);
	}
}

int CIMACDoc::GetVirtualVolumeEquation(DWORD i, CString &name, CString &eq, CString &type)
{
	CString text = DefaultVVEquations[i];
	if (text.IsEmpty()) return -1;
	int iStart = 0;
	name = text.Tokenize("=;", iStart);
	eq = text.Tokenize("=;", iStart);
	type = text.Tokenize("=;", iStart);
	return 0;
}

CVVAttribute &CIMACDoc::GetVVAttributeRef(int n)
{
	if (n >= m_vvAttributeArray.GetCount()) {
		CVVAttribute newAttr;
		m_vvAttributeArray.SetAtGrow(n, newAttr);  // newAttr copy constructor
	}
	return m_vvAttributeArray.GetAt(n);
}

void CIMACDoc::AllocateDynamicSliders(CWnd *pParentWnd)
{
	try {
		// first free up memory from the old sliders.
		for (int i = 0; i<m_nDynamicSliders; i++) {
			if (m_arrDynamicSliders[i]) {
				m_arrDynamicSliders[i]->DestroyData();
				delete m_arrDynamicSliders[i];
				m_arrDynamicSliders[i] = NULL;
			}
		}

		// first get some pointers to the data
		int nCurrentVolTypeIx = GetCurrentVolTypeIx();
		VolTypeList	  *pVolTypeList = GetVolTypeListPtr();
		CVolType      *pVolType = pVolTypeList->GetAt(pVolTypeList->FindIndex(nCurrentVolTypeIx));
		SeisParmsList *pSeisParmsList = &m_seisParmsList;
		// general bail out conditions
		if (pVolType == NULL) return;
		if (pVolTypeList == NULL) return;
		if (pVolTypeList->IsEmpty()) return;
		if (pSeisParmsList->IsEmpty()) return;
		if (pVolType->GetParmNamesCount() == 0) return;


		int sliderCount = pVolType->GetParmNamesCount(); // a slider will be created for each parameter
		int ifirstrow = (m_bMinimizeColorMap) ? SLIDER_ROW_MIN : SLIDER_ROW_NORM;
		int irow = ifirstrow;
		int y = irow * ROWSIZE;

		// display the title
		m_title1.Create("Select Volume:", WS_CHILD | WS_VISIBLE | SS_CENTER | WS_BORDER,
			CRect(GAP, y, GAP + WINXSIZE, y + ROWSIZE), pParentWnd);
		irow++;

		// Allocate the array of pointers to the dynamic sliders, or increase it's size if necessary
		if (sliderCount > m_nDynamicSliders) {
			if (m_arrDynamicSliders) {
				delete m_arrDynamicSliders;
			}
			while (m_nDynamicSliders <= sliderCount) {
				m_nDynamicSliders += 50;
			}
			m_arrDynamicSliders = new CDynamicSlider*[m_nDynamicSliders];
			if (m_arrDynamicSliders == NULL)
				throw "Allocation failure on m_arrDynamicSliders";
			for (int i = 0; i<m_nDynamicSliders; i++) {
				m_arrDynamicSliders[i] = NULL;
			}
		}

		// allocate a temp array with the maximum number of items.
		int sliderValueCount = (int) pSeisParmsList->GetCount();
		DWORD *pTmp = new DWORD[sliderValueCount];
		if (pTmp == NULL)
			throw "Allocation failure on pTmp";

		// create a dynamic slider for each parameter
		for (int i = 0; i<sliderCount; i++) {
			DWORD *pSliderValues = NULL;
			pSliderValues = new DWORD[sliderValueCount];
			if (pSliderValues == NULL)
				throw "Allocation failure on pSliderValues";

			TRACE("Allocated %d bytes\n", sliderValueCount * sizeof(DWORD));

			// march through the list and extract the individual parameter values.
			int ix = 0;
			POSITION pos = pSeisParmsList->GetHeadPosition();
			while (pos) {
				CSeisParms *pSeisParms = pSeisParmsList->GetNext(pos);
				if (pSeisParms->GetVolType() == pVolType->GetVolTypeName()) {
					if (i < pSeisParms->GetParmCount()) {
						pTmp[ix++] = (DWORD)pSeisParms->GetParmValue(i);
					}
				}
			}
			int nUnique = 0;
			if (ix > 0) {
				QuickSort(pTmp, pSliderValues, ix);				// sort the data
				memcpy(pTmp, pSliderValues, sizeof(DWORD)*ix);		// copy back to original array
				Unique(pTmp, pSliderValues, ix, &nUnique);			// remove the duplicates
			}
			// now we can make the slider...
			m_arrDynamicSliders[i] = new CDynamicSlider(pParentWnd, (i * 3) + irow, pSliderValues, nUnique, pVolType->GetParmName(i));
			if (m_arrDynamicSliders[i] == NULL) {
				CString txt;
				txt.Format("Allocation Failure Slider %d", i);
				throw txt;
			}
			TRACE("pVolType->GetParmEnabled(i)=%d\n", pVolType->GetParmEnabled(i));
			m_arrDynamicSliders[i]->SetEnabled(pVolType->GetParmEnabled(i));
		}
		if (pTmp) delete pTmp;


	}
	catch (char *str) {
		AfxMessageBox(str);
	}
	catch (...) {
		AfxMessageBox("Exception caught");
	}
}


//
// Allocate memory for the amplitude array. If the requested memory is smaller than the current, nothing is done.
int CIMACDoc::ReAllocateAmpList(int n)
{
	if (n < m_ampListAllocSize) return 0;

	if (m_ampList) delete m_ampList;

	m_ampList = new float[n];

	if (m_ampList == NULL) {
		AfxMessageBox("Cannot allocate memory for amplitude array");
		m_ampListAllocSize = 0;
		m_ampListSize = 0;
		return -1;
	}

	return 0;
}



void CIMACDoc::GenParameters(CStringArray &nameList, int parmToolCount, ParmToolDataArray *pDataArray, SeisParmsList *pSeisParmsList)
{
	int ix = 0;
	CSeisParms *pSeisParms = NULL;

	for (int j = 0; j<parmToolCount; j++) {
		CParmToolData data;
		data = *pDataArray->GetAt(j);

		CIntArray values;
		values.SetSize(100, 100);

		// init the array to the minimum values for each parameter
		for (int i = 0; i<data.m_parmCount; i++) {
			values.SetAtGrow(i, data.m_arrMin[i]);
		}

		// build a file string for each combination of parameters.
		do {

			CString txt = data.m_lineName + "-" + data.m_lineVersion + "-" + data.m_volType;

			if (pSeisParmsList != NULL) {
				pSeisParms = new CSeisParms;
				m_seisParmsList.AddTail(pSeisParms);
			}

			for (int i = 0; i<data.m_parmCount; i++) {
				CString strNumber;
				strNumber.Format("-%d", values[i]);
				txt += strNumber;

				if (pSeisParmsList != NULL) {
					pSeisParms->SetParmValue(i, values[i]);
					pSeisParms->IncParmCount();
				}
			}
			CString fname = txt + ".sgy";
			nameList.SetAtGrow(ix++, fname);

			if (pSeisParmsList != NULL) {
//				pSeisParms->SetFileName(fname);
				pSeisParms->SetVolType(data.m_volType);
			}

		} while (IncrementParms(&values, &data));
	}
}

BOOL CIMACDoc::IncrementParms(CIntArray *pValues, CParmToolData *pData)
{
	for (int i = 0; i<pData->m_parmCount; i++) {
		int min = pData->m_arrMin[i];
		int max = pData->m_arrMax[i];
		int inc = pData->m_arrInc[i];
		if (pValues->GetAt(i) + inc <= max) {
			// increment the value, all preceeding parms are reset to the min.
			pValues->SetAt(i, pValues->GetAt(i) + inc);
			for (int j = 0; j<i; j++) {
				pValues->SetAt(j, pData->m_arrMin[j]);
			}
			return true;
		}
	}

	// nothing has been incremented, we're done.
	return false;
}

void CIMACDoc::UpdateParmToolArray()
{
	// Add the volume types that don't exist in the parmToolArray
	POSITION pos = m_volTypeList.GetHeadPosition();
	while (pos) {
		CVolType *pVol = m_volTypeList.GetNext(pos);
		BOOL bFound = FALSE;
		for (int i = 0; i<m_parmToolCount; i++) {
			if (pVol->GetVolTypeName() == m_parmToolDataArray[i]->m_volType) {
				bFound = TRUE;
				break;
			}
		}
		if (!bFound) {
			CParmToolData *pParmToolData = new CParmToolData;
			pParmToolData->m_volType = pVol->GetVolTypeName();
			m_parmToolDataArray.SetAtGrow(m_parmToolCount, pParmToolData);
			m_parmToolCount++;
		}
	}
}

void CIMACDoc::DoParmToolDlg()
{
	// For now we're not going to update the volumes in the parm tool.
	 UpdateParmToolArray();

	CParmToolDlg dlg;
	// copy the document data to the dialog
	for (int i = 0; i<m_parmToolCount; i++) {
		CParmToolData *pParmToolData = new CParmToolData;
		*pParmToolData = *m_parmToolDataArray[i];
		dlg.m_parmToolDataArray.SetAtGrow(i, pParmToolData);
	}
	dlg.m_parmToolCount = m_parmToolCount;

	// show the dialog
	int iRet = (int) dlg.DoModal();
	if (iRet == IDOK || iRet == IDAPPLY) {
		// remove the old data from the document
		for (int i = 0; i<m_parmToolCount; i++) {
			delete m_parmToolDataArray[i];
		}
		// copy in the new data from the dialog
		for (int i = 0; i<dlg.m_parmToolCount; i++) {
			CParmToolData pParmToolData;
			pParmToolData = *dlg.m_parmToolDataArray[i];
			m_parmToolDataArray.SetAtGrow(i, dlg.m_parmToolDataArray[i]);
		}
		m_parmToolCount = dlg.m_parmToolCount;

	} else {
		// cancel was pressed, clean up the dialog
		for (int i = 0; i<dlg.m_parmToolCount; i++) {
			delete dlg.m_parmToolDataArray[i];
		}
	}

	if (iRet == IDAPPLY) {
		// populate the parameter structures with generated parms from the dialog.
		if (AfxMessageBox("Existing parameters will be overwritten. Continue?", MB_YESNO) == IDNO) return;
		DestroySeisParmList();
		DestroyVolTypeList();

		// create the new volume type list
		for (int i = 0; i<m_parmToolCount; i++) {
			CVolType *pVolType = new CVolType;
			m_volTypeList.AddTail(pVolType);
			// the name
			pVolType->SetVolTypeName(m_parmToolDataArray[i]->m_volType);
			// the list of parameter names for this volume type
			for (int j = 0; j<m_parmToolDataArray[i]->m_parmCount; j++) {
				pVolType->AddParmName(m_parmToolDataArray[i]->m_arrParmName[j]);
			}
			// colorbar min and max values
			//float cbmin = m_plotParmData.m_colorBarMin;
			//float cbmax = m_plotParmData.m_colorBarMax;
			//pVolType->SetColorBarMinMax(cbmin, cbmax);
		}

		// create the SeisParm list
		CStringArray nameList;
		GenParameters(nameList, m_parmToolCount, &m_parmToolDataArray, &m_seisParmsList);
	}
}

void CIMACDoc::ClearMinimizedFlag(int index)
{
	DWORD theMagicBit = 0x1 << index;
	m_minimizedFlag ^= theMagicBit;		// xor the bit off
}
BOOL CIMACDoc::GetMinimizedFlag(int index)
{
	DWORD theMagicBit = 0x1 << index;
	return (m_minimizedFlag & theMagicBit);
}

//
// The user has changed the volume type in the drop down combo box
void CIMACDoc::SetCurrentVolTypeIx(int index)
{
	m_strCurrentVolType.Empty();

	VolTypeList	*pVolTypeList = GetVolTypeListPtr();
	POSITION pos = pVolTypeList->GetHeadPosition();
	if (pos == NULL) {
		return; // nothing to do, there is no volume type list. 
	}
	int i = 0;
	while (pos) {
		CVolType *pVolType = pVolTypeList->GetNext(pos);
		CString txt = pVolType->GetVolTypeName();
		if (i++ == index) {
			m_strCurrentVolType = txt;
			break;
		}
	}

	SetShowCSIPane(TRUE);
}

int CIMACDoc::GetCurrentVolTypeIx()
{
	VolTypeList	*pVolTypeList = GetVolTypeListPtr();
	POSITION pos = pVolTypeList->GetHeadPosition();
	if (pos == NULL) {
		return 0; // nothing to do, there is no volume type list. 
	}
	int index = 0;
	while (pos) {
		CVolType *pVolType = pVolTypeList->GetNext(pos);
		CString txt = pVolType->GetVolTypeName();
		if (txt == m_strCurrentVolType) {
			break;
		}
		index++;
}
	if (index >= pVolTypeList->GetCount()) index = 0;
	return index;
}

void CIMACDoc::DoDispParmsDlg(void)
{
	CPlotParmData *pData = GetPlotParmData();
	CCSIViewParmDlg dlg;

	// Get the colorbar min and max values from the current volume type.
	float colorBarMin, colorBarMax;
	GetCurrentColorBarMinMax(colorBarMin, colorBarMax);

	dlg.m_dispLine = pData->m_dispLine;
	dlg.m_inlineXlineMode = pData->m_inlineXlineMode;
	dlg.m_horizontalScale = pData->m_horizontalScale;
	dlg.m_verticalScale = pData->m_verticalScale;
	dlg.m_startTime = pData->m_startTime;
	dlg.m_endTime = pData->m_endTime;
	dlg.m_colorBarMax = colorBarMax;
	dlg.m_colorBarMin = colorBarMin;
	dlg.m_10msTLineMode = pData->m_10msTLineMode;
	dlg.m_100msTLineMode = pData->m_100msTLineMode;
	dlg.m_500msTLineMode = pData->m_500msTLineMode;
	dlg.m_cursorPositionMode = pData->m_cursorPositionMode;
	dlg.m_wellWidth = pData->m_wellWidth;

	if (dlg.DoModal() != IDOK) return;

	pData->m_dispLine = dlg.m_dispLine;
	pData->m_inlineXlineMode = (eLineMode)dlg.m_inlineXlineMode;
	pData->m_horizontalScale = dlg.m_horizontalScale;
	pData->m_verticalScale = dlg.m_verticalScale;
	pData->m_startTime = dlg.m_startTime;
	pData->m_endTime = dlg.m_endTime;
	pData->m_10msTLineMode = dlg.m_10msTLineMode;
	pData->m_100msTLineMode = dlg.m_100msTLineMode;
	pData->m_500msTLineMode = dlg.m_500msTLineMode;
	pData->m_cursorPositionMode = dlg.m_cursorPositionMode;
	pData->m_wellWidth = dlg.m_wellWidth;

	SetCursorPositionMode(pData->m_cursorPositionMode);

	// Set the colorbar min and max values in the current volume type.
	SetCurrentColorBarMinMax(dlg.m_colorBarMin, dlg.m_colorBarMax);

	SetForceRedraw(TRUE);
	UpdateViews();
}

CVolType *CIMACDoc::GetCurrentVolTypePtr()
{
	VolTypeList	*pVolTypeList = GetVolTypeListPtr();
	if (pVolTypeList == NULL) return NULL;
	CVolType *pVolType = pVolTypeList->GetAt(pVolTypeList->FindIndex(GetCurrentVolTypeIx()));
	if (pVolType == NULL) return NULL;
	return pVolType;
}

// Get the colorbar min and max values from the current volume type.
void CIMACDoc::GetCurrentColorBarMinMax(float &min, float &max)
{
	min = 0;
	max = 0;
	CVolType *pVolType = GetCurrentVolTypePtr();
	if (pVolType == NULL) return;
	pVolType->GetColorBarMinMax(min, max);
}

// Set the colorbar min and max values from the current volume type.
void CIMACDoc::SetCurrentColorBarMinMax(float min, float max)
{
	CVolType *pVolType = GetCurrentVolTypePtr();
	if (pVolType == NULL) return;
	pVolType->SetColorBarMinMax(min, max);
}

int  CIMACDoc::GetCurrentColorBarCount()
{
	CVolType *pVolType = GetCurrentVolTypePtr();
	if (pVolType == NULL) return 0;
	return pVolType->GetColorBarCount();
}

void CIMACDoc::SetCurrentColorBarCount(int n)
{
	CVolType *pVolType = GetCurrentVolTypePtr();
	if (pVolType == NULL) return;
	pVolType->SetColorBarCount(n);
}

COLORREF *CIMACDoc::GetCurrentColorBarPtr()
{
	CVolType *pVolType = GetCurrentVolTypePtr();
	if (pVolType == NULL) return NULL;
	return pVolType->GetColorBarPtr();
}

CString CIMACDoc::GetCSIVolumeName(BOOL bFullName)
{
	CString strName;
	SeisParmsList *pSeisParmsList = GetSeisParmsListPtr();
	if (pSeisParmsList && m_viewIndex>=0){
		CSeisParms *pSeisParms = pSeisParmsList->GetAt(pSeisParmsList->FindIndex(m_viewIndex));
		if (pSeisParms){
			strName = pSeisParms->GetAttrName();
			if (!bFullName){
				strName = strName.Mid(strName.ReverseFind('\\'));
			}
		}
	}
	
	return strName;
}

COLORREF *CIMACDoc::GetColorBarPtr() {

    COLORREF *pColorbar = NULL;
    if (IsThirdAttributeMode(GetViewInstance())) {
        pColorbar = GetColorBarPtr(GetViewInstance());
    }
    else if (IsColorbarOpenedFromCSI()) {
        pColorbar = GetCurrentColorBarPtr();
    }
    else {
        pColorbar = GetColorBar();
    }
    return pColorbar;
}

COLORREF *CIMACDoc::GetColorBarPtr(int viewInstance)
{
	if (viewInstance < 0 || viewInstance >= NXPLOT) viewInstance = 0;

	return &m_thirdAttributeBar[viewInstance*MAXCBSIZE];
}

int CIMACDoc::GetColorBarSize() {

    int cbSize = 0;
    if (IsThirdAttributeMode(GetViewInstance())) {
        cbSize = GetColorBarSize(GetViewInstance());
    }
    else if (IsColorbarOpenedFromCSI()) {
        cbSize = GetCurrentColorBarCount();
    }
    else {
        cbSize = m_nClass;
    }
    return cbSize;
}

int CIMACDoc::GetColorBarSize(int viewInstance)
{
	int iRet = 0;
	if (viewInstance >= 0 && viewInstance < NXPLOT) {
		iRet = m_thirdAttributBarSize[viewInstance];
    }
    else if (viewInstance == -1) {
        iRet = m_nClass;
    }
	return iRet;
}

void CIMACDoc::SetColorBarSize(int size)
{
	m_nClass = size;
}

void CIMACDoc::SetColorBarSize(int viewInstance, int size)
{
	m_thirdAttributBarSize[viewInstance] = size;
}

BOOL CIMACDoc::IsThirdAttributeMode(int viewInstance)
{
	BOOL bReturn = FALSE;
	CXplotParms *pXpParms;
	if (viewInstance >= 0) {
		pXpParms = GetXplotParms(viewInstance);

		bReturn = pXpParms->IsThirdAttributeMode();
	}

	return bReturn;
}

// Generate crossplot parameter report for Segy Ebcdic header.
BYTE* CIMACDoc::GenerateEbcdicReport()
{
	int startIndex = 0;
	memset(m_parameterReportBuffer, ' ', 3200);
	for (int i = 79; i < 3200; i += 80) {
		m_parameterReportBuffer[i] = '.';
	}

	CString qiProVersion = QIPRO_VERSION;
	CTime ticks = CTime::GetCurrentTime();
	CString todaysDate = ticks.Format("%d-%b-%Y,%H:%M:%S");

	CString outputLine = "QI-Pro v" + qiProVersion + " - Classified Seismic Volume - " + todaysDate;
	startIndex = WriteReportLine(outputLine, startIndex);

	outputLine.Format("---- Classified Volume legend ----");
	startIndex = WriteReportLine(outputLine, startIndex);
	
	if (GetXplotCount() == 0) {
		outputLine.Format("%3d %s", 0, "Unclassified");
		startIndex = WriteReportLine(outputLine, startIndex);
		outputLine.Format("---- No Crossplots defined ----");
		startIndex = WriteReportLine(outputLine, startIndex);
	}
	outputLine.Empty();
	int elementCount = 0;
	int columnCount = 4;
	for (int i = 0; i < GetClassCount(); i++) {
		if (IsClassActiveGlobal(i)) {
			CString strName = GetClssName(i);
			strName = strName.Trim();
			if (strName.IsEmpty() ) {
				strName = "unnamed";
			}
			CString strFormat;
			strFormat.Format("%3d=%-15s", i, strName);
			outputLine += strFormat;
			elementCount++;
			if (elementCount == columnCount) {
				elementCount = 0;
				startIndex = WriteReportLine(outputLine, startIndex);
				outputLine.Empty();
			}
		}
	}
	if (elementCount > 0) {
		startIndex = WriteReportLine(outputLine, startIndex);
	}

	for (int i = 0; i < GetXplotCount(); i++) {
		CXplotParms *pParms = GetXplotParms(i);

		outputLine.Format("---- Crossplot %d parameters ----", i+1);
		startIndex = WriteReportLine(outputLine, startIndex);
		CString segyFilePath;
		int attributeIndex = GetAttributeIndex(pParms->GetXAttr());
		// if the index isn't found check if it's a virtual volume.
		if (attributeIndex < 0) {
			if (GetVirtualVolumeIndex(pParms->GetXAttr()) >= 0) {
				segyFilePath = "Virtual Volume";
			}
		}
		else {
			segyFilePath = GetFile(attributeIndex);
			int fileIndex = segyFilePath.ReverseFind('\\');
			if (fileIndex >= 0) {
				segyFilePath = segyFilePath.Mid(fileIndex + 1);
			}
		}
		outputLine.Format("X Axis: %s File: %s", pParms->GetXAttr(), segyFilePath);
		startIndex = WriteReportLine(outputLine, startIndex);

		attributeIndex = GetAttributeIndex(pParms->GetYAttr());
		// if the index isn't found check if it's a virtual volume.
		if (attributeIndex < 0) {
			if (GetVirtualVolumeIndex(pParms->GetYAttr()) >= 0) {
				segyFilePath = "Virtual Volume";
			}
		}
		else {
			segyFilePath = GetFile(attributeIndex);
			int fileIndex = segyFilePath.ReverseFind('\\');
			if (fileIndex >= 0) {
				segyFilePath = segyFilePath.Mid(fileIndex + 1);
			}
		}
		outputLine.Format("Y Axis: %s File: %s", pParms->GetYAttr(), segyFilePath);
		startIndex = WriteReportLine(outputLine, startIndex);

		for (int j = 0; j<pParms->GetCutoffCount(); j++) {
			CCutoffParms *pCutoff = pParms->CutoffParmsGetAt(j);
			CString strType = pCutoff->Type2Name(pCutoff->m_cutoffType);
			outputLine.Format("%20s %-10s %3d %3d %3d", pCutoff->m_strCutoffName, strType, pCutoff->m_nClassAbove, pCutoff->m_nClassBelow, pCutoff->m_applyTo);
			startIndex = WriteReportLine(outputLine, startIndex);
		}
	}
	return (BYTE *)m_parameterReportBuffer;
}


// Write one line to the report.
// return the index of the beginning of the next line.
int CIMACDoc::WriteReportLine(CString outputLine, int startIndex)
{
	if (startIndex < 3200) {

		CCppUtil cpputil;
		outputLine = outputLine.TrimRight();
		outputLine = cpputil.FilterCString(outputLine);

		int lineLength = outputLine.GetLength();
		if ((lineLength + startIndex) >= 3200) {
			lineLength = 3200 - startIndex - 1;
		}
		memcpy(&m_parameterReportBuffer[startIndex], outputLine.GetString(), lineLength);
		startIndex += ((lineLength / 80) + 1) * 80;
	}
	return startIndex;
}

int CIMACDoc::ColorBarExport(CString fname)
{
    FILE *pf;
	int cbSize = GetColorBarSize();
    COLORREF *pColorbar = GetColorBarPtr();

    if ((pf = fopen(fname, "w")) == NULL) {
        CString msg;
        msg.Format("Cannot open file %s", fname);
        AfxMessageBox(msg);
        return -1;
    }

    for (int i = 0; i < cbSize; i++) {
		CString className;
		if (!IsThirdAttributeMode(GetViewInstance())) {
			className.Format("%s", GetClssName(i).GetBuffer());
			className.Replace("\n","");
		}
        fprintf(pf, "%3d %3d %3d %s\n",
            GetRValue(pColorbar[i]),
            GetGValue(pColorbar[i]),
            GetBValue(pColorbar[i]),
			(const char*)className);
    }
    fclose(pf);
    return 0;
}

int CIMACDoc::CrossplotExport(int viewInstance, CString filename)
{
	FILE *pf;

	if ((pf = fopen(filename, "w")) == NULL) {
		CString msg;
		msg.Format("Cannot open file %s", filename);
		AfxMessageBox(msg);
		return -1;
	}

    fprintf(pf, "#@vers 2.0\n");
    fprintf(pf, "#\n");
    fprintf(pf, "# IMAC Cutoff Data\n");
	fprintf(pf, "# ----------------\n");
	fprintf(pf, "# Cutoff parameters are written on two lines\n");
	fprintf(pf, "# First line is the cutoff name:\n");
	fprintf(pf, "# Second line as follows:\n");
	fprintf(pf, "# Column 1 = Cutoff Type either LINE, POLY or ELLIPSE.\n");
	fprintf(pf, "# Column 2 = Color Above or In the Cutoff.\n");
	fprintf(pf, "# Column 3 = Color Below or Outside of the Cutoff.\n");
    fprintf(pf, "# Column 4 = Class to apply this cutoff to.\n");
    fprintf(pf, "# Column 5 = Group number that this cutoff belongs to.\n");
    fprintf(pf, "# The remainder of the line contains the cutoff data.\n");
	fprintf(pf, "# Line Data - Two coordinate pairs representing the endpoints of the line\n");
	fprintf(pf, "# Polygon Data - The number of points followed by the coordinates of the polygon vertexes\n");
	fprintf(pf, "# Ellipse Data - Three coordinate pairs, the ellipse center, major and minor axis endpoints.\n");
	fprintf(pf, "#\n");
	
	CXplotParms *pParms = GetXplotParms(viewInstance);

	for (int j = 0; j<pParms->GetCutoffCount(); j++) {
		CCutoffParms *pCutoff = pParms->CutoffParmsGetAt(j);
		CString strType = pCutoff->Type2Name(pCutoff->m_cutoffType);
		CString cutoffName;
		CCppUtil cpputil;
		cutoffName = cpputil.FilterCString(pCutoff->m_strCutoffName);

		fprintf(pf, "%s\n", cutoffName.GetBuffer());
		fprintf(pf, "%-10s %3d %3d %3d %3d ", strType.GetBuffer(), pCutoff->m_nClassAbove, pCutoff->m_nClassBelow, pCutoff->m_applyTo, pCutoff->m_nGroupID);
		float x1 = (float)pParms->x1;
		float x2 = (float)pParms->x2;
		float y1 = (float)pParms->y1;
		float y2 = (float)pParms->y2;
		if (pCutoff->m_cutoffType == eLINE) {
			float ax1, ax2, ay1, ay2;
			ax1 = pParms->m_fXMin + (pCutoff->lx1 - x1) / (x2 - x1) * (pParms->m_fXMax - pParms->m_fXMin);
			ax2 = pParms->m_fXMin + (pCutoff->lx2 - x1) / (x2 - x1) * (pParms->m_fXMax - pParms->m_fXMin);
			ay1 = pParms->m_fYMax - (pCutoff->ly1 - y1) / (y2 - y1) * (pParms->m_fYMax - pParms->m_fYMin);
			ay2 = pParms->m_fYMax - (pCutoff->ly2 - y1) / (y2 - y1) * (pParms->m_fYMax - pParms->m_fYMin);
			fprintf(pf, "%7.3f %7.3f %7.3f %7.3f\n", ax1, ay1, ax2, ay2);
		}
		else if (pCutoff->m_cutoffType == ePOLY) {
			float a1, a2;
			int nPoint = pCutoff->m_nPolyData;
			fprintf(pf, "%5d ", nPoint);
			for (int i = 0; i<nPoint; i++) {
				CPoint pt = pCutoff->m_arrPolyData[i];
				a1 = pParms->m_fXMin + (pt.x - x1) / (x2 - x1) * (pParms->m_fXMax - pParms->m_fXMin);
				a2 = pParms->m_fYMax - (pt.y - y1) / (y2 - y1) * (pParms->m_fYMax - pParms->m_fYMin);
				fprintf(pf, "%7.3f %7.3f ", a1, a2);
			}
			fprintf(pf, "\n");
		}
		else if (pCutoff->m_cutoffType == eELLIPSE) {
			CPoint origin = pCutoff->m_ellipse.GetOrigin();
			// get the coordinates of the origin and axis endpoints in floating point.
			float ellXc, ellYc, ellX1, ellY1, ellX2, ellY2;
			float pi2 = (float)atan(1.0) * 2;
			pCutoff->m_ellipse.GetFPoint(0, ellX1, ellY1);
			pCutoff->m_ellipse.GetFPoint(pi2, ellX2, ellY2);
			// convert the screen x,y coodinates to axis coordinates, in float.
			ellXc = pParms->m_fXMin + (origin.x - x1) / (x2 - x1) * (pParms->m_fXMax - pParms->m_fXMin);
			ellYc = pParms->m_fYMax - (origin.y - y1) / (y2 - y1) * (pParms->m_fYMax - pParms->m_fYMin);
			fprintf(pf, "%7.3f %7.3f ", ellXc, ellYc);
			ellX1 = pParms->m_fXMin + (ellX1 - x1) / (x2 - x1) * (pParms->m_fXMax - pParms->m_fXMin);
			ellY1 = pParms->m_fYMax - (ellY1 - y1) / (y2 - y1) * (pParms->m_fYMax - pParms->m_fYMin);
			ellX2 = pParms->m_fXMin + (ellX2 - x1) / (x2 - x1) * (pParms->m_fXMax - pParms->m_fXMin);
			ellY2 = pParms->m_fYMax - (ellY2 - y1) / (y2 - y1) * (pParms->m_fYMax - pParms->m_fYMin);
			fprintf(pf, "%7f %7f %f %f\n", ellX1, ellY1, ellX2, ellY2);
		}
		else {
			fprintf(pf, "unsupported \n");
		}
	}
	fclose(pf);
	return 0;
}

void CIMACDoc::LoadSamplesForAttributeAdvisor(CModelessInfoDlg *pInfoDlg)
{
	CIMACView *pMainView = (CIMACView *)GetMainViewPtr();

	LOAD_AA_SAMPLES_PARM taskparm;
	taskparm.pDoc = this;
	taskparm.pMainView = pMainView;

	CUPDialog progressDlg(AfxGetMainWnd()->GetSafeHwnd(), LoadSamplesForAATask, &taskparm, "Attribute Advisor working...", true);
	progressDlg.DoModal();

}
bool LoadSamplesForAATask(const CUPDUPDATA* pCUPDUPData)
{
	LOAD_AA_SAMPLES_PARM *pTaskparm = (LOAD_AA_SAMPLES_PARM *)pCUPDUPData->GetAppData();
	CIMACDoc *pDoc = pTaskparm->pDoc;
	CIMACView *pMainView = (CIMACView *)pTaskparm->pMainView;

	int startTime = pMainView->GetStartTime();

	// initialize region arrays
	CAARegionArray *pRegionArray1 = pDoc->GetAARegion1ArrayPtr();
	CAARegionArray *pRegionArray2 = pDoc->GetAARegion2ArrayPtr();
	pDoc->DestroyAARegions();
	pDoc->DestroyAAEllipses();
	int regionArrayCount = 0;

	// get the highlight extents
	CRect select = pDoc->GetHighliteRegion1();
	CRect plotBox = pMainView->ClipToBounds(select);
	CRect traceIndex1 = pMainView->ConvertToIndexes(plotBox);
	select = pDoc->GetHighliteRegion2();
	plotBox = pMainView->ClipToBounds(select);
	CRect traceIndex2 = pMainView->ConvertToIndexes(plotBox);

	// volume counts
	int fileCount = pDoc->GetFileCount();
	int virtualVolumeCount = pDoc->GetVirtualVolumeCount();
	if (fileCount == 0) return true;  // nothing to do

	// For the progress dialog, count the number of volumes we'll be loading.
	int progressDialogTotalCount = 0;
	for (int i = 0; i < fileCount + virtualVolumeCount; i++) {
		if (i < fileCount) {
			if (pDoc->IsAASelectedAttribute(pDoc->GetAttr(i))) progressDialogTotalCount++;
		}
		else {
			// Check the VV list
			int vvIndex = i - fileCount;
			CString attributeName = pDoc->GetVirtualVolumeAttributeName(vvIndex);
			if (pDoc->IsAASelectedAttribute(attributeName)) progressDialogTotalCount++;
		}
	}

	// loop through all the volumes, save samples if attribute is selected in the AA dialog
	int progressDialogCount = 0;
	for (int i = 0; i < fileCount + virtualVolumeCount; i++) {
		CSegy *pSegy;
		CString attributeName;

		BOOL useThisAttribute = FALSE;
		if (i < fileCount) {
			attributeName = pDoc->GetAttr(i);
			if (pDoc->IsAASelectedAttribute(attributeName)) {
				useThisAttribute = TRUE;
				pSegy = pDoc->GetSegyInPtr(i);
			}
		}
		else {
			// Check the VV list
			int vvIndex = i - fileCount;
			attributeName = pDoc->GetVirtualVolumeAttributeName(vvIndex);
			if (pDoc->IsAASelectedAttribute(attributeName)) {
				useThisAttribute = TRUE;
				pSegy = pDoc->GetVirtualVolumeSegyPtr(vvIndex);
			}
		}

		if (!useThisAttribute) continue;

		int count = (progressDialogCount++ * 100) / progressDialogTotalCount;
		pCUPDUPData->SetProgress(count);

		// Load the data for this attribute
		if (pSegy->GetTraceCount() == 0) {
			if (i < fileCount) {
				
				pSegy->Reset();
				if (pDoc->GetInlineXlineMode() == eUSERLINE) {
					CPointArray *pData = pDoc->GetCurrentUserLinePtr();
					if (pData == NULL) {
						AfxMessageBox("No Userline has been selected");
						break;
					}
					int ntrace = (int)pData->GetCount();
					pSegy->Create(ntrace, pSegy->GetSegyIndexPtr()->GetSampleCount());
					pSegy->LoadIndexedLine(pDoc->GetFile(i), 0, pDoc->GetInlineXlineMode(), pData);
				}
				else {
					int ntrace = pSegy->Create(pDoc->GetDisplayLine(), pDoc->GetInlineXlineMode(), pSegy->GetSegyIndexPtr()->GetSampleCount());
					if (pSegy->LoadIndexedLine(pDoc->GetFile(i), pDoc->GetDisplayLine(), pDoc->GetInlineXlineMode()) != ntrace) {
						CString msg;
						msg.Format("problem loading line %d from file %s", pDoc->GetDisplayLine(), pDoc->GetFile(i));
						AfxMessageBox(msg);
						break;
					}
				}
			}
			else {
				pDoc->LoadVirtualVolumes(NULL, NULL, &attributeName);
			}
		}

		// save the region data for both regions
		CAARegion *pRegion1 = pDoc->CreateAARegion(attributeName, pSegy, traceIndex1, startTime);
		CAARegion *pRegion2 = pDoc->CreateAARegion(attributeName, pSegy, traceIndex2, startTime);
		pRegionArray1->SetAtGrow(regionArrayCount, pRegion1);
		pRegionArray2->SetAtGrow(regionArrayCount, pRegion2);
		pDoc->SetAARegionCount(++regionArrayCount);
	}
	return true;
}

CAARegion* CIMACDoc::CreateAARegion(CString attributeName, CSegy *pSegy, CRect traceIndex, int startTime)
{
	CAARegion *pRegion = new CAARegion;
	pRegion->SetName(attributeName);
	CFloatArray *pRegionData = pRegion->GetDataPointer();
	int dataCount = 0;

	for (int j = traceIndex.left; j <= traceIndex.right; j++) {
		float flatteningOffset = GetFlatteningOffsetForTrace(pSegy, j);
		int segySampCount = pSegy->GetSampleCount();
		int segyStartTime = pSegy->GetStartTime();
		int segyEndTime = segyStartTime + Index2Time((segySampCount - 1), GetSI());
		int endTime = min(GetEndTime(), segyEndTime);

		float sampleOffset = std::round(flatteningOffset) * 1000 / GetSI();

		int sampCount = Time2Index((endTime - startTime), GetSI()) + 1;
		if (sampCount > segySampCount) sampCount = segySampCount;
		float* pData = pSegy->GetTraceDataPtr(j, startTime);

		std::vector<float> datapoints;
		int count = 0;
		int dataIndex = 0;

		// no shift
		if (sampleOffset == 0) {
			for (int k = traceIndex.top; k < traceIndex.bottom; k++) {
				pRegionData->SetAtGrow(dataCount++, pData[k]);
			}
		}

		// shift up
		else if (sampleOffset < 0) {
			for (int i = startTime + (int)sampleOffset; count < sampCount; i++) {
				if (i < startTime) dataIndex++;
				else if (dataIndex >= sampCount) {
					datapoints.push_back(0);
					count++;
				}
				else {
					datapoints.push_back(pData[dataIndex++]);
					count++;
				}
			}
			for (int k = traceIndex.top; k < traceIndex.bottom; k++) {
				if (flatteningOffset == NULL_HORIZON_VALUE) pRegionData->SetAtGrow(dataCount++, 0);
				else pRegionData->SetAtGrow(dataCount++, datapoints[k]);
			}
		}
		// shift down
		else {
			for (int i = 0; count < sampCount; i++, count++) {
				if (i < sampleOffset) datapoints.push_back(0);
				else if (dataIndex >= sampCount) {
					datapoints.push_back(0);
				}
				else datapoints.push_back(pData[dataIndex++]);
			}
			for (int k = traceIndex.top; k < traceIndex.bottom; k++) {
				if (flatteningOffset == NULL_HORIZON_VALUE) pRegionData->SetAtGrow(dataCount++, 0);
				else pRegionData->SetAtGrow(dataCount++, datapoints[k]);
			}
		}
	}

	pRegion->SetPointCount(dataCount);
	return pRegion;
}

void CIMACDoc::DestroyAARegions()
{
	int regionCount = GetAARegionCount();
	if (regionCount > 0) {
		CAARegionArray *pRegionArray1 = GetAARegion1ArrayPtr();
		CAARegionArray *pRegionArray2 = GetAARegion2ArrayPtr();
		for (int i = 0; i < regionCount; i++) {
			delete pRegionArray1->GetAt(i);
			delete pRegionArray2->GetAt(i);
		}
		pRegionArray1->RemoveAll();
		pRegionArray2->RemoveAll();
		SetAARegionCount(0);
	}
}

void CIMACDoc::DestroyAAEllipses()
{
	int ellipseCount = GetAAEllipseCount();
	if (ellipseCount > 0) {
		CAAEllipseArray *pAAEllipseArray = GetAAEllipseArrayPtr();
		pAAEllipseArray->RemoveAll();
	}
	SetAAEllipseCount(0);
}

void CIMACDoc::DumpAAEllipses()
{
    CAAEllipseArray* pAAEllipseArray = GetAAEllipseArrayPtr();
    int AAEllipseCount = GetAAEllipseCount();

    for (int i = 0; i < AAEllipseCount; i++) {
        CAAEllipse aaEllipse = pAAEllipseArray->GetAt(i);
        TRACE("%d %s %s %f %f %f %f %f %f\n", i, aaEllipse.m_attributeX, aaEllipse.m_attributeY,
            aaEllipse.m_ellipse1.GetXAxisLength(),
            aaEllipse.m_ellipse1.GetYAxisLength(),
            aaEllipse.m_ellipse1.GetXOrigin(),
            aaEllipse.m_ellipse1.GetYOrigin(),
            aaEllipse.m_ellipse1.GetAngle(),
            aaEllipse.m_binCounts);
        TRACE("%d %s %s %f %f %f %f %f %f\n", i, aaEllipse.m_attributeX, aaEllipse.m_attributeY,
            aaEllipse.m_ellipse2.GetXAxisLength(),
            aaEllipse.m_ellipse2.GetYAxisLength(),
            aaEllipse.m_ellipse2.GetXOrigin(),
            aaEllipse.m_ellipse2.GetYOrigin(),
            aaEllipse.m_ellipse2.GetAngle(),
            aaEllipse.m_binCounts);
    }
}

void CIMACDoc::AddAAEllipseCrossplot(int thumbnailIndex, CFloatRect floatRect, CAAEllipse aaEllipse)
{
    float PI = (float)atan(1.0) * 4;

    CIMACApp *pApp = (CIMACApp *)AfxGetApp();
    int nxplot = GetXplotCount();
    if (nxplot == 5) {
        AfxMessageBox("Sorry, only 5 crossplots allowed.");
        return;
    }

    // Fill in the data that we can, then present the user with the crossplot parameter dialog.
    CXplotParms* pParms = GetXplotParms(nxplot);

//    pParms->m_allButton = BST_CHECKED;
//    pParms->m_activeButton = BST_UNCHECKED;
    float stdX = aaEllipse.m_stdX;
    float stdY = aaEllipse.m_stdY;
    float meanX = aaEllipse.m_meanX;
    float meanY = aaEllipse.m_meanY;
    pParms->m_strXAttr = aaEllipse.m_attributeX;
    pParms->m_strYAttr = aaEllipse.m_attributeY;
    pParms->m_fXMin = floatRect.x1 * stdX + meanX;
    pParms->m_fXMax = floatRect.x2 * stdX + meanX;
    pParms->m_fYMin = floatRect.y1 * stdY + meanY;
    pParms->m_fYMax = floatRect.y2 * stdY + meanY;
    float x1 = 100;
    float y1 = 50;
    int frameHeight = pParms->rcWinFrame.Height();
    if (frameHeight == 0) frameHeight = 600;
    float x2 = x1 + frameHeight - 200;
    float y2 = y1 + frameHeight - 200;

    pParms->x1 = (int) x1;
    pParms->x2 = (int) x2;
    pParms->y1 = (int) y1;
    pParms->y2 = (int) y2;
//    pParms->m_title.Format("Attribute Advisor - Thumbnail %d", thumbnailIndex);
    pParms->m_title.Format("Attribute Advisor");

    for (int i = 0; i < 2; i++) {
        CCutoffParms newCutoff;
        newCutoff.m_cutoffType = eELLIPSE;
        CEllipse *pEllipse;
        if (i == 0) {
            pEllipse = &aaEllipse.m_ellipse1;
        } else {
            pEllipse = &aaEllipse.m_ellipse2;
        }

        float ellXc, ellYc, ellX1, ellY1, ellX2, ellY2;
        ellXc = pEllipse->GetXOrigin();
        ellYc = pEllipse->GetYOrigin();
        pEllipse->GetFPoint(0, ellX1, ellY1);
        pEllipse->GetFPoint((float)(PI/2.0), ellX2, ellY2);

        ellXc = ellXc * stdX + meanX;
        ellYc = ellYc * stdY + meanY;
        ellX1 = ellX1 * stdX + meanX;
        ellX2 = ellX2 * stdX + meanX;
        ellY1 = ellY1 * stdY + meanY;
        ellY2 = ellY2 * stdY + meanY;

        // convert the floating coords to screen coordinates
        ellXc = x1 + (ellXc - pParms->m_fXMin) / (pParms->m_fXMax - pParms->m_fXMin) * (x2 - x1);
        ellYc = y2 - (ellYc - pParms->m_fYMin) / (pParms->m_fYMax - pParms->m_fYMin) * (y2 - y1);
        ellX1 = x1 + (ellX1 - pParms->m_fXMin) / (pParms->m_fXMax - pParms->m_fXMin) * (x2 - x1);
        ellY1 = y2 - (ellY1 - pParms->m_fYMin) / (pParms->m_fYMax - pParms->m_fYMin) * (y2 - y1);
        ellX2 = x1 + (ellX2 - pParms->m_fXMin) / (pParms->m_fXMax - pParms->m_fXMin) * (x2 - x1);
        ellY2 = y2 - (ellY2 - pParms->m_fYMin) / (pParms->m_fYMax - pParms->m_fYMin) * (y2 - y1);

        // compute the axis length
        float d1, d2;
        d1 = ((ellX1 - ellXc) * (ellX1 - ellXc)) + ((ellY1 - ellXc) * (ellY1 - ellXc));
        d1 = pow(d1, 0.5f);
        d2 = ((ellX2 - ellXc) * (ellX2 - ellXc)) + ((ellY2 - ellXc) * (ellY2 - ellXc));
        d2 = pow(d2, 0.5f);

        // Create the ellipse
        CPoint cPt = CPoint((int)ellXc, (int)ellYc);
        CPoint xPt = CPoint((int)ellX1, (int)ellY1);
        CPoint yPt = CPoint((int)ellX2, (int)ellY2);
        newCutoff.m_ellipse.SetOrigin(cPt);
        newCutoff.lx1 = cPt.x;
        newCutoff.ly1 = cPt.y;
        newCutoff.lx2 = xPt.x;
        newCutoff.ly2 = xPt.y;
        if (d1 > d2) {
            newCutoff.m_ellipse.SetXAxisEndPoint(yPt);
            newCutoff.m_ellipse.SetYAxisEndPoint(xPt);
        } else {
            newCutoff.m_ellipse.SetXAxisEndPoint(xPt);
            newCutoff.m_ellipse.SetYAxisEndPoint(yPt);
        }

        newCutoff.m_nClassInside = i + 1;
        pParms->CutoffParmsAddTail(&newCutoff);
      
    }

    int status = pApp->EditXplotParms(nxplot);
	if (status == IDOK) {
		SelectAllData();
	} else {
        pParms->ResetXplotVariables();
    }
}

BOOL CIMACDoc::IsAASelectedAttribute(CString attributeName)
{
	BOOL returnValue = FALSE;
	for (int j = 0; j < GetAASelectedAttributeCount(); j++) {
		if (attributeName == GetAASelectedAttribute(j)) {
			returnValue = TRUE;
			break;
		}
	}
	return returnValue;
}

void CIMACDoc::SelectAllData()
{
	CIMACView *pMainView = (CIMACView *)GetMainViewPtr();
	pMainView->SelectAllData();
}

float CIMACDoc::CalculatePetrelOffset(float datum)
{
	float petrelOffset = 0.0;

	CIMACDoc* pDoc = CIMACDoc::GetIMACDocPtr();
	CSegy* pOutputSegy = pDoc->GetSegyOutPtr();
	int segyStartTime = pOutputSegy->GetStartTime();

	if (segyStartTime != 0)
		petrelOffset = segyStartTime + datum + (segyStartTime - datum);
	else
		petrelOffset = datum;

	return petrelOffset;
}

BOOL CIMACDoc::IsHighliteRegionOnCurrentLine()
{
    // check if the selection box is on the current line and lineMode.   
    CSegy *pSegy = GetSegyOutPtr();
    BOOL bReturn = TRUE;

    eLineMode highlightLineMode = GetHighliteLineMode();
    if (highlightLineMode != GetInlineXlineMode()) {
        bReturn = FALSE;
    }
    int highlightLine = (int)GetHighliteLine();
    int currentLine;
    if (GetInlineXlineMode() == eINLINE) {
        currentLine = pSegy->GetInline(1);
    }
    else if (GetInlineXlineMode() == eXLINE) {
        currentLine = pSegy->GetCrossline(1);
    }
    else {
        currentLine = GetSelectedUserLineNumber();
    }
    if (highlightLine != currentLine) {
        bReturn = FALSE;
    }
    return bReturn;
}

// Get the current line, independent of which mode we're in.
int CIMACDoc::GetCurrentLine()
{
    CSegy *pSegy = GetSegyOutPtr();
 
    int currentLine;
    if (GetInlineXlineMode() == eINLINE) {
        currentLine = pSegy->GetInline(1);
    }
    else if (GetInlineXlineMode() == eXLINE) {
        currentLine = pSegy->GetCrossline(1);
    }
    else {
        currentLine = GetSelectedUserLineNumber();
    }
    return currentLine;
}

//
//  Headwave functions
//  -------------------
CHeadwaveSocket *CIMACDoc::GetHeadwaveConnector()
{ 
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	return &pApp->m_headwaveSocket; 
}
BOOL CIMACDoc::IsHeadwaveConnected()
{ 
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	return pApp->m_bHeadwaveConnected; 
}
void CIMACDoc::SetHeadwaveConnected(BOOL value)
{ 
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	pApp->m_bHeadwaveConnected = value;
}
void CIMACDoc::SetHeadwaveOutputFolder(CString path)
{ 
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	pApp->m_headwaveOutputFolder = path;
}
CString CIMACDoc::GetHeadwaveOutputFolder()
{ 
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	return pApp->m_headwaveOutputFolder;
}
void CIMACDoc::SetHeadwaveProjectFolder(CString path)
{ 
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	pApp->m_headwaveProjectFolder = path;
}
CString CIMACDoc::GetHeadwaveProjectFolder()
{ 
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	return pApp->m_headwaveProjectFolder;
}

int CIMACDoc::OpenOrCreateHeadwaveProject(CString path, CString filename)
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return 0;
	if (!IsHeadwaveConnected()) return -1;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();

	// check the version of the python script running on Headwave. 
	CStringArray parameters;
	int stat = pHW->HwCommand(eHW_GET_VERSION, 0, &parameters);
	if (stat != 0) return stat;
	CString pythonRevision = parameters.GetAt(0);
	if (pythonRevision != HW_PYTHON_VERSION) {
		CString message;
		message.Format("%s\n%s%s\n%s%s ", "Detected that QiProPlugin.py is not the correct version.",
			"Found version: ", pythonRevision, "Should be version: ", HW_PYTHON_VERSION);
		AfxMessageBox(message);
		return -1;
	}


	// check if the project exists, then we'll know to open it or create a new one.
	FILE *pf;
	int hwCommand;
	filename.Replace(' ', '-');
	CString fullPath = path + filename;
	if ((pf = fopen(fullPath.GetBuffer(), "r")) != NULL) {
		hwCommand = eHW_OPEN_WORKSPACE;
		fclose(pf);
	}
	else {
		hwCommand = eHW_CREATE_WORKSPACE;
		int dot = filename.ReverseFind('.');
		filename = filename.Left(dot);
	}

	// Check all the segy files in the project and send any that don't already exist in headwave.
	SendSegyFilesToHeadwave();

	// first close any workspace that might be open
	stat = pHW->HwCommand(eHW_CLOSE_WORKSPACE);
	if (stat != 0) return stat;

	// send a signal to Headwave to not update the XPlot objects.  (We're going to delete them)
	SendCrossPlotResetSignalToHeadwave(FALSE);

	// issue the open or create command
	parameters.SetAtGrow(0, path);
	parameters.SetAtGrow(1, filename);
	stat = pHW->HwCommand(hwCommand, 2, &parameters);

	// send the crossplot parameter files.
	if (stat == 0) {
		for (int i = 0; i < GetXplotCount(); i++) {
			int returnStatus = SendCutoffDataToHeadwave(i);
			if (returnStatus != 0) break;
		}
	}

	// Create new workflow
	stat = CreateHeadwaveWorkflow();

	// if creating a new workspace, it has to be closed and opened again to initalize the xplot objects properly
	if (hwCommand == eHW_CREATE_WORKSPACE) {
		CloseHeadwaveWorkspace();
		hwCommand = eHW_OPEN_WORKSPACE;
		parameters.SetAtGrow(0, path);
		filename += ".hww";
		parameters.SetAtGrow(1, filename);
		stat = pHW->HwCommand(hwCommand, 2, &parameters);
	}
	return stat;
}

int CIMACDoc::CloseHeadwaveWorkspace()
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return 0;
	if (!IsHeadwaveConnected()) return -1;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();
	int stat =pHW->HwCommand(eHW_CLOSE_WORKSPACE);
	return stat;
}

int CIMACDoc::CreateHeadwaveWorkflow()
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return 0;
	if (!IsHeadwaveConnected()) return -1;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();
	CString outputFolder = GetHeadwaveOutputFolder();
	int returnStatus = 0;

	// send a signal to Headwave to not update the XPlot objects.  (We're going to delete them)
	SendCrossPlotResetSignalToHeadwave(FALSE);
	
	// Remove the exiting crossplot compute plugins
	DeleteAllHeadwaveXplots();
	if (!IsHeadwaveXPlotReady()) {
		AfxMessageBox("Headwave is having trouble updating the QI-Pro workflow.\nPlease press Update Workspace.");
	}
//	Sleep(1000);

	// Check if the colorbar has been sent, if not sendit.
	if (!IsHeadwaveColorbarDefined()) {
		SendColorbarToHeadwave();
	}

	// Create new crossplot plugins with the correct x and y axis volumes
	for (int i = 0; i < GetXplotCount(); i++) {
		CXplotParms *pXplotParms = GetXplotParms(i);
		CString xAttr = pXplotParms->GetXAttr();
		CString yAttr = pXplotParms->GetYAttr();
		int xAttrIndex = GetAttributeIndex(xAttr);
		int yAttrIndex = GetAttributeIndex(yAttr);
		if (xAttrIndex < 0 || yAttrIndex < 0) {
			if (GetVirtualVolumeIndex(xAttr) > 0 || GetVirtualVolumeIndex(yAttr) > 0) {
				AfxMessageBox("QI-Pro Virtual Volumes are not yet supported in Headwave.\nPlease save your VV to disk and load as segy to your project.");
				return -1;
			}
			CString message;
			message = (xAttrIndex < 0) ? xAttr : yAttr;
			message = "Attribute not found: " + message;
			AfxMessageBox(message);
			return -1;
		}
		CString xFile = GetFile(xAttrIndex);
		CString yFile = GetFile(yAttrIndex);
		CString displayName;
		CString cascade;
		if (i == 0) {
			displayName = "XPlot";
			cascade.Empty();
		}
		else if (i == 1) {
			displayName = "XPlot (2)";
			cascade = "XPlot";
		}
		else {
			displayName.Format("XPlot (%d)", i + 1);
			cascade.Format("XPlot (%d)", i);
		}

		returnStatus = SendCutoffDataToHeadwave(i);
		if (returnStatus != 0) break;

		xFile = SegyFilenameToHeadwaveVDS(xFile, outputFolder);
		yFile = SegyFilenameToHeadwaveVDS(yFile, outputFolder);
		CString cutoffFile = GetLatestFile(i);

		CStringArray parameters;
		parameters.SetAtGrow(0, displayName);
		parameters.SetAtGrow(1, xFile);
		parameters.SetAtGrow(2, yFile);
		parameters.SetAtGrow(3, cascade);
		parameters.SetAtGrow(4, cutoffFile);
		returnStatus = pHW->HwCommand(eHW_NEW_XPLOT, 5, &parameters);
		if (returnStatus != 0) break;
		if (!IsHeadwaveXPlotReady()) {
			AfxMessageBox("Headwave is having trouble finding the XPlot plugin\nPlease press Update Workspace.");
		}
	}
	
	// finally signal the extention plugin to send the cutoff parameter files to the compute plugins.
	if (returnStatus == 0) {
		returnStatus = SendCrossPlotResetSignalToHeadwave(TRUE);
	}

	return returnStatus;
}

int CIMACDoc::SendCutoffDataToHeadwave(int viewInstance)
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return 0;
	if (!IsHeadwaveConnected()) return 0;

	CString outputFolder = BuildHeadwaveCutoffFolder();

	CXplotParms *pParms = GetXplotParms(viewInstance);

	CString filename;
	CTime t = CTime::GetCurrentTime();
	long seconds = (long)t.GetTime();

	filename.Format("XPlot%d_*.txt", viewInstance);
	CCppUtil::DeleteFileByWildcard(outputFolder, filename);

	filename.Format("%sXPlot%d_%d.txt", outputFolder, viewInstance, seconds);
	FILE *pf;
	if ((pf = fopen(filename, "w")) == NULL) {
		CString msg;
		msg.Format("Cannot open file %s", filename);
		AfxMessageBox(msg);
		return -1;
	}

	CString string;
	fprintf(pf, "#@vers 1.0\n");
	fprintf(pf, "#\n");
	fprintf(pf, "# QI-Pro Crossplot and Cutoff Data\n");
	fprintf(pf, "# --------------------------------\n");
	fprintf(pf, "#\n");
	fprintf(pf, "CrossplotVersion= %d\n", pParms->m_version);
	string = pParms->m_strXAttr.Trim();
	if (string.IsEmpty()) string = ".";
	fprintf(pf, "XAttribute= %s\n", string.GetBuffer());
	string = pParms->m_strYAttr.Trim();
	if (string.IsEmpty()) string = ".";
	fprintf(pf, "YAttribute= %s\n", string.GetBuffer());
	fprintf(pf, "XMin= %f\n", pParms->m_fXMin);
	fprintf(pf, "YMin= %f\n", pParms->m_fYMin);
	fprintf(pf, "XMax= %f\n", pParms->m_fXMax);
	fprintf(pf, "YMax= %f\n", pParms->m_fYMax);
	fprintf(pf, "x1= %d\n", pParms->x1);
	fprintf(pf, "y1= %d\n", pParms->y1);
	fprintf(pf, "x2= %d\n", pParms->x2);
	fprintf(pf, "y2= %d\n", pParms->y2);
	fprintf(pf, "CutoffCount= %d\n", pParms->GetCutoffCount());

	for (int i = 0; i < pParms->GetCutoffCount(); i++) {
		pParms->CutoffParmsGetAt(i)->DumpCutoffData(pf);
	}

	fclose(pf);
	return 0;
}

int CIMACDoc::SendCrossPlotResetSignalToHeadwave(BOOL resetFlag)
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return 0;
	if (!IsHeadwaveConnected()) return 0;
	CString outputFolder = BuildHeadwaveCutoffFolder();

	if (outputFolder.IsEmpty()) {
		AfxMessageBox("Output folder not defined. Please check Headwave settings dialog");
		return -1;
	}

	CString filename;
	CString resetFilename;
	CString noResetFilename;
	resetFilename.Format("%sXPlot_Reset.txt", outputFolder);
	noResetFilename.Format("%sXPlot_NoReset.txt", outputFolder);

	if (resetFlag) {
		remove(noResetFilename);
		filename = resetFilename;
	}
	else {
		remove(resetFilename);
		filename = noResetFilename;
	}
	FILE *pf;
	if ((pf = fopen(filename, "w")) == NULL) {
		CString msg;
		msg.Format("Cannot open file %s", filename);
		AfxMessageBox(msg);
		return -1;
	}
	fprintf(pf, "The presence of this file is a signal to the QI-Pro extension plugin.\n");
	fprintf(pf, "The plugin will look for instances of XPlot in the workflow and pass them the appropriate parameter file.\n");
	fprintf(pf, "This file can safely be removed.\n");
	fclose(pf);
	return 0;
}

CString CIMACDoc::GetLatestFile(int instance)
{
	// search for the files C:\HW_Data\XPlot_<workspaceName>\XPlot<instance>_1557428893.txt
	// return the full path as filename.
	// if more than one file exists differing only in the 10 digit number, return the highest.

	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return 0;
	if (!IsHeadwaveConnected()) return 0;
	CString outputFolder = BuildHeadwaveCutoffFolder();

	CString filename;
	int fileTime = 0;
	char buffer[256];
	sprintf(buffer, "%s%s%d%s", (LPCTSTR)outputFolder, "XPlot", instance, "_*.txt");
	std::string search_path = buffer;
	WIN32_FIND_DATA fd;
	HANDLE hFind = ::FindFirstFile(search_path.c_str(), &fd);
	if (hFind != INVALID_HANDLE_VALUE) {
		do {
			std::string file = fd.cFileName;
			int time = 0;
			std::size_t leftDelimiter = file.rfind("_");
			std::size_t rightDelimiter = file.rfind(".");
			if (leftDelimiter != std::string::npos && rightDelimiter != std::string::npos) {
				std::string strTime = file.substr(leftDelimiter + 1, rightDelimiter - leftDelimiter - 1);
				time = atol(strTime.c_str());
			}

			if (time > fileTime) {
				fileTime = time;
				filename = outputFolder + file.c_str();
			}

		} while (::FindNextFile(hFind, &fd));
		::FindClose(hFind);
	}
	return filename;
}

CString CIMACDoc::SegyFilenameToHeadwaveVDS(CString infile, CString outputFolder)
{
	CString outfile = infile.Left(infile.ReverseFind('.'));
	outfile = outfile.Mid(outfile.ReverseFind('\\'));
	outfile += ".vds";
	outfile = outputFolder + outfile;
	return outfile;
}

CString CIMACDoc::BuildHeadwaveProjectName(CString *projectName)
{

	CString hwProjectName;
	if (projectName == NULL) {
		hwProjectName = GetProjectName();
	}
	else {
		hwProjectName = *projectName;
	}
	int dot = hwProjectName.ReverseFind('.');
	hwProjectName = hwProjectName.Left(dot) + ".hww";
	return hwProjectName;
}

CString CIMACDoc::BuildHeadwaveCutoffFolder()
{
	CString outputFolder = GetHeadwaveOutputFolder();
	CString projectName = BuildHeadwaveProjectName();
	projectName = projectName.Left(projectName.ReverseFind('.'));
	projectName = "XPlot_" + projectName;
	CString folderName = outputFolder + projectName;
	folderName.Replace(' ', '-');
	_mkdir(folderName);
	folderName += "\\";
	return folderName;
}

void CIMACDoc::ValidatePath(CString *path)
{
	*path = path->Trim();
	path->Replace('/', '\\');
	if (path->IsEmpty()) return;
	char lastChar = path->GetAt(path->GetLength() - 1);
	if (lastChar != '/' && lastChar != '\\') {
		*path += '\\';
	}
}

void CIMACDoc::DeleteAllHeadwaveXplots()
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return;
	if (!IsHeadwaveConnected()) return;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();

	// The Delete command will remove all poststack objects beginning with XPlot
	CStringArray parameters;
	parameters.SetAtGrow(0, "XPlot");
	if (pHW->HwCommand(eHW_DELETE_XPLOT, 1, &parameters)) return;
}

void CIMACDoc::SendColorbarToHeadwave()
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return;
	if (!IsHeadwaveConnected()) return;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();
	COLORREF *pColorbar = GetColorBar();
	int colorCount = GetColorBarSize();
	CStringArray parameters;
	CString parameter;
	for (int i = 0; i < colorCount; i++)
	{
		COLORREF color = pColorbar[i];
		int red = GetRValue(color);
		int grn = GetGValue(color);
		int blu = GetBValue(color);
		parameter.Format("%4d%4d%4d", red, grn, blu);
		parameters.SetAtGrow(i, parameter);
	}
	pHW->HwCommand(eHW_NEW_COLORBAR, colorCount, &parameters);
}

BOOL CIMACDoc::IsHeadwaveColorbarDefined()
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return FALSE;
	if (!IsHeadwaveConnected()) return FALSE;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();

	CStringArray parameters;
	if (pHW->HwCommand(eHW_IS_COLORBAR_DEFINED, 0, &parameters)) return FALSE;
	CString retValue = parameters.GetAt(0);
	return (retValue == "Defined");
}

BOOL CIMACDoc::IsHeadwaveXPlotReady()
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return FALSE;
	if (!IsHeadwaveConnected()) return FALSE;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();

	CStringArray parameters;
	if (pHW->HwCommand(eHW_IS_XPLOT_READY, 0, &parameters)) return FALSE;
	CString retValue = parameters.GetAt(0);
	return (retValue == "Ready");
}

int CIMACDoc::ExportSegyToHeadwave(int nCount, CStringArray *parrSegyFilenames)
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return -1;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();

	CStringArray arrParameters;
	CString outputFolder = GetHeadwaveOutputFolder();

	CString pythonPath = pHW->GetPythonPath();
	if (pythonPath.IsEmpty()) return -1;

	for (int i = 0; i < nCount; i++) {
		CString infile = parrSegyFilenames->GetAt(i);
		int segyIndex = GetFileIndex(infile);
		CSegy *pSegy = GetSegyInPtr(segyIndex);
		CHeaderMap *pHeaderMap = pSegy->GetHeaderMap();
		int iline = (int)pHeaderMap->inlineNum.GetIndex() + 1;
		int xline = (int)pHeaderMap->xlineNum.GetIndex() + 1;
		int cdpX = (int)pHeaderMap->cdpX.GetIndex() + 1;
		int cdpY = (int)pHeaderMap->cdpY.GetIndex() + 1;

		CString outfile = SegyFilenameToHeadwaveVDS(infile, outputFolder);

		CString parameters;
		parameters.Format("--allow-overwrite --segy-type poststack --compression-method RLE --crossline %d --inline %d --easting %d --northing %d \"%s\" \"%s\"",
			xline, iline, cdpX, cdpY, infile, outfile);
		arrParameters.SetAtGrow(i, parameters);
	}

	CString batchFile = outputFolder + "\\Convert_segy_vds.bat";
	CString command = "\\python\\headwave\\demo\\convert_segy_vds.py ";
	CString comment = "Converting Segy to vds";
	pHW->ExecuteHeadwaveBatch(batchFile, pythonPath, command, comment, &arrParameters);
	return 0;
}

int CIMACDoc::SendSegyFilesToHeadwave()
{
	CIMACApp *pApp = (CIMACApp *)AfxGetApp();
	if (!pApp->IsHeadwaveMode()) return -1;
	CHeadwaveSocket *pHW = GetHeadwaveConnector();

	CStringArray arrSegyFilenames;
	CString outputFolder = GetHeadwaveOutputFolder();
	for (int i = 0; i < GetFileCount(); i++) {
		CString infile = GetFile(i);
		CString outfile = SegyFilenameToHeadwaveVDS(infile, outputFolder);
		// Check if file exists, if not add to list
		FILE *pf;
		if ((pf = fopen(outfile.GetBuffer(), "r"))) {
			fclose(pf);
		}
		else {
			arrSegyFilenames.Add(infile);
		}
	}
	int outCount = (int) arrSegyFilenames.GetCount();
	if (outCount > 0) {
		ExportSegyToHeadwave(outCount, &arrSegyFilenames);
	}
	return 0;
}

int CIMACDoc::LaunchHeadwave()
{
	CHeadwaveSocket *pHW = GetHeadwaveConnector();

	// export the VDS files
	SendSegyFilesToHeadwave();

	// Before launching check if an instance is already running. If so connect to it.
	int istat = -1;
	if (pHW->HwCommand(eHW_CONNECT, 0, NULL, TRUE) == 0) {
		istat = IDOK;
	}
	else {

		HW_LAUNCH_PARM hwLaunchParm;
		hwLaunchParm.launchCommand = HW_EXE_PATH;
		hwLaunchParm.pHW = pHW;
		HWND parentWindow = AfxGetMainWnd()->GetSafeHwnd();
		CUPDialog launchDlg(
			parentWindow,
			HWLaunchTask,
			&hwLaunchParm,
			_T("Launching Headwave"),
			true
		);
		istat = (int)launchDlg.DoModal();
	}

	if (istat == IDOK) {
		if (pHW->HwCommand(eHW_CONNECT) != 0) {
			AfxMessageBox("Cannot connect to Headwave");
			SetHeadwaveConnected(FALSE);
			return -1;
		}
		SetHeadwaveConnected(TRUE);

		CStringArray parameters;
		if (pHW->HwCommand(eHW_GET_OUTPUT_FOLDER, 0, &parameters)) return -1;
		CString outputFolder = parameters.GetAt(0);
		ValidatePath(&outputFolder);
		SetHeadwaveOutputFolder(outputFolder);

		CString projectFolder = GetHeadwaveProjectFolder();
		ValidatePath(&projectFolder);
		CString projectName = BuildHeadwaveProjectName();

		OpenOrCreateHeadwaveProject(projectFolder, projectName);

	}

	return istat;
}


bool CIMACDoc::HWLaunchTask(const CUPDUPDATA* pCUPDUPData)
{
	HW_LAUNCH_PARM *pTaskParm = (HW_LAUNCH_PARM *)pCUPDUPData->GetAppData();
	CHeadwaveSocket *pHwSocket = pTaskParm->pHW;
	pHwSocket->ExecuteHeadwaveCommand(pTaskParm->launchCommand, "");
	bool connected = false;
	int count = 0;
	while (!connected && !pCUPDUPData->ShouldTerminate()) {
		Sleep(1000);
		connected = (pHwSocket->HwCommand(eHW_CONNECT, 0, NULL, TRUE) == 0);
		pCUPDUPData->SetProgress(count);
		count += 10;
	}
	// sleep another few seconds to give HW time to fully load
	int seconds = 10;
	while (seconds > 0 && !pCUPDUPData->ShouldTerminate()) {
		Sleep(1000);
		pCUPDUPData->SetProgress(count);
		count += 10;
		seconds--;
	}

	return !pCUPDUPData->ShouldTerminate();
}
