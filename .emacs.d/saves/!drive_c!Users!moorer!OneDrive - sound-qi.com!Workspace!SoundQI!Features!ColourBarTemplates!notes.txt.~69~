Pipeline: Feature Requests and Defects
Priority: Medium
Name: Add standard colour bars like Rainbow, Sand shale etc to the colour bar settings
Description: Add standard colour bars like Rainbow, Sand shale etc tot eh colour bar settings in Xplot. Slide 11 - 
file:\\soundqi-dc2\Shared Drive\QI-Pro Support\Features-Bugs_Monthly_Meeting\2020_12_QI_Pro_feature _request.pptx
Software Component: Color Editor
Rank: 5 - High
Video Link:

-----

-How do the data members in CCrossPlotSettingsDlg get serialized?
-How do I enable the CColorCombo CCrossPlotSettingsDlg for point density?

-----

Review of Color Bar Templates with Kevin (2021.06.21):
1) CrossplotSettingsDlg: the color bar is missing user color bars -> COMPLETE
2) Periodically it is getting an ixpen == - 1 -> COMPLETE
3) The color bar on the RHS is too long so need to scale it -> COMPLETE
4) When you set the scatter point to anything but 1 then you get a square box -> COMPLETE

Review of Color Bar Templates with Kevin (2021.06.09):
-Remove ColorBarTemplates directory creation in run_installers.py -> COMPLETE
-CColorBarView is not reloading *.cb files other than ClassColors.cb -> COMPLETE (works when running from C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\OSI.sln)
-Put *.cb files in "Horn River Demo\Projects" with a subdirectory folder of the project name and put the *.cb files in there under QI-Pro_data -> COMPLETE
-Needs to read the *.cb files from "Horn River Demo\Projects" every time CColorBarView closes and re-opens. -> COMPLETE
-Save the ColorBarTemplates file number so every time they re-open the window it picks the one they had before, e.g., Lithology -> COMPLETE
-If they change one, say Greyscale, then automatically create a Greyscale.cb file, so there will be a Greyscale in yellow.  This happens the moment you edit the CColorBarView color bar. -> COMPLETE
-Put the code back in that reads the *.cb files from "Horn River Demo\Projects" -> COMPLETE (stores user-generated *.cb for example in C:\QI-Pro Demo\Horn River Demo\Projects\UserColorBarFiles\QI-Pro Laurie complete)
-Don`t put files into %appdata% when the user adds a file, instead put it into "Horn River Demo\Projects." -> COMPLETE
-Overwrite ClassColors.cb file every time when you open the project, not when you open CColorBarView.  Instead, when you open CColorBarView it should read the *.cb files. -> COMPLETE
BUG: -When you create a new project, the CColorBarView combobox is empty.

Roger:
TODO:

-There will be an issue if anyone ever puts a dot in the color bar name because of how you try to find the extension. You need to do a reverse find for the dot, otherwise everything after the first dot will be considered an extension. -> COMPLETE
-There is an issue with the serialization…..I assume that you did a merge, and got my version change from 92 to 93. You changed the A_ArchiveVersion.h to be 94, however you never changed your serialization code to use 94 instead of 93…..which means anyone who saved a project using the 93 version will crash when they use this latest code. You need to change XPlotParms.cpp to use 94 instead of 93 as well. -> COMPLETE
-You’ve changed the text color on the color combo to be a very light gray, which makes it very hard to read. I thought that you were going to change the background item color to be light grey and not the text color for .cb files. -> COMPLETE (changed from light grey to blue)
-The selected color bar is now only drawing the name and not the colorbar in the colorbar window -> COMPLETE
-You’ve seemed to have added more code in the colorbarview that deals with is this the third attribute color…..I thought since you added the colorbar to the crossplot parms dialog, that there will never be a way to get to the colorbarview as a third attribute. You should be removing anything in the colorbarview that has to deal with the third attribute color. -> COMPLETE (Removed third attribute, i.e., seismic attribute, because it is no longer needed so we are using CColorBarCombop in the CrossplotSettingsDlg instead of a link to the CColorBarView)


-----

-Color Bar Templates: When importing, change the file filter to be *.txt; *.cb -> COMPLETE
-On import color bar template *.txt, automatically select that one -> COMPLETE
-Remove "Import Color Bar Template" button and put it as the first item in the combobox list, "Add new Color Bar Template" -> COMPLETE
-Don`t bother saving the decimated values as *.cb files -> COMPLETE
-Change save as color bar with the color bars in %appdata%\project name.  So only have in this directory the color bars saved by the user.  Load these user-saved ones as "Color Bar Name.cb" -> COMPLETE
-The .txt files are just a list of RGB values, but the *.cb files have RGB plus the class names -> COMPLETE
-Put "User defined - color bar file name": make it one character, like a mu μ (instead changed text brush to gray) -> COMPLETE
-Put combobox in xplotsettings: here don`t load the custom user-defined color bar *.cb files -> COMPLETE
-Need to retain the names (say if the user adds a new class name), unless, you restore *.cb file -> COMPLETE
-Don`t put import on the dropdown, just change the extension to *.cb, *.txt on the Open Color Bar -> COMPLETE

-----

-"Seismic Attribute" means "Third Attribute": When you scan it maps the attributes to the color bar. It only does it for a given crossplot, not all the other windows.  It should only affect the Third Attribute if you change the colors, and nothing else. -> COMPLETE
-Grey out the "Color Map:" label -> COMPLETE
-Can strip out all of the Third Attribute mode source code to simplify things -> COMPLETE
-Give them the color bar combobox in "Point Density" and in "Seismic Attribute" -> COMPLETE
-Wait to actually change the colors until they press OK -> COMPLETE
-Will have to change the serialization of the crossplot, to save the color bar combobox name (see code for well stuff, IMACView, the drawing of the wells, how it takes the color bar name, and gets the list of wells).
-Have a distinction between color bar template files and the user-defined color bar files, like add a red dot or something (instead of mu), so instead maybe have mu - colorbar, and make sure the names line up.  Maybe add a custom icon, like a painters pallet.  Or change the background color instead.
-Store user-defined color bar files *.cb into project directory instead of in %appdata% 
-Do the sort in the utilities class, and then change the background color for the user-defined *.cb files.  Maybe put the user-defined ones at the top of the list

-----
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1477


http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1435
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1425
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1424



http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1393


-----

-----Original Appointment-----
From: Roger Moore 
Sent: February 25, 2021 2:28 PM
To: Roger Moore; Carl Reine; Draga Talinga; Kaushal Pander
Cc: Brenda Maloff; Kevin Lee; Laurie Weston
Subject: Add standard colour bars like Rainbow, Sand shale etc to the colour bar settings
When: March 2, 2021 10:00 AM-11:00 AM (UTC-07:00) Mountain Time (US & Canada).
Where: Teams

Clarification on requirements for this software development task:

•	Should we save custom color bar settings as text files in the installation directory or in AppData, or have them be a limited set that are compiled directly into the QI-Pro executable?  What is the best way to ensure that a given customer’s custom color bar settings don’t get deleted or lost when they install a new version of QI-Pro?
•	Should we have the custom color bars be selected in the Color Bar via combobox or open file selector?  Should we allow users to add as many custom color bar settings files as they want, or limit it to a pre-defined set?
•	What specific custom color bar settings should we have? Rainbow, Sand shale, etc?  
•	Should we allow the user to select these custom color bar settings in the "Color Bar" accessed only from the "Xplot Settings" dialog or from other ways as well?
________________________________________________________________________________ 
Microsoft Teams meeting 

--------------------------------------------------------------------------------

Clarification on requirements for this software development task:

•	Should we save custom color bar settings as text files in the installation directory or in AppData, or have them be a limited set that are compiled directly into the QI-Pro executable?  What is the best way to ensure that a given customer’s custom color bar settings don’t get deleted or lost when they install a new version of QI-Pro?

-Brenda: Don`t need just one place for things.  We could store some in a binary, some in a directory, some in an AppData folder.
-Carl: There are default built-in color bars, but you can still customize any of those.  Do we need separate files?  
-Kevin: If you load a different version of QI-Pro, so then a different executable doesn`t have those templates built-in.
-Brenda: If you want to pull in a bunch of color bars maybe we do want an external file?
-Carl: In terms of having stored colors
-Brenda: Dolomites are blue, sandstones are yellow
-The classified colour bar is going to be a tricky one.  Maybe even just changing the default color bar, so that it is a bit bigger than 10 classes.  Let us have, say, 15 classes.
-Kaushal: For classified volume, we don`t need a custom colour bar.  When they are done, they just tweak it a bit.  I was thinking if you want to see porosity, s-impedance, z-impedance, there are custom colour bars out there.  We need to make sure that when a person upgrades QI-Pro, he shouldn`t lose it, if he moves or upgrades.
-Carl: The paste, easter-egg color 
-Laurie: Instead of them saving to an internal database is better.  If they save to their own directory, they will lose it all of the time.  If you can internally save it to a database that goes with QI-Pro.  
-Carl: If they have several projects, we want the colour bar to go between projects.
-Kaushal: In my view, whenever you open QI-Pro, you should see all of your color bars.  
-Kevin: I don`t want to lose existing functionality, so if somebody wants to save their color bar as a text file, they can then send it to a colleague.
-Save the whole range of options.
-Brenda: Would you really want to see all of your color bars in all of your projects?  It might get pretty big soon.
-Kaushal: How Petrel works, is it saves it in the project, butthen it has that reference tool function so I can transfer that colour bar between projects.
-Brenda: It might be good to store the colour bars in the app directory or in AppData, then we are kind of building up a database. 
-Laurie: I think we should start simple.  Rather than trying to think of every possible situation that may arise, let us put in a few colour bar templates that everybody uses in the install directory.  
-Kevin: They will always be saved in the project.  But we won`t save the whole database in the project.

•	Should we have the custom color bars be selected in the Color Bar via combobox or open file selector?  Should we allow users to add as many custom color bar settings files as they want, or limit it to a pre-defined set?
•	What specific custom color bar settings should we have? Rainbow, Sand shale, etc?  
•	Should we allow the user to select these custom color bar settings in the “Color Bar” accessed only from the “Xplot Settings” dialog or from other ways as well?

Laurie: I have had this idea that you can have this highlight color in your colour bar, and you can slide it up and down in your porosity or point density colour.  
-Kaushal: We were wondering about inserting two colours, in between.  
-Brenda: We have another ticket.
-Laurie: Do we have a greyscale as well?
-Carl: Do we have a target number of spectra to have?  10?  7?
-Laurie: That is for the Thrid Attribute, right?
-Kevin: We will save all the color bars in use in the project bar.  We will ... in the Third Attribute mode, to save to a database.  Then we will allow the user to export their database.
-Carl: In Hampson Russel, you have individually select every color bar combo-box text item to see what it actually is.  This drives me absolutely batty.
-Brenda: We want to put a little Red, White and Blue swatch.
-Kevin: Save class names as well as part of the colour bar 

-----

-Changesets for code review:

http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1177
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1182
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1234
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1238
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1239
http://sqi009:8080/tfs/DefaultCollection/SoundQI/_versionControl/changeset/1241
http://sqi009:8080/tfs/DefaultCollection/SoundQI/_versionControl/changeset/1243
http://sqi009:8080/tfs/DefaultCollection/SoundQI/_versionControl/changeset/1244

http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1260
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1261
http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/1262

-----

2021.03.23
I. Researching and implementing solution:                        

STRINGTABLE
BEGIN
    ID_OUTPUT_SEGY          "SEG-Y Output"
    ID_FILE_EXPORT_SEGY     "Save Classified Seismic Volume as a SEG-Y file\nSave Classified Seismic Volume as a SEG-Y file"
    ID_CB_NEW               "Create a New Color Set\nCreate a New Color Set"
    ID_CB_OPEN              "Load a Color Set File\nLoad a Color Set File"
    ID_CB_SAVE              "Save this Color Set\nSave this Color Set"
    ID_CB_CLEAR             "Clear All Colors\nClear All Colors"
    ID_CB_INTERP            "Interpolate Color Scale\nInterpolate Color Scale"
    ID_CB_HELP              "Class Manager Help\nClass Manager Help"
END

COMBOBOX        IDC_X_COMBO,76,88,356,57,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP

void CCrossPlotSettingsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    // ...
    DDX_Control(pDX, IDC_X_COMBO, m_xAttrCombo);
    // ...
}

ON_CBN_SELCHANGE(IDC_X_COMBO, OnSelchangeXCombo)

void CCrossPlotSettingsDlg::OnSelchangeXCombo()
{
	UpdateData(TRUE);
	PopulateMinMax(&m_xAttrCombo, &m_xMin, &m_xMax);
	UpdateData(FALSE);
}

CComboBox	  m_xAttrCombo;

void CCrossPlotSettingsDlg::OnScanXattr() 
{
    UpdateData(TRUE);
    DoScan(&m_xAttrCombo, &m_xMin, &m_xMax);
}

bool CCrossPlotSettingsDlg::IsValid()
{
	UpdateData(TRUE);
	SaveActiveData();
	int xCurSel = m_xAttrCombo.GetCurSel();
	int yCurSel = m_yAttrCombo.GetCurSel();
	int cCurSel = m_thirdAttribute.GetCurSel();

	m_strXAttr = _T("");
	m_strYAttr = _T("");
	m_strColorAttr = _T("");

	if (xCurSel >= 0) {
		m_xAttrCombo.GetLBText(xCurSel, m_strXAttr);
	}
	if (yCurSel >= 0) {
		m_yAttrCombo.GetLBText(yCurSel, m_strYAttr);
	}
	if (cCurSel >= 0) {
		m_thirdAttribute.GetLBText(cCurSel, m_strColorAttr);
	}
    // ...
}    

Where:

  CString	m_strXAttr;

OnInitDialog:

	int xselect = m_xAttrCombo.FindStringExact( -1, m_parms.m_strXAttr);
	int yselect = m_yAttrCombo.FindStringExact( -1, m_parms.m_strYAttr);
	int cselect = m_thirdAttribute.FindStringExact(-1, m_parms.m_strColorAttr);
	m_xAttrCombo.SetCurSel(xselect);
	m_yAttrCombo.SetCurSel(yselect);
	m_thirdAttribute.SetCurSel(cselect);

BEGIN_MESSAGE_MAP(CColorBarView, CView)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	ON_COMMAND(ID_CB_INTERP, OnCbInterp)
	ON_COMMAND(ID_CB_CLEAR, OnCbClear)
	ON_COMMAND(ID_CB_NEW, OnCbExtend)
	ON_COMMAND(ID_CB_OPEN, OnCbOpen)
	ON_COMMAND(ID_CB_SAVE, OnCbSave)
	ON_COMMAND(ID_CB_HELP, OnCbHelp)
	ON_COMMAND(ID_CB_EXIT, OnCbExit)

	ON_UPDATE_COMMAND_UI(ID_CB_NAMES, OnUpdateCbNames)
	ON_COMMAND(ID_CB_NAMES, &CColorBarView::OnCbNames)
END_MESSAGE_MAP()


COMBOBOX        IDC_COMBO_DEFAULT,54,57,255,30,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP

COMBOBOX        IDC_CUTOFFTYPE,154,54,50,30,CBS_DROPDOWN | WS_VSCROLL | WS_TABSTOP

    COMBOBOX        IDC_COMBO_CLASS_ABOVE,154,70,50,30,CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP

COMBOBOX        IDC_USERLINE_COMBO,12,267,64,51,CBS_DROPDOWN | WS_VSCROLL | WS_GROUP | WS_TABSTOP    

	// populate the x and y attribute combo box drop down menus.
	m_xAttrCombo.ResetContent();
	m_yAttrCombo.ResetContent();
	m_thirdAttribute.ResetContent();

	for ( i = 0; i < m_fileCount; i++) {
		if (!m_attr[i].IsEmpty() && m_favorite[i] >= 0) {
			m_xAttrCombo.AddString(m_attr[i]);
			m_yAttrCombo.AddString(m_attr[i]);
			m_thirdAttribute.AddString(m_attr[i]);
		}
	}

	m_strTitleBox.Format("Crossplot %d Settings - %s", m_viewInstance + 1, m_parms.m_title);


	int xselect = m_xAttrCombo.FindStringExact( -1, m_parms.m_strXAttr);
	int yselect = m_yAttrCombo.FindStringExact( -1, m_parms.m_strYAttr);
	int cselect = m_thirdAttribute.FindStringExact(-1, m_parms.m_strColorAttr);
	m_xAttrCombo.SetCurSel(xselect);

-----

    CComboBox m_colorTemplateCombo;

    COMBOBOX    IDC_COMBO_COLOR_TEMPLATE, 154, 10, 50, 30, CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP

2021.03.23
I. Researching and implementing solution:                        
    
-Instead of trying to set values in IMAC.rc for the combobox the ColorBarView is a CView instead of a CDialog so it means that you have to create the combobox like the Crossline/Userline one in the main view:

	// find the coordinates of the placeholder on the toolbar. This is where the controls will be placed.
	CRect rect;
	int index = 0;
	UINT ID = 0;
	while (ID != ID_PLACEHOLDER) {
		ID = m_wndToolBar.GetItemID(index++);
	}
	index--;
	m_wndToolBar.SetButtonInfo(index, ID_PLACEHOLDER, TBBS_SEPARATOR, 1);
	m_wndToolBar.GetItemRect(index, &rect);

        // ...

	// the Xline select combo box
	extent = pDC->GetTextExtent("1234567");
	rect.left  = rect.right;
	rect.right = rect.left  + extent.cx + 30;
	if (!m_wndToolBar.m_cmbXline.Create( WS_CHILD|WS_VISIBLE|CBS_DROPDOWN|WS_VSCROLL, 
				rect, &m_wndToolBar, IDC_COMBO_XLINE)) {
		TRACE0("Failed to create line select combo Box\n");
		return -1;
	}
	m_wndToolBar.m_cmbXline.SetLineMode(eXLINE);


    COMBOBOX    IDC_COMBO_COLOR_TEMPLATE, 104, 10, 50, 30, CBS_DROPDOWNLIST | CBS_OWNERDRAWFIXED | CBS_HASSTRINGS | WS_VSCROLL | WS_TABSTOP

    
-----

void CColorBarView::OnInitialUpdate()
{
	m_intensity = 1.0;
	m_lbuttondown = FALSE;
	m_palletIndex = -2;	// nothing selected
	m_colorbarIndex = -1;
	m_colorbarIndexMouseMove = -1;
	pApp = (CIMACApp*)AfxGetApp();
}

void CMainFrame::CreateCrossplotMenus()
{
	CIMACDoc* pDoc = CIMACApp::GetDocument();
	if (pDoc != NULL)
	{
		int nXplot = pDoc->GetXplotCount();

		if (nXplot != 0)
		{
			CMenu* mainMenu = AfxGetMainWnd()->GetMenu();

			// Add cross plots into the View menu
			CMenu* viewMenu = mainMenu->GetSubMenu(3);
			if (viewMenu)
			{
				for (int i = 0; i < nXplot; i++)
				{
					CXplotParms* pXplot = pDoc->GetXplotParms(i);
					CString title;
					title.Format("Crossplot %d - %s", i + 1, pXplot->m_title);
					viewMenu->AppendMenu(MF_STRING | MF_ENABLED, ID_VIEW_XPLOTS + i + 1, title);
				}
			}

			// Add cross plots settings into the Crossplot menu
			CMenu* crossplotMenu = mainMenu->GetSubMenu(2);
			if (crossplotMenu)
			{
				for (int i = 0; i < nXplot; i++)
				{
					CXplotParms* pXplot = pDoc->GetXplotParms(i);
					CString title;
					title.Format("Crossplot %d Settings - %s", i + 1, pXplot->m_title);
					crossplotMenu->AppendMenu(MF_STRING | MF_ENABLED, ID_EDIT_XPLOT_PARMS + i + 1, title);
				}
			}
		}
	}
}

Which is called from:

void CMainFrame::UpdateCrossplotMenus()
{
	CIMACDoc* pDoc = CIMACApp::GetDocument();
	if (pDoc != NULL)
	{
		CMenu* mainMenu = AfxGetMainWnd()->GetMenu();
		CMenu* viewMenu = mainMenu->GetSubMenu(3);
		if (viewMenu)
		{
			int count = viewMenu->GetMenuItemCount();
			for (int i = 0; i < NXPLOT; i++)
				viewMenu->DeleteMenu(ID_VIEW_XPLOTS + i + 1, MF_BYCOMMAND);
		}
		CMenu* crossplotMenu = mainMenu->GetSubMenu(2);
		if (crossplotMenu)
		{
			for (int i = 0; i < NXPLOT; i++)
				crossplotMenu->DeleteMenu(ID_EDIT_XPLOT_PARMS + i + 1, MF_BYCOMMAND);
		}
		CreateCrossplotMenus();
	}
}

void CMainFrame::OnActivate(UINT state, CWnd* wndOther, BOOL minimized)
{
	UpdateCrossplotMenus();
}

BOOL CMainFrame::OnNcActivate(BOOL)
{
	UpdateCrossplotMenus();
	return TRUE;
}

-----

void CIMACDoc::UpdateCombobox(DWORD lineCount, DWORD* pLine, CLineSelectCombo *pCombo, int currentLine) 
{
	CString txt;
	pCombo->ResetContent();
	int currentIndex = 0;

	for (DWORD i=0; i<lineCount; i++) {
		txt.Format("%d", pLine[i]);
		if (pLine[i] == currentLine) currentIndex = i;
		int status = pCombo->AddString(txt);
		if (status == CB_ERR || status == CB_ERRSPACE) {
			AfxMessageBox("error creating inline/crossline combo");
			break;
		}
	}
	pCombo->SetCurSel(currentIndex);
}

Which is called from:
UpdateViews(...):

			// Update Inline combobox
			GetLiveInlineNumbers(lineCount, &pLine);
			UpdateCombobox(lineCount, pLine, pApp->m_cmbInline, m_nDisplayInline);

But please note that IMAC.h has:

	CLineSelectCombo *m_cmbInline;
	CLineSelectCombo *m_cmbXline;
        CLineSelectCombo *m_cmbUserline;

2021.03.25
I. Researching and implementing solution:                                
    
currentDir = 0x000000f5f96f9a90 "C:\\Sound-QI_Source\\SoundQI-Branch\\RM_Branch\\IMAC"

void CIMACDoc::UpdateCombobox(DWORD lineCount, DWORD* pLine, CLineSelectCombo *pCombo, int currentLine) 
{
	CString txt;
	pCombo->ResetContent();
	int currentIndex = 0;

	for (DWORD i=0; i<lineCount; i++) {
		txt.Format("%d", pLine[i]);
		if (pLine[i] == currentLine) currentIndex = i;
		int status = pCombo->AddString(txt);
		if (status == CB_ERR || status == CB_ERRSPACE) {
			AfxMessageBox("error creating inline/crossline combo");
			break;
		}
	}
	pCombo->SetCurSel(currentIndex);
}

-----

void CColorBarView::OnCbOpen() 
{
	FILE *pf;
	CString msg, fname;
	CString fileFilter = "Colorbar Files (*.cb)|*.cb|All Files (*.*)|*.*|";
	CCSIDoc* pDoc = GetDocument();

	CFileDialog fileDialog(TRUE, "cb", NULL, OFN_HIDEREADONLY|OFN_FILEMUSTEXIST, fileFilter, this);
	if (fileDialog.DoModal() == IDOK)
	{
		fname = fileDialog.GetPathName();
		if ((pf=fopen(fname, "r"))==NULL) {		
			msg.Format("Cannot open file %s", fname);
			AfxMessageBox(msg);
			return;
		}
		int i=0;
		int istat, red, grn, blu;
		while (!feof(pf)) {
			istat = fscanf(pf, "%d %d %d", &red, &grn, &blu);
			if (istat==3) {
				pDoc->m_colorbar[i++] = RGB(red, grn, blu);
			}
		}
		fclose(pf);
		pDoc->m_cbSize=i;
		m_colorbarIndex = -1;
		pDoc->SetForceRedraw(TRUE);

		Invalidate(FALSE);
	}	
}

-----

        int nRows = m_nameList.GetItemCount();

	for (int i = 0; i < m_pDoc->GetClassCount(); i++) {
            // ...
        }

        
-----

void CColorBarFrame::UpdateColorBarTemplateCombobox()
{
	m_wndToolBar.m_cmbColorTemplate.ResetContent();
	int currentIndex = 0;
	CString appDataDir = Utilities::GetAppDataDirectory();
	CString resourcesDirectory = appDataDir + "\\ColorBarTemplates";
	Utilities::GetAllFileNames(files, resourcesDirectory);

	for (int i = 0; i < files.GetCount(); i++) {
		int status = m_wndToolBar.m_cmbColorTemplate.AddString(files[i]);
		if (status == CB_ERR || status == CB_ERRSPACE) {
			AfxMessageBox("error creating color bar templates combo");
			break;
		}
	}
	m_wndToolBar.m_cmbColorTemplate.SetCurSel(currentIndex);
}

------

// Read the Segy data into memory for one segy line.
int CIMACDoc::LoadData()
{
	int i;
	int fileCount = GetFileCount();
	if (fileCount == 0) return 0;

#ifdef DEBUG
    clock_t start, finish, intervalStart;
	start = clock();
#endif

	BOOL bNewLoad = LoadProjectIndexes();
	if  (bNewLoad)  {
		CSegyIndex *pSegyIndex[NFILE];

		for (int i=0; i<fileCount; i++) {
			pSegyIndex[i] = GetSegyInPtr(i)->GetSegyIndexPtr();
		}
		CrossCheckIndexes(AfxGetMainWnd()->GetSafeHwnd(), pSegyIndex, fileCount);
	}

	// check if the requested line exists and is in range.
	if (GetInlineXlineMode() != eUSERLINE) {
		CSegyIndex *pSegyIndex = GetSegyInPtr(0)->GetSegyIndexPtr();
		if ( !pSegyIndex->LineExists(GetDisplayLine(), GetInlineXlineMode()) ) {
			CString txt, line;
			line = GetInlineXlineMode() == eINLINE ? "inline" : "crossline";
			txt.Format("There has been an error: The %s %d was not found in the file. The display inline and crossline will be reset.", line, GetDisplayLine());
			AfxMessageBox(txt);

			ResetDisplayLines();
		}
	}
	
	CModelessInfoDlg infoDlg;
	infoDlg.ShowMessage("Loading data...");

	// find the segy that has the latest start time, we'll use it for output.
	int segyToUseForOutput = GetSegyToUse();

	// If the line has changed then load appropriate data
	if (GetInlineXlineMode() != eUSERLINE) {
		for (i = 0; i < fileCount; i++) {
			CSegy *pSegy = GetSegyInPtr(i);
			if (pSegy->GetTraceCount() == 0 ||
				GetDisplayLine() != pSegy->GetCurrentLineNumber() ||
				GetInlineXlineMode() != pSegy->GetInlineXlineMode())
			{
				CString attrName = GetAttr(i);

				// skip loading if this attribute doesn't appear on any xplot.
				if (!IsAttributeInUse(attrName) && i != segyToUseForOutput) {
					// check if the attribute is needed for a virtual volume
					if (!IsAttributeInVirtualVolumeInUse(attrName)) {
						continue;
					}
				}
#ifdef DEBUG
                intervalStart = clock();
#endif
				infoDlg.AddString(attrName);
				pSegy->Reset();
				int ntrace = GetLiveTraceCount(GetDisplayLine(), GetInlineXlineMode());
				pSegy->Create(ntrace, pSegy->GetSegyIndexPtr()->GetSampleCount());
				if (pSegy->LoadIndexedLine(GetFile(i), GetDisplayLine(), 
					GetInLineMin(), GetInLineMax(), GetXLineMin(), GetXLineMax(), GetInlineXlineMode()) != ntrace) {
					CString msg;
					msg.Format("problem loading line %d from file %s", GetDisplayLine(), GetFile(i));
					AfxMessageBox(msg);
					return -1;
				}
				CheckDensityModeUpdateFlag(attrName);
#ifdef DEBUG
				TRACE("LoadData File=%s time=%f\n", GetFile(i), (double)(clock() - intervalStart) / CLOCKS_PER_SEC);
#endif
			}
		}

	} else {
		// load user line

		CPointArray* pData = GetCurrentUserLinePtr();
		if (pData == NULL) {
			AfxMessageBox("No Userline has been selected");
			return -1;
		}

		for (i=0; i<fileCount; i++) {
			CSegy* pSegy = GetSegyInPtr(i);
			if (!pSegy->isUserLineLoaded(pData)) {

				CString attrName = GetAttr(i);

				// skip loading if this attribute doesn't appear on any xplot.
				if (!IsAttributeInUse(attrName) && i != segyToUseForOutput) {
					// check if the attribute is needed for a virtual volume
					if (!IsAttributeInVirtualVolumeInUse(attrName)) {
						continue;
					}
				}

				infoDlg.AddString(attrName);
				pSegy->Reset();
				int ntrace = (int) pData->GetCount();
				pSegy->Create(ntrace, pSegy->GetSegyIndexPtr()->GetSampleCount());
				if (pSegy->LoadIndexedLine(GetFile(i), 0, GetInLineMin(), GetInLineMax(), GetXLineMin(), GetXLineMax(), GetInlineXlineMode(), pData) < 0) {
					return -1;
				}
				CheckDensityModeUpdateFlag(attrName);
			}
		}
	}

	LoadVirtualVolumes(&infoDlg, NULL);

	infoDlg.DestroyWindow();

#ifdef DEBUG
    intervalStart = clock();
#endif
	// Create the output volume (in memory) if it hasn't been done already.
	CSegy *pSegyOut = GetSegyOutPtr();
	int ntrace = pSegyOut->GetTraceCount();
	if (  GetDisplayLine()==0 || ntrace==0 || (ntrace>0 &&
		(GetDisplayLine() != pSegyOut->GetCurrentLineNumber() ||
		GetInlineXlineMode() != pSegyOut->GetInlineXlineMode() )))
	{

		*pSegyOut = GetSegyInPtr(segyToUseForOutput);  // invoke the = operator. Copy the data from the first segy.

		for (i=0; i<pSegyOut->GetTraceCount(); i++) {
			float *pData=pSegyOut->GetTraceDataPtr(i);
			for (int j=0; j<pSegyOut->GetSampleCount(); j++) {
				pData[j]=UNCLASSIFIED;
			}
		}
		ntrace = pSegyOut->GetTraceCount();
		SetReadyToCompute();
	}

    if (GetInlineXlineMode() == eUSERLINE) {
        pSegyOut->SetUserLinePtr(GetCurrentUserLinePtr());
        pSegyOut->SetUserLineSmoothedCoordinatePtr(GetCurrentUserLineSmoothedCoordinatePtr());
    } else {
        pSegyOut->SetUserLinePtr(NULL);
        pSegyOut->SetUserLineSmoothedCoordinatePtr(NULL);
    }

#ifdef DEBUG
    TRACE("Create output volume time=%f\n", (double)(clock() - intervalStart) / CLOCKS_PER_SEC);
#endif

	// loop through the list of wells and project any deviation data onto the current line.
	ProjectWellsToCurrentLine();

#ifdef DEBUG
	finish = clock();
	double duration = (double)(finish-start) / CLOCKS_PER_SEC;
	TRACE("LoadData Total time=%f\n", duration);
#endif

    // the view class takes care of inserting the select codes into the output volume.
    SetInitialSelect(TRUE);
	
    return ntrace;
}

-----

this->GetClassCount()
25

// Read the Segy data into memory for one segy line.
int CIMACDoc::LoadData()
{                        
    // ...                        
    // the view class takes care of inserting the select codes into the output volume.
    SetInitialSelect(TRUE);
	
    return ntrace;
}

--------------------------------------------------------------------------------
                        
Didn`t actually send this email because I figured it out later on by putting the UpdateCombobox inside the CColorBarFrame instead of CColorBarView:


From: Roger Moore <roger@sound-qi.com> 
Sent: March 26, 2021 10:45 AM
To: Roger Moore <roger@sound-qi.com>
Subject: getting combobox when building from C++ for a view for color bar templates

Brenda & Kevin, please note that I am trying to create a combobox on the color bar view.

When I check this in the IMAC mainframe, this is what I see:

void CIMACDoc::UpdateCombobox(DWORD lineCount, DWORD* pLine, CLineSelectCombo *pCombo, int currentLine) 
{
        CString txt;
        pCombo->ResetContent();
        int currentIndex = 0;

        for (DWORD i=0; i<lineCount; i++) {
                 txt.Format("%d", pLine[i]);
                if (pLine[i] == currentLine) currentIndex = i;
                 int status = pCombo->AddString(txt);
                if (status == CB_ERR || status == CB_ERRSPACE) {
                        AfxMessageBox("error creating inline/crossline combo");
                         break;
                 }
        }
        pCombo->SetCurSel(currentIndex);
}

Which then calls the above function from:

UpdateCombobox(lineCount, pLine, pApp->m_cmbInline, m_nDisplayInline);

In my case I have written:

void CColorBarView::UpdateCombobox(CComboBox* pCombo)
{
        pCombo->ResetContent();
        int currentIndex = 0;
        CString getTemplates;
        CStringArray files;
        TCHAR currentDir[MAX_PATH];
        Utilities::GetCurrentDir(currentDir);
        CString workingDirectory(currentDir);
        Utilities::GetAllFileNames(files, workingDirectory);
        
        for (int i = 0; i < files.GetCount(); i++) {
                 int status = pCombo->AddString(files[i]);
                if (status == CB_ERR || status == CB_ERRSPACE) {
                     AfxMessageBox("error creating color bar templates combo");
                         break;
                 }
        }
        pCombo->SetCurSel(currentIndex);
}

Where I am trying to call this function from the same class:

void CColorBarView::OnInitialUpdate()
{
        m_intensity = 1.0;
        m_lbuttondown = FALSE;
        m_palletIndex = -2;      // nothing selected
        m_colorbarIndex = -1;
        m_colorbarIndexMouseMove = -1;
        UpdateCombobox();
        pApp = (CIMACApp*)AfxGetApp();
}

What is unclear to me is, how can I get a reference to the CCombobox in CColorBarFrame to pass to the above function as a parameter.  Here is the full source code for your reference:



Do you have any suggestions? TIA.

Feel free to let me know if you have any further questions, concerns or issues.

All the best,

Roger

2021.03.26
I. Researching and implementing solution:                                
                        
-		files	{m_pData=0x000001aadc3b7290 "Baha.txt" m_nSize=1 m_nMaxSize=1 ...}	CStringArray & {mfc140d.dll!CStringArray}
+		[CStringArray]	{m_pData=0x000001aadc3b7290 "Baha.txt" m_nSize=1 m_nMaxSize=1 ...}	mfc140d.dll!CStringArray
+		CObject	{...}	CObject
+		m_pData	0x000001aadc3b7290 "Baha.txt"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>> *
		m_nSize	1	__int64
		m_nMaxSize	1	__int64
		m_nGrowBy	0	__int64

        // skip . and .. files
        if (!finder.IsDots())
        {
            files.Add(finder.GetFileName());
        }

-----

			CStdioFile cFile;
			CFile cFileOutput;
			cFile.Open(file, CFile::modeRead);
                        
cFile = {hFile=0xffffffffffffffff name="C:\\Sound-QI_Source\\SoundQI-Branch\\RM_Branch\\IMAC\\Baha.txt"}
                        
cFile = {hFile=0x000000000000051c name="C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Baha.txt"}

C:\Users\moorer\AppData\Roaming\Sound QI\QI-Pro\ColorBarTemplates\Baha.txt                        

cFile = {hFile=0xffffffffffffffff name="C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Baha.txt"}                        

C:\Users\moorer\AppData\Roaming\Sound QI\QI-Pro\ColorBarTemplates\Baha.txt                                                

void CIMACDoc::CreateColorBarTemplateFiles()
{
	CStringArray files;
	CString appDataDir = Utilities::GetAppDataDirectory();
	CString resourcesDirectory = appDataDir + "\\ColorBarTemplates";
	Utilities::GetAllFileNames(files, resourcesDirectory, ".txt");
	UINT iCount;

	for (int i = 0; i < files.GetCount(); i++) {
		CString file = files[i];
		int extensionPos = file.Find(".");
		CString extension = file.Right(extensionPos);
		CString rootName = file.Left(extensionPos);

		if (extension == ".txt") {
			const int iBuffSiz = 500;
			char chBuffer[iBuffSiz];
			memset(chBuffer, 0, sizeof(chBuffer));
			CStdioFile cFile;
			CFile cFileOutput;
			CString inputFilePath = resourcesDirectory + "\\" + file;
			cFile.Open(inputFilePath, CFile::modeRead);
			CString fileOutput = resourcesDirectory + "\\" + rootName + ".cb";
			cFileOutput.Open(fileOutput, CFile::modeCreate | CFile::modeWrite); // cFileOutput.Open(fileOutput, CFile::modeCreate | CFile::modeWrite | CFile::typeText);
			
			// Get number of lines in the source file
			UINT templateSrcLineCount = 0;
			CString row;
			while (cFile.ReadString(row))
			{
				templateSrcLineCount++;
			}
			const UINT linesToSkip = templateSrcLineCount / this->GetClassCount();
			UINT lineCounter = 0;
			cFileOutput.SeekToBegin();

			// Write template to *.cb file based on number of classes
			while ((iCount = cFile.Read(chBuffer, iBuffSiz)) > 0) {
				try {
					if (lineCounter % linesToSkip == 0) {
						cFileOutput.Write(chBuffer, iCount);
					}
				}
				catch (CFileException& ex) {
					TCHAR   szCause[255];
					ex.GetErrorMessage(szCause, 255);
					AfxMessageBox(szCause);
				}
			}
			cFileOutput.Close();
			cFile.Close();
		}
	}
}

-----

void CIMACDoc::CreateColorBarTemplateFiles()
{
	CStringArray files;
	CString appDataDir = Utilities::GetAppDataDirectory();
	CString resourcesDirectory = appDataDir + "\\ColorBarTemplates";
	Utilities::GetAllFileNames(files, resourcesDirectory, ".txt");
	UINT iCount;

	for (int i = 0; i < files.GetCount(); i++) {
		CString file(files[i]);
		const int extensionPos = file.Find(".");
		CString extension = file.Right(extensionPos);
		CString rootName = file.Left(extensionPos);

		if (extension == ".txt" || extension == "txt") {
			CStringArray fileContents;
			const int iBuffSiz = 500;
			char chBuffer[iBuffSiz];
			memset(chBuffer, 0, sizeof(chBuffer));
			CStdioFile cFile;
			CFile cFileOutput;
			CString inputFilePath = resourcesDirectory + "\\" + file;
			cFile.Open(inputFilePath, CFile::modeRead);
			CString fileOutput = resourcesDirectory + "\\" + rootName + ".cb";
			cFileOutput.Open(fileOutput, CFile::modeCreate | CFile::modeWrite); // cFileOutput.Open(fileOutput, CFile::modeCreate | CFile::modeWrite | CFile::typeText);
			
			// Get number of lines in the source file
			UINT templateSrcLineCount = 0;
			CString row;
			try {
				while (cFile.ReadString(row))
				{
					templateSrcLineCount++;
					fileContents.Add(row + "\n");
				}
			}
			catch (CFileException& ex) {
				TCHAR   szCause[255];
				ex.GetErrorMessage(szCause, 255);
				AfxMessageBox(szCause);
			}
			const UINT linesToSkip = templateSrcLineCount / this->GetClassCount();
			cFileOutput.SeekToBegin();

			// Write template to *.cb file based on number of classes
			try {
				for (int j = 0; j < fileContents.GetCount(); j++) {
					if (j % linesToSkip == 0) {
						cFileOutput.Write(fileContents[j], fileContents[j].GetLength());
					}
				}
			}
			catch (CFileException& ex) {
				TCHAR   szCause[255];
				ex.GetErrorMessage(szCause, 255);
				AfxMessageBox(szCause);
			}
			cFileOutput.Close();
			cFile.Close();
		}
	}
}

2021.03.29
I. Researching and implementing solution:                                
1) 
                        
+		this	0x000001f29bff6d40 {m_tempPathName="C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj" ...}	CIMACDoc *

                        
{hFile=0x000000000000032c name="C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Baha.cb"}
    [CFile]: {hFile=0x000000000000032c name="C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Baha.cb"}
    CObject: {...}
    m_hFile: 0x000000000000032c
    m_bCloseOnDelete: 1
    m_strFileName: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Baha.cb"
    m_pTM: 0x0000000000000000 <NULL>

-----

CString path = pDoc->GetProjectPath();

CString CIMACDoc::GetProjectName() 
{
	CString projectName = m_strPathName.Mid(m_strPathName.ReverseFind('\\') + 1);
	return projectName;
}

                        
	  if (!(DirectoryExists(temp))) 
	    if (!(DirectoryCreateDirectory(temp,NULL))) // attempt to create
	      {
		temp.Format("Create directory \"%s\\%d\" faild",path,p);
		AfxMessageBox(temp,MB_ICONSTOP); 
		return;
	      }
	}

if (!(CreateDirectory(temp,NULL))) // attempt to create

_lpszPathName = 0x000000f80d6fd2f0 "Z:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj"

            
m_tempPathName.Mid(m_strPathName.ReverseFind('\\') + 1)

"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj"

colorBarTemplateDirectory
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj"

            
	// create new from resource
	if (!pFrame->LoadFrame(m_nIDResource,
			WS_OVERLAPPEDWINDOW | FWS_ADDTOTITLE,   // default frame styles
			NULL, &context))

colorBarTemplateDirectory
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj"

--------------------------------------------------------------------------------
2) See https://flylib.com/books/en/4.348.1.75/1/

    m_il.Create (IDB_IMAGE, 16, 1, RGB (255, 0, 255));
    m_wndCBEx.SetImageList (&m_il);
    
    for (int i=0; i<5; i++) {
            CString string;
            string.Format (_T ("Item %d"), i);
            COMBOBOXEXITEM cbei;
            cbei.mask = CBEIF_IMAGE ¦ CBEIF_SELECTEDIMAGE ¦ CBEIF_TEXT;
            cbei.iItem = i;
            cbei.pszText = (LPTSTR) (LPCTSTR) string;
            cbei.iImage = 0;
            cbei.iSelectedImage = 0;
            m_wndCBEx.InsertItem (&cbei);
    }             

2021.03.30
I. Researching and implementing solution:                                
    
Severity	Code	Description	Project	File	Line	Suppression State
Error (active)	E0020	identifier "CMDIChildWndEx" is undefined	PathListApp	C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\VC\Tools\MSVC\14.28.29333\atlmfc\include\afxmdiframewndex.h	202	

CColorArray m_colorList;

m_lstCutoffLines.m_colorComboMap.SetAt(COL_CLASS_ABOVE_IN, &m_colorList);

m_lstCutoffLines.InsertColumn(COL_CLASS_ABOVE_IN,"Class Above/In",	LVCFMT_LEFT, rItem.Width()*17/100);

m_lstCutoffLines.SetItem(index, COL_CLASS_ABOVE_IN, LVIF_TEXT, _itoa(pCutoff.m_nClassAbove, ibuf, 10), 0, 0, 0, 0);

m_lstCutoffLines.SetSubitemColor(COL_CLASS_ABOVE_IN, i, pColorbar[i]);

COLORREF color = m_colorList[pCutoff.m_nClassAbove];
m_lstCutoffLines.SetSubitemColor(COL_CLASS_ABOVE_IN, index, color);

m_lstCutoffLines.SetTextCol(COL_CLASS_ABOVE_IN);

newCutoff.m_nClassAbove = atoi(m_lstCutoffLines.GetItemText(i, COL_CLASS_ABOVE_IN));

void CEditListCtrl::OnNMCustomdraw(NMHDR *pNMHDR, LRESULT *pResult)
{
	*pResult = CDRF_DODEFAULT;
	NMLVCUSTOMDRAW* pCD = (NMLVCUSTOMDRAW*)pNMHDR;
	int row = (int) pCD->nmcd.dwItemSpec;
 
	if(row < 0 || row >= GetItemCount()) {
		if(pCD->nmcd.dwDrawStage == CDDS_PREPAINT) {
			*pResult = CDRF_NOTIFYSUBITEMDRAW;
		}
		return;
	}
 
	switch(pCD->nmcd.dwDrawStage)
	{
	case  CDDS_PREPAINT:  // First stage (for the whole control)
	{
		*pResult = CDRF_NOTIFYITEMDRAW|CDRF_NOTIFYPOSTPAINT;
		break;
	}
	case CDDS_ITEMPREPAINT:
		*pResult = CDRF_NOTIFYSUBITEMDRAW|CDRF_NOTIFYPOSTPAINT;
		break;
 
	case CDDS_ITEMPREPAINT|CDDS_SUBITEM:
	{
		// alternate row bg color
		DWORD subitemColor = (row % 2  == 0) ? COLOR_EVEN : COLOR_ODD;
		pCD->clrTextBk = subitemColor;
 
		// color selected row
		if (IsSelected(row)) {
			pCD->clrTextBk = GetSysColor(COLOR_HIGHLIGHT);// COLOR_SELECTED;
			pCD->clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
		}
 
		// handle the color of a subitem
		if (pCD->iSubItem >= m_coloredSubitemLow && pCD->iSubItem <= m_coloredSubitemHi && m_arrColors[pCD->iSubItem][row] != COLOR_DEFAULT) {
			if (row < m_arrColors[pCD->iSubItem].GetCount()) {
				if (m_coloredTexMode) {
					if (!IsSelected(row)) {
						DWORD highlightColor = m_arrColors[pCD->iSubItem][row];
						pCD->clrText = m_arrColors[pCD->iSubItem][row];
					}
					else {
						// if the row is selected, then brighten up the color.
						DWORD highlightColor = m_arrColors[pCD->iSubItem][row];
						DWORD red = GetRValue(highlightColor);
						DWORD green = GetGValue(highlightColor);
						DWORD blue = GetBValue(highlightColor);
						red += (255 - red) / 2;
						green += (255 - green) / 2;
						blue += (255 - blue) / 2;
						highlightColor = RGB(red, green, blue);
						pCD->clrText = highlightColor;
					}
				}
				else {
					CDC* hDc = GetDC();
					CRect rect;
					GetSubItemRect(row, pCD->iSubItem, LVIR_LABEL, rect);
					COLORREF crOldTextColor = hDc->GetTextColor();
					COLORREF crColor = m_arrColors[pCD->iSubItem][row];
					COLORREF crText = GetSysColor(COLOR_WINDOWTEXT);
					CRect rBlockRect(rect);
					CRect rTextRect(rBlockRect);
					CBrush brFrameBrush;
					int iBoxWidth = 0;
					CString strItem = this->GetItemText(row, pCD->iSubItem);
					iBoxWidth = (rBlockRect.Width() / 2);				// Get 1/2 Of Item Area
					brFrameBrush.CreateStockObject(BLACK_PEN);			// Create Black Brush
					hDc->SetTextColor(crText);					// Set Text Color
					hDc->SetBkColor(subitemColor);					// Set BG Color
					hDc->FillSolidRect(&rBlockRect, subitemColor);	// Erase Item
 
					//	Calculate Text Area...
					rTextRect.left += (iBoxWidth + 3);					// Set Start Of Text
					rTextRect.top += 2;										// Offset A Bit
 
					//	Calculate Color Block Area..
					rBlockRect.DeflateRect(CSize(2, 2));				// Reduce Color Block Size
					if (!strItem.IsEmpty()) rBlockRect.right -= iBoxWidth;						// Set Width Of Color Block
 
					//	Draw Color Text And Block...
					int iaTabStops[1] = { 50 };
 
					hDc->SelectObject(GetFont());
					hDc->TabbedTextOut(rTextRect.left,
						rTextRect.top, strItem, (int)_tcslen(strItem), 1,
						iaTabStops, 0);							// Draw Color Name
 
					if (crColor == NOCOLOR) {
						// Draw NOCOLOR warning
						brFrameBrush.CreateStockObject(WHITE_PEN);			// Create White Brush
						const COLORREF whiteColor = RGB(255, 255, 255);
						hDc->SetBkColor(whiteColor);					// Set BG Color
						hDc->FillSolidRect(&rBlockRect, whiteColor);	// Erase Item
						hDc->FrameRect(&rBlockRect, &brFrameBrush);	// Draw Frame
 
						COLORREF redColor = RGB(255, 0, 0);
						CPen* pRedPen = new CPen(PS_SOLID, 1, redColor);
						hDc->SelectObject(pRedPen);
						hDc->MoveTo(rect.left, rect.top);
						hDc->LineTo(rect.right, rect.bottom);
						 if (pRedPen != NULL) delete pRedPen;
					}
					else {
						hDc->FillSolidRect(&rBlockRect, crColor);	// Draw Color
						hDc->FrameRect(&rBlockRect, &brFrameBrush);	// Draw Frame
					}
									
					ReleaseDC(hDc);
				}
			}
		}
 
		if (m_boldTextMode) {
			if (row < m_arrBold.GetSize()) {
				BOOL isBold = m_arrBold[row];
				if (isBold) {
					::SelectObject(pCD->nmcd.hdc, m_fontBold.GetSafeHandle());
					*pResult = CDRF_NEWFONT;
				}
			}
		}
		*pResult = CDRF_NOTIFYSUBITEMDRAW | CDRF_NOTIFYPOSTPAINT;
		break;
	}
	case CDDS_ITEMPOSTPAINT | CDDS_SUBITEM: // Stage four (called for each subitem of the focused item)
	{
		DWORD subitemColor = (row % 2 == 0) ? COLOR_EVEN : COLOR_ODD;
		// handle the color of a subitem
		if (pCD->iSubItem >= m_coloredSubitemLow && pCD->iSubItem <= m_coloredSubitemHi && m_arrColors[pCD->iSubItem][row] != COLOR_DEFAULT) {
			if (row < m_arrColors[pCD->iSubItem].GetCount()) {
				if (m_coloredTexMode) {
					if (!IsSelected(row)) {
						DWORD highlightColor = m_arrColors[pCD->iSubItem][row];
						pCD->clrText = m_arrColors[pCD->iSubItem][row];
					}
					else {
						// if the row is selected, then brighten up the color.
						DWORD highlightColor = m_arrColors[pCD->iSubItem][row];
						DWORD red = GetRValue(highlightColor);
						DWORD green = GetGValue(highlightColor);
						DWORD blue = GetBValue(highlightColor);
						red += (255 - red) / 2;
						green += (255 - green) / 2;
						blue += (255 - blue) / 2;
						highlightColor = RGB(red, green, blue);
						pCD->clrText = highlightColor;
					}
				}
				else {
					CDC* hDc = GetDC();
					CRect rect;
					GetSubItemRect(row, pCD->iSubItem, LVIR_LABEL, rect);
					COLORREF crOldTextColor = hDc->GetTextColor();
					COLORREF crColor = m_arrColors[pCD->iSubItem][row];
					COLORREF crText = GetSysColor(COLOR_WINDOWTEXT);
					CRect rBlockRect(rect);
					CRect rTextRect(rBlockRect);
					CBrush brFrameBrush;
					int iBoxWidth = 0;
					CString strItem = this->GetItemText(row, pCD->iSubItem);
					iBoxWidth = (rBlockRect.Width() / 2);				// Get 1/2 Of Item Area
					brFrameBrush.CreateStockObject(BLACK_PEN);			// Create Black Brush
					hDc->SetTextColor(crText);					// Set Text Color
					hDc->SetBkColor(subitemColor);					// Set BG Color
					hDc->FillSolidRect(&rBlockRect, subitemColor);	// Erase Item
 
					//	Calculate Text Area...
					rTextRect.left += (iBoxWidth + 3);					// Set Start Of Text
					rTextRect.top += 2;										// Offset A Bit
 
					//	Calculate Color Block Area..
					rBlockRect.DeflateRect(CSize(2, 2));				// Reduce Color Block Size
					if (!strItem.IsEmpty()) rBlockRect.right -= iBoxWidth;						// Set Width Of Color Block
 
					//	Draw Color Text And Block...
					int iaTabStops[1] = { 50 };
					hDc->SelectObject(GetFont());
					hDc->TabbedTextOut(rTextRect.left,
						rTextRect.top, strItem, (int)_tcslen(strItem), 1,
						iaTabStops, 0);							// Draw Color Name
 
					// Draw NOCOLOR warning
					if (crColor == NOCOLOR) {
						brFrameBrush.CreateStockObject(WHITE_PEN);			// Create White Brush
						const COLORREF whiteColor = RGB(255, 255, 255);
						hDc->SetBkColor(whiteColor);					// Set BG Color
						hDc->FillSolidRect(&rBlockRect, whiteColor);	// Erase Item
						hDc->FrameRect(&rBlockRect, &brFrameBrush);	// Draw Frame
 
						COLORREF redColor = RGB(255, 0, 0);
						CPen* pRedPen = new CPen(PS_SOLID, 1, redColor);
						hDc->SelectObject(pRedPen);
						hDc->MoveTo(rect.left, rect.top);
						hDc->LineTo(rect.right, rect.bottom);
						if (pRedPen != NULL) delete pRedPen;
					}
					else {
						hDc->FillSolidRect(&rBlockRect, crColor);	// Draw Color
						hDc->FrameRect(&rBlockRect, &brFrameBrush);	// Draw Frame					
					}
					ReleaseDC(hDc);
				}
			}
		}
		if (m_checkboxCol >= 0 && pCD->iSubItem == m_checkboxCol) {
			if (row < GetItemCount())
			{
				CDC* hDc = GetDC();
				CRect rect;
				GetSubItemRect(row, pCD->iSubItem, LVIR_LABEL, rect);
 
				const int boxHeight = 13;
				const int boxWidth = 13;
				int left = rect.left + (rect.right - rect.left) / 2 - boxWidth / 2;
				int top = rect.top + (rect.bottom - rect.top) / 2 - boxHeight / 2;
 
				CBrush blkBrush;
				blkBrush.CreateStockObject(BLACK_PEN);			// Create Black Brush
 
				CRect checkBoxRect(left, top, left + boxWidth, top + boxHeight);
				hDc->FillSolidRect(checkBoxRect, RGB(255, 255, 255));	// Draw Color
				hDc->FrameRect(&checkBoxRect, &blkBrush);	// Draw Frame					
				blkBrush.Detach();
 
				if (m_checkBoxState[row]) {
					CPen blkPen;
					blkPen.CreatePen(PS_SOLID, 2, GetSysColor(COLOR_GRAYTEXT));
					hDc->SelectObject(blkPen);
					hDc->MoveTo(left + 2, top + 6);
					hDc->LineTo(left + 5, top + 10);
					hDc->LineTo(left + 10, top + 2);
					blkPen.Detach();
				}
 
				ReleaseDC(hDc);
			}
		}
		break;
	}
	case CDDS_POSTPAINT: // Stage four 
	{
		// Indicate the Clipboard item
		CRect itemRect;
		GetItemRect(m_iClipboardItem, &itemRect, LVIR_BOUNDS);
		CDC* hDc = GetDC();
		hDc->FrameRect(itemRect, &CBrush(COLOR_SELECTED));
		ReleaseDC(hDc);
		break;
	}
	default:// it wasn`t a notification that was interesting to us.
	{
		*pResult = CDRF_DODEFAULT;
		break;
	}
	}
}

m_colorComboWnd.Create(WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL | CBS_HASSTRINGS | CBS_OWNERDRAWFIXED, rect, this, 0);

m_subitem = lvhit.iSubItem;
m_item = item;
CStringArray* pComboStrings = NULL;
CColorArray* pComboColors = NULL;
if (!m_comboMap.Lookup(m_subitem, pComboStrings) && !m_colorComboMap.Lookup(m_subitem, pComboColors)) {
	EditLabel(item);
}
else if (m_colorComboMap.Lookup(m_subitem, pComboColors)) {
	CRect rect;
	GetSubItemRect(m_item, m_subitem, LVIR_BOUNDS, rect);
	m_colorComboWnd.Create(WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL | CBS_HASSTRINGS | CBS_OWNERDRAWFIXED, rect, this, 0);
        
	int maxWidth = rect.Width();
	for (int i = 0; i < pComboColors->GetSize(); i++) {
		COLORREF color = pComboColors->GetAt(i);
		CString str;
		str.Format("%d", i);
		m_colorComboWnd.AddColor(str, color);
	}
	CString strItem = this->GetItemText(m_item, m_subitem);
	int ix = m_colorComboWnd.FindStringExact(-1, strItem);
	if (ix == CB_ERR) ix = 0;
	m_colorComboWnd.SetCurSel(ix);
	m_colorComboWnd.m_item = m_item;
	m_colorComboWnd.m_subitem = m_subitem;
	m_colorComboWnd.SetFont(GetFont());
	m_colorComboWnd.ShowDropDown(TRUE);


void CEditListCtrl::OnPaint()
        {
	    // first time set the extended styles for this control.
	if (!m_bSetExtendedStyle) {
		SetExtendedStyle(GetExtendedStyle()|LVS_EX_GRIDLINES);
		m_bSetExtendedStyle = TRUE;
	}
            
	CStringArray* pComboStrings = NULL;
	    CColorArray* pComboColors = NULL;
	if (m_subitem && (!m_comboMap.Lookup(m_subitem, pComboStrings)) && (!m_colorComboMap.Lookup(m_subitem, pComboColors))) {
		CRect rect;
		CRect editrect;
		GetSubItemRect(m_item,m_subitem,LVIR_LABEL, rect);
		if (m_editWnd.m_hWnd == NULL) {
			TRACE("m_editWnd.m_hWnd == NULL\n");
			return;
		}
		m_editWnd.GetWindowRect(editrect);
		ScreenToClient(editrect);
		// Clean up the original text to the right of the edit control
		if (editrect.right < rect.right) {
			rect.left = editrect.right;
			ValidateRect(rect);
			CDC* hDc = GetDC();
			hDc->FillRect(rect,&CBrush(::GetSysColor(COLOR_WINDOW)));
			ReleaseDC(hDc);
		}
		//block filling redraw of leftmost item (caused by FillRect)
		GetItemRect(m_item, rect,LVIR_LABEL );
		ValidateRect(rect);
	}

	if (m_subitem >= m_coloredSubitemLow && m_subitem <= m_coloredSubitemHi && m_item < m_colorCount && m_arrColors[m_subitem][m_item] != COLOR_DEFAULT) {
		COLORREF itemColor = m_arrColors[m_subitem][m_item];
		CRect rect;
		GetSubItemRect(m_item, m_subitem, LVIR_LABEL, rect);
		CDC* hDc = GetDC();
		hDc->FillRect(rect, &CBrush(itemColor));
		ReleaseDC(hDc);
	}
            
	CListCtrl::OnPaint();
        }

2021.04.05
        I. Researching and implementing solution:

// color combo
class CColorCombo : public CComboBox
        {
	    DECLARE_DYNAMIC(CColorCombo)

public:
	    int m_x;
	    int m_y;
	    int m_currSelect;

	// the following variables for updating the parent list control.
	    CListCtrl* pParent;
	    int m_item;
	    int m_subitem;

	CColorCombo();
	    virtual ~CColorCombo();

protected:
	    DECLARE_MESSAGE_MAP()
	    virtual void PreSubclassWindow();
	    afx_msg void OnWindowPosChanging(WINDOWPOS* lpwndpos);
	    afx_msg void OnCbnKillfocus();
	    afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);

public:
	    int	AddColor(LPCTSTR cpColor, COLORREF crColor);
	    COLORREF GetSelectedColorValue(void);
	    LPCTSTR	GetSelectedColorName(void);
	    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);



private:
	    TCHAR m_cColorName[32];		// Name Of Selected Color

};

	CColorCombo m_colorComboWnd;
        
-----
        
-		cbei	{mask=1 iItem=0 pszText=0x000001a7acdb5b78 "Baha.cb" ...}	tagCOMBOBOXEXITEMA
	mask	1	unsigned int
	iItem	0	__int64
        +		pszText	0x000001a7acdb5b78 "Baha.cb"	char *
	cchTextMax	0	int
	iImage	0	int
	iSelectedImage	0	int
	iOverlay	0	int
	iIndent	0	int
	lParam	0	__int64

        
2021.04.06
I. Researching and implementing solution:

-		m_wndToolBar.m_cmbColorTemplate	{hWnd=0x000000000009146e {unused=??? }}	CColorBarTemplateCombo
        +		CComboBoxEx	{hWnd=0x000000000009146e {unused=??? }}	CComboBoxEx
	m_currSelect	-842150451	int
        +		m_colorBarTemplateFiles	{m_pData=0x00000162eb31c710 "Baha.cb" m_nSize=13 m_nMaxSize=13 ...}	CStringArray
        +		m_colorBarTemplateImageFileNames	{m_pData=0x0000000000000000 <NULL> m_nSize=0 m_nMaxSize=0 ...}	CStringArray
        +		m_colorBarTemplateImages	{m_hImageList=0x0000000000000000 <NULL> }	CImageList
        +		m_cColorName	0x00000162eb337b08 "ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ..."	char[32]

-----

mfc debug assertion failed afxcmn2.inl CComboBox AddString UNUSED_ALWAYS              

_AFXCMN_INLINE int CComboBoxEx::AddString(_In_z_ LPCTSTR lpszString)
	{ UNUSED_ALWAYS(lpszString); ASSERT(FALSE); return CB_ERR;}

See https://stackoverflow.com/questions/7757931/why-cant-i-add-a-string-to-a-combo-box

int CComboBoxEx::InsertItem(const COMBOBOXEXITEM* pCBItem)
        {
	    ASSERT(::IsWindow(m_hWnd));
	    ASSERT(pCBItem != NULL);
	    ASSERT(AfxIsValidAddress(pCBItem, sizeof(COMBOBOXEXITEM), FALSE));

	return (int) ::SendMessage(m_hWnd, CBEM_INSERTITEM, 0, (LPARAM) pCBItem);
        }

-----

inputFilePath
        "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Baha.cb"
        ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Baha.cb"

sFrom = "208\t0\t0\n"

-----

		int red = atoi(saItems[0]);
	int grn = atoi(saItems[1]);
	int blu = atoi(saItems[2]);
	COLORREF color = RGB(red, grn, blu);

	for (int i = 0; i < m_colorBarTemplateFiles.GetCount(); i++) {
		CString colorBarTemplateFile = m_colorBarTemplateFiles[i];
		CStringArray fileContents;
		CStdioFile cFile;
		CString inputFilePath = colorBarTemplateDirectory + "\\" + colorBarTemplateFile;
		cFile.Open(inputFilePath, CFile::modeRead);
		CString row;

		while (cFile.ReadString(row))
		{
		    fileContents.Add(row + "\n");
		}
		const CString sFrom = fileContents[0];

		int j = 0;
		CStringArray saItems;
b
		int nTokenPos = 0;
		CString strToken = sFrom.Tokenize(_T("\t"), nTokenPos);

		while (!strToken.IsEmpty())
		{
		    saItems.Add(strToken);
		    strToken = sFrom.Tokenize(_T("\t"), nTokenPos);
		    nTokenPos += strToken.GetLength();
		}

		int red = atoi(saItems[0]);
		int grn = atoi(saItems[1]);
		int blu = atoi(saItems[2]);
		COLORREF color = RGB(red, grn, blu);
		int status = m_wndToolBar.m_cmbColorTemplate.AddString(colorBarTemplateFile);
		if (status == CB_ERR || status == CB_ERRSPACE) {
			AfxMessageBox("Error creating color bar templates combo");
			break;
		}		
		//m_wndToolBar.m_cmbColorTemplate.AddColor("", color);
	}

				m_colorComboWnd.Create(WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL | CBS_HASSTRINGS | CBS_OWNERDRAWFIXED, rect, this, 0);

Debug Assert Failed: winctrl1.cpp line 265:              
        winctrl1.cpp:              
        void CComboBox::MeasureItem(LPMEASUREITEMSTRUCT)
	{ ASSERT(FALSE); }              
        
-----

iItem = 0:

void CColorBarTemplateCombo::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
        {
	    ASSERT(lpDrawItemStruct->CtlType == ODT_COMBOBOX);

	int iItem = lpDrawItemStruct->itemID;
            // ...
	    {														// Set Standard Attributes
		                                                                                                        dc.SetTextColor(crText);					// Set Text Color
		                                                                                                        dc.SetBkColor(crNormal);					// Set BG Color
		                                                                                                        dc.FillSolidRect(&rBlockRect, crNormal);	// Erase Item
	     }              

Where:        
	    crNormal	16777215	unsigned long
	    crText	0	unsigned long

COLORREF	crNormal = GetSysColor(COLOR_WINDOW);
            COLORREF crText = GetSysColor(COLOR_WINDOWTEXT);


WINUSERAPI
            DWORD
            WINAPI
            GetSysColor(
                _In_ int nIndex);

-----

This is what I added to draw a red line through an undefined colour in the CClassNameDlg "Edit Class Names":

		if (crColor == NOCOLOR) {
			// Draw NOCOLOR warning
			brFrameBrush.CreateStockObject(WHITE_PEN);			// Create White Brush
			const COLORREF whiteColor = RGB(255, 255, 255);
			dc.SetBkColor(whiteColor);					// Set BG Color
			dc.FillSolidRect(&rBlockRect, whiteColor);	// Erase Item
			dc.FrameRect(&rBlockRect, &brFrameBrush);	// Draw Frame

			COLORREF redColor = RGB(255, 0, 0);
			CPen* pRedPen = new CPen(PS_SOLID, 1, redColor);
			dc.SelectObject(pRedPen);
			dc.MoveTo(rBlockRect.left, rBlockRect.top);
			dc.LineTo(rBlockRect.right, rBlockRect.bottom);
			if (pRedPen != NULL) delete pRedPen;
		}    
		else {
			dc.FillSolidRect(&rBlockRect, crColor);	// Draw Color
			dc.FrameRect(&rBlockRect, &brFrameBrush);	// Draw Frame
		}


Where:

    crColor = 0            

rBlockRect
{LT(2, 22) RB(57, 38)  [55 x 16]}
    tagRECT: {LT(2, 22) RB(57, 38)  [55 x 16]}

iBoxWidth = 57

--------------------------------------------------------------------------------

QI-Pro.exe has triggered a breakpoint.

        if (_CRT_ASSERT == nRptType && _InterlockedIncrement(&_crtAssertBusy) > 0)
        {
            /* use only 'safe' functions -- must not assert in here! */

            _ERRCHECK(_itow_s(nLine, szLineMessage, DBGRPT_MAX_MSG, 10));

            OutputDebugStringW(L"Second Chance Assertion Failed: File ");
            OutputDebugStringW(szFile ? szFile : L"<file unknown>");
            OutputDebugStringW(L", Line ");
            OutputDebugStringW(szLineMessage);
            OutputDebugStringW(L"\n");

            _CrtDbgBreak();
            retval = -1;
            __leave;
        }            

CString inputFilePath = colorBarTemplateDirectory + "\\" + colorBarTemplateFile;

inputFilePath
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Baha.cb"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Baha.cb"

sFrom = "243\t56\t2\n"

saItems
{m_pData=0x00000291650ebd30 "243" m_nSize=2 m_nMaxSize=5 ...}
    [CStringArray]: {m_pData=0x00000291650ebd30 "243" m_nSize=2 m_nMaxSize=5 ...}
    CObject: {...}
    m_pData: 0x00000291650ebd30 "243"
    m_nSize: 2
    m_nMaxSize: 5
    m_nGrowBy: 0

-----

Utilities::CreateColorBarTemplateFiles(m_tempPathName, this->GetClassCount());

2021.04.07
I. Researching and implementing solution:            
            
Severity	Code	Description	Project	File	Line	Suppression State
Warning	C4477	'sprintf' : format string '%s' requires an argument of type 'char *', but variadic argument 1 has type 'CString'	IMAC	c:\sound-qi_source\soundqi-branch\rm_branch\imac\colorbarframe.cpp	476	

-> Solution: Use strcpy instead            

--------------------------------------------------------------------------------

"Save this Color Set"            

void CColorBarView::OnCbAddNewColorbarTemplate()
{
	CString msg;
	CString fname = "Original.cb";
	CIMACDoc* pDoc = GetDocument();

	// Get color bar templates for this project directory
	const CString appDataDir = Utilities::GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "\\ColorBarTemplates";
	const CString colorBarTemplateDirectory = resourcesDirectory + "\\" + pDoc->GetProjectName();
	const CString filePath = colorBarTemplateDirectory + "\\" + fname;
	pDoc->ColorBarExport(filePath);
}

fname
"C:\\Users\\moorer\\OneDrive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\Rock Properties.txt"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\OneDrive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\Rock Properties.txt"
fsaveName
"Drive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\Rock Properties.txt"
    ATL::CSimpleStringT<char,1>: "Drive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\Rock Properties.txt"

            
            
rootName = "Drive - sound-qi"

            
fsaveFullPath
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Rock Properties.cb"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Rock Properties.cb"

            
	const CString appDataDir = Utilities::GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "\\ColorBarTemplates";

	// Get directory for for color bar template
	CString colorBarTemplateDirectory = resourcesDirectory + "\\" + pDoc->m_tempPathName.Mid(pDoc->m_tempPathName.ReverseFind('\\') + 1);
    
fname
"C:\\Users\\moorer\\OneDrive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\Rock Properties.txt"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\OneDrive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\Rock Properties.txt"

resourcesDirectory = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\\\ColorBarTemplates"

colorBarTemplateDirectory
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj"

            
ERROR_SHARING_VIOLATION

32 (0x20)

The process cannot access the file because it is being used by another process.

--------------------------------------------------------------------------------

c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 0 at i = Unclassified
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 1 at i = Ft Simpsonc:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 2 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 3 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 4 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 5 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 6 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 7 at i = L Keg River
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 8 at i = High BIc:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 9 at i = Med Hi BIc:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 10 at i = Med Low BIc:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 11 at i = Low BIc:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 12 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 13 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 14 at i = Porosity 0-2%
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 15 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 16 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 17 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 18 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 19 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 20 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 21 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 22 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 23 at i = 
c:\sound-qi_source\soundqi-branch\rm_branch\imac\imacdoc.cpp(2627) : atlTraceGeneral - CIMACDoc::CreateColorBarTemplateFiles class name 24 at i = >20%

            
-----

Severity	Code	Description	Project	File	Line	Suppression State
Error	C2664	'BOOL CFileException::GetErrorMessage(LPTSTR,UINT,PUINT) const': cannot convert argument 1 from 'CString' to 'LPTSTR'	NativeUnitTests	c:\sound-qi_source\soundqi-branch\rm_branch\osi\nativeunittests\segyderived.cpp	23	
            
-----
            
fsaveFullPath
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Rock Properties.cb"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj\\Rock Properties.cb"

            
colorBarTemplateDirectory
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj"

            
colorBarTemplateDirectory
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete.prj"

3:20 PM

2021.04.12
I. Researching and implementing solution:                        

bool Utilities::Unzip2Folder(BSTR lpZipFile, BSTR lpFolder)
{
	IShellDispatch* pISD;

	Folder* pZippedFile = 0L;
	Folder* pDestination = 0L;

	long FilesCount = 0;
	IDispatch* pItem = 0L;
	FolderItems* pFilesInside = 0L;

	VARIANT Options, OutFolder, InZipFile, Item;
	CoInitialize(NULL);
	__try {
		if (CoCreateInstance(CLSID_Shell, NULL, CLSCTX_INPROC_SERVER, IID_IShellDispatch, (void**)&pISD) != S_OK)
			return 1;

		InZipFile.vt = VT_BSTR;
		InZipFile.bstrVal = lpZipFile;
		pISD->NameSpace(InZipFile, &pZippedFile);
		if (!pZippedFile)
		{
			pISD->Release();
			return 1;
		}

		OutFolder.vt = VT_BSTR;
		OutFolder.bstrVal = lpFolder;
		pISD->NameSpace(OutFolder, &pDestination);
		if (!pDestination)
		{
			pZippedFile->Release();
			pISD->Release();
			return 1;
		}

		pZippedFile->Items(&pFilesInside);
		if (!pFilesInside)
		{
			pDestination->Release();
			pZippedFile->Release();
			pISD->Release();
			return 1;
		}

		pFilesInside->get_Count(&FilesCount);
		if (FilesCount < 1)
		{
			pFilesInside->Release();
			pDestination->Release();
			pZippedFile->Release();
			pISD->Release();
			return 0;
		}

		pFilesInside->QueryInterface(IID_IDispatch, (void**)&pItem);

		Item.vt = VT_DISPATCH;
		Item.pdispVal = pItem;

		Options.vt = VT_I4;
		Options.lVal = 1024 | 512 | 16 | 4;//http://msdn.microsoft.com/en-us/library/bb787866(VS.85).aspx

		bool retval = pDestination->CopyHere(Item, Options) == S_OK;

		pItem->Release(); pItem = 0L;
		pFilesInside->Release(); pFilesInside = 0L;
		pDestination->Release(); pDestination = 0L;
		pZippedFile->Release(); pZippedFile = 0L;
		pISD->Release(); pISD = 0L;

		return retval;

	}
	__finally
	{
		CoUninitialize();
	}
}            

--------------------------------------------------------------------------------

Unhandled exception thrown: read access violation.
**pFromFolder** was nullptr.

--------------------------------------------------------------------------------
            
Invalid command: "RemoveDirectory"
Error in script "QiPro.nsi" on line 568 -- aborting creation process
!makensis: returned 1, aborting
Error in macro WriteSignedUninstaller on macroline 1
Error in script "Installer\QiPro.nsi" on line 182 -- aborting creation process            

--------------------------------------------------------------------------------

  7998: ANSI targets are deprecated
Done Adding Additional Store
Successfully signed: C:\Users\moorer\AppData\Local\Temp\Uninst.exe
File: "$INSTDIR\ColorBarTemplates\Baha.txt" -> no files found.
Usage: File [/nonfatal] [/a] ([/r] [/x filespec [...]] filespec [...] |
   /oname=outfile one_file_only)
Error in script "Installer\QiPro.nsi" on line 189 -- aborting creation process

            
2021.04.13
I. Researching and implementing solution:                        

1)
            
void CFileOperation::DoFolderCopy(CString sSourceFolder, CString sDestFolder, bool bDelteAfterCopy)
{
	CFileFind ff;
	CString sPathSource = sSourceFolder;
	BOOL bRes = ff.FindFile(sPathSource);
	while (bRes)
	{
		bRes = ff.FindNextFile();
		if (ff.IsDots()) continue;
		if (ff.IsDirectory()) // source is a folder
		{
			if (m_iRecursionLimit == 0) continue;
			sPathSource = ff.GetFilePath() + CString("\\") + CString("*.*");
			CString sPathDest = sDestFolder + ff.GetFileName() + CString("\\");
			if (CheckPath(sPathDest) == PATH_NOT_FOUND) 
			{
				if (!CreateDirectory(sPathDest, NULL))
				{
					ff.Close();
					throw new CFExeption(GetLastError());
				}
			}
			if (m_iRecursionLimit > 0) m_iRecursionLimit --;
			DoFolderCopy(sPathSource, sPathDest, bDelteAfterCopy);
		}
		else // source is a file
		{
			CString sNewFileName = sDestFolder + ff.GetFileName();
			DoFileCopy(ff.GetFilePath(), sNewFileName, bDelteAfterCopy);
		}
	}
	ff.Close();
}            

-----

2)
        
int FindStringExact(int nIndexStart, LPCTSTR lpszFind) const;            

-----

3)

void CColorBarView::OnCbSave() 
{	
	CString fname;
	CString fileFilter = "Colorbar Files (*.cb)|*.cb|All Files (*.*)|*.*|";
	CIMACDoc* pDoc = GetDocument();	

	CFileDialog fileDialog(FALSE, "cb", NULL, OFN_HIDEREADONLY|OFN_PATHMUSTEXIST, fileFilter, this);
	CString path = pDoc->GetProjectPath();
	fileDialog.m_ofn.lpstrInitialDir = path;
	if (fileDialog.DoModal() == IDOK)
	{
		fname = fileDialog.GetPathName();
                pDoc->ColorBarExport(fname);		
	}	
}

-----

4)

-		inputFilePath	"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete\\Baha.cb"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>

-----

5)

    void SetNClass(int n) { m_nClass = n; }

--------------------------------------------------------------------------------
    
6)

Severity	Code	Description	Project	File	Line	Suppression State
Error	C2664	'LRESULT SendMessageA(HWND,UINT,WPARAM,LPARAM)': cannot convert argument 1 from 'CWnd *' to 'HWND'	IMAC	c:\sound-qi_source\soundqi-branch\rm_branch\imac\colorbarview.cpp	957	


Previous version which closed CColorBarFrame and CColorBarView:

void CColorBarView::OnCbAddNewColorbarTemplate()
{
	CString msg;
	CString fileFilter = "Colorbar Templates (*.txt)|*.txt|All Files (*.*)|*.*|";
	CIMACDoc* pDoc = GetDocument();
	CFileDialog fileDialog(TRUE, "cb", NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, fileFilter, this);
	const CString appDataDir = Utilities::GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "ColorBarTemplates";

	// Get directory for for color bar template
	CString colorBarTemplateDirectory = resourcesDirectory + "\\" + pDoc->m_tempPathName.Mid(pDoc->m_tempPathName.ReverseFind('\\') + 1);
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	colorBarTemplateDirectory = colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);     
	
	if (fileDialog.DoModal() == IDOK)
	{
		CString fname = fileDialog.GetPathName();
		
		// Copy file from source into QI-Pro resources dir
		CString fsaveName = fname.Mid(fname.ReverseFind('\\') + 1);
		CString userTemplate = resourcesDirectory + "\\" + fsaveName;
		if (CopyFile(fname, userTemplate, FALSE) == 0) {
			DWORD lasterror = GetLastError();
			// todo: need to print the actual error message
			TRACE("Copy color bar template error == %u\n", lasterror);
		}

		// Save template as color bar *.cb file
		CStdioFile cFile;
		
		if (cFile.Open(fname, CFile::modeRead) == FALSE) {
			msg.Format("Cannot open file %s", fname);
			AfxMessageBox(msg);
			return;
		}
		CStringArray fileContents;

		// Get number of lines in the source file
		int templateSrcLineCount = 0;
		CString row;
		try {
			while (cFile.ReadString(row))
			{
				templateSrcLineCount++;
				fileContents.Add(row + "\n");
			}
		}
		catch (CFileException& ex) {
			TCHAR   szCause[255];
			ex.GetErrorMessage(szCause, 255);
			AfxMessageBox(szCause);
		}	

		// Write out as color bar *.cb file
		const int extensionPos = fsaveName.Find(".");
		CString rootName = fsaveName.Left(extensionPos);
		const int linesToSkip = templateSrcLineCount / pDoc->GetClassCount();
		CString fsaveFullPath = colorBarTemplateDirectory + "\\" + rootName + ".cb";
		CFile cFileOutput;

		if (cFileOutput.Open(fsaveFullPath, CFile::modeCreate | CFile::modeWrite)
			 == FALSE) {
			msg.Format("Cannot open file %s", fsaveFullPath);
			AfxMessageBox(msg);
			return;
		}

		// Write template to *.cb file based on number of classes
		try {
			for (int j = 0; j < fileContents.GetCount(); j++) {
				if (j % linesToSkip == 0) {
					cFileOutput.Write(fileContents[j], fileContents[j].GetLength());
				}
			}
		}
		catch (CFileException& ex) {
			TCHAR   szCause[255];
			ex.GetErrorMessage(szCause, 255);
			AfxMessageBox(szCause);
		}
		cFileOutput.Close();
		cFile.Close();
	}
	Invalidate(FALSE);
	pDoc->UpdateViews();
	CString closeMsg = "Please reopen the color bar view to load the new template.";
	AfxMessageBox(closeMsg);
	this->OnCbExit();
}

Updated attempts to refresh ccombobox which don`t work yet:

void CColorBarView::OnCbAddNewColorbarTemplate()
{
	//::SendMessage(GetParentFrame()->GetParent()->m_hWnd, WM_SETREDRAW, FALSE, 0);
	::SendMessage(this->m_hWnd, WM_SETREDRAW, FALSE, 0);
	CString msg;
	CString fileFilter = "Colorbar Templates (*.txt)|*.txt|All Files (*.*)|*.*|";
	CIMACDoc* pDoc = GetDocument();
	CFileDialog fileDialog(TRUE, "txt", NULL, OFN_HIDEREADONLY | OFN_FILEMUSTEXIST, fileFilter, this);
	const CString appDataDir = Utilities::GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "ColorBarTemplates";

	// Get directory for for color bar template
	CString colorBarTemplateDirectory = resourcesDirectory + "\\" + pDoc->m_tempPathName.Mid(pDoc->m_tempPathName.ReverseFind('\\') + 1);
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	colorBarTemplateDirectory = colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);     
	
	if (fileDialog.DoModal() == IDOK)
	{
		CString fname = fileDialog.GetPathName();
		
		// Copy file from source into QI-Pro resources dir
		CString fsaveName = fname.Mid(fname.ReverseFind('\\') + 1);
		CString userTemplate = resourcesDirectory + "\\" + fsaveName;
		if (CopyFile(fname, userTemplate, FALSE) == 0) {
			DWORD lasterror = GetLastError();
			// todo: need to print the actual error message
			TRACE("Copy color bar template error == %u\n", lasterror);
		}

		// Save template as color bar *.txt file
		CStdioFile cFile;
		
		if (cFile.Open(fname, CFile::modeRead) == FALSE) {
			msg.Format("Cannot open file %s", fname);
			AfxMessageBox(msg);
			return;
		}
		CStringArray fileContents;

		// Get number of lines in the source file
		int templateSrcLineCount = 0;
		CString row;
		try {
			while (cFile.ReadString(row))
			{
				templateSrcLineCount++;
				fileContents.Add(row + "\n");
			}
		}
		catch (CFileException& ex) {
			TCHAR   szCause[255];
			ex.GetErrorMessage(szCause, 255);
			AfxMessageBox(szCause);
		}	

		// Write out as color bar *.cb file from *.txt template based on number of classes
		const int extensionPos = fsaveName.Find(".");
		CString rootName = fsaveName.Left(extensionPos);
		const int linesToSkip = templateSrcLineCount / pDoc->GetClassCount();
		CString fsaveFullPath = colorBarTemplateDirectory + "\\" + rootName + ".cb";
		CFile cFileOutput;

		if (cFileOutput.Open(fsaveFullPath, CFile::modeCreate | CFile::modeWrite)
			 == FALSE) {
			msg.Format("Cannot open file %s", fsaveFullPath);
			AfxMessageBox(msg);
			return;
		}

		// Write template to *.cb file based on number of classes
		try {
			for (int j = 0; j < fileContents.GetCount(); j++) {
				if (j % linesToSkip == 0) {
					cFileOutput.Write(fileContents[j], fileContents[j].GetLength());
				}
			}
		}
		catch (CFileException& ex) {
			TCHAR   szCause[255];
			ex.GetErrorMessage(szCause, 255);
			AfxMessageBox(szCause);
		}
		cFileOutput.Close();
		cFile.Close();
	}
	Invalidate(TRUE);
	pDoc->UpdateViews();
	//CString closeMsg = "Please reopen the color bar view to load the new template.";
	//AfxMessageBox(closeMsg);
	//GetParentFrame()->PostMessage(WM_SETREDRAW);
	//RedrawWindow(NULL, NULL, RDW_ALLCHILDREN | RDW_INVALIDATE | RDW_UPDATENOW | RDW_FRAME | RDW_ERASE);
	//GetParentFrame()->RedrawWindow();
	
	//::SendMessage(GetParentFrame()->GetParent()->m_hWnd, WM_SETREDRAW, TRUE, 0);
	//::RedrawWindow(GetParentFrame()->GetParent()->m_hWnd, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);

	//GetParentFrame()->GetParent()->Create()
	
	::SendMessage(this->m_hWnd, WM_SETREDRAW, TRUE, 0);
	::RedrawWindow(this->m_hWnd, NULL, NULL, RDW_ERASE | RDW_FRAME | RDW_INVALIDATE | RDW_ALLCHILDREN);
	
}

CComboBox  *GetColorBarComboPointer() {return m_pColorBarCombo;}
void SetColorBarComboPointer(CComboBox* p) { m_pColorBarCombo = p; }

-----

Exception thrown at 0x00007FFDD19D4B59 (KernelBase.dll) in QI-Pro.exe: 0x000006A6: The binding handle is invalid.

CStringArray* GetColorBarTemplateFilesPointer() { return m_pColorBarTemplateFiles; }
void SetColorBarTemplateFilesPointer(CStringArray* p) { m_pColorBarTemplateFiles = p; }

m_colorBarTemplateFiles

AddColorBarTemplateFile

/////////////////////////////////////////////////////
// CColorBarTemplateCombo
class CColorBarTemplateCombo : public CComboBox
{
    DECLARE_DYNAMIC(CColorBarTemplateCombo)

public:
    int m_currSelect;

    CColorBarTemplateCombo();
    virtual ~CColorBarTemplateCombo();

protected:
    DECLARE_MESSAGE_MAP()

public:
    void AddColorBarTemplateFile(CString file) { m_colorBarTemplateFiles.Add(file); }
    COLORREF GetSelectedColorValue(void) const;
    LPCTSTR	GetSelectedColorName(void);
    virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
    virtual void MeasureItem(LPMEASUREITEMSTRUCT lpMeasureItemStruct);
    afx_msg void OnCbnSelchange();

private:
    CStringArray m_colorBarTemplateFiles;

    TCHAR m_cColorName[32];		// Name Of Selected Color	
};

	m_wndToolBar.m_cmbColorTemplate.m_currSelect = 
		m_wndToolBar.m_cmbColorTemplate.FindString(0, "ClassColors.cb");
	m_wndToolBar.m_cmbColorTemplate.SetCurSel(m_wndToolBar.m_cmbColorTemplate.m_currSelect);

        
--------------------------------------------------------------------------------



	CStringT Tokenize(
		_In_z_ PCXSTR pszTokens,
		_Inout_ int& iStart) const
	{
		ATLASSERT( iStart >= 0 );

		if(iStart < 0)
			AtlThrow(E_INVALIDARG);

		if( (pszTokens == NULL) || (*pszTokens == (XCHAR)0) )
		{
			if (iStart < this->GetLength())
			{
				return( CStringT( this->GetString()+iStart, GetManager() ) );
			}
		}
		else
		{
			PCXSTR pszPlace = this->GetString()+iStart;
			PCXSTR pszEnd = this->GetString() + this->GetLength();
			if( pszPlace < pszEnd )
			{
				int nIncluding = StringTraits::StringSpanIncluding( pszPlace,
					pszTokens );

				if( (pszPlace+nIncluding) < pszEnd )
				{
					pszPlace += nIncluding;
					int nExcluding = StringTraits::StringSpanExcluding( pszPlace, pszTokens );

					int iFrom = iStart+nIncluding;
					int nUntil = nExcluding;
					iStart = iFrom+nUntil+1;

					return( Mid( iFrom, nUntil ) );
				}
			}
		}

		// return empty string, done tokenizing
		iStart = -1;

		return( CStringT( GetManager() ) );
	}

2021.04.15
I. Researching and implementing solution:                        
        
2021.04.16
I. Researching and implementing solution:                        

Exception thrown at 0x00007FFDD19D4B59 (KernelBase.dll) in QI-Pro.exe: 0x000006A6: The binding handle is invalid

2021.05.10
I. Researching and implementing solution:                        

Roger:
TODO:
-Color Bar Templates: When importing, change the file filter to be *.txt; *.cb
-On import color bar template *.txt, automatically select that one
-Remove "Import Color Bar Template" button and put it as the first item in the combobox list, "Add new Color Bar Template"
-Don`t bother saving the decimated values as *.cb files 
-Change save as color bar with the color bars in %appdata%\project name.  So only have in this directory the color bars saved by the user.  Load these user-saved ones as "Color Bar Name.cb"
-The .txt files are just a list of RGB values, but the *.cb files have RGB plus the class names
-Put "User defined - color bar file name": make it one character, like a mu
-Put combobox in xplotsettings: here don`t load the custom user-defined color bar *.cb files 
-Need to retain the names (say if the user adds a new class name), unless, you restore *.cb file
-Don`t put import on the dropdown, just change the extension to *.cb, *.txt on the Open Color Bar

-> See top of file

-----

int CIMACDoc::ColorBarExportCore(CString fname, CString writeFlag)
{
	FILE* pf;
	int cbSize = GetColorBarSize();
	COLORREF* pColorbar = GetColorBarPtr();

	if ((pf = fopen(fname, writeFlag)) == NULL) {
		CString msg;
		msg.Format("Cannot open file %s", fname);
		AfxMessageBox(msg);
		return -1;
	}

	for (int i = 0; i < cbSize; i++) {
		CString className;
		if (!IsThirdAttributeMode(GetViewInstance())) {
			className.Format("%s", GetClssName(i).GetBuffer());
			className.Replace("\n", "");
		}
		fprintf(pf, "%3d %3d %3d %s\n",
			GetRValue(pColorbar[i]),
			GetGValue(pColorbar[i]),
			GetBValue(pColorbar[i]),
			(const char*)className);
	}
	fclose(pf);
	return 0;
}

int CIMACDoc::ColorBarExport(CString fname)
{
	return ColorBarExportCore(fname, "w");
}

int CIMACDoc::ColorBarExportOverwrite(CString fname)
{
	return ColorBarExportCore(fname, "w+");
}

void CIMACDoc::SaveClassColorbar()
{
	const CString appDataDir = Utilities::GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "ColorBarTemplates";
	CString colorBarTemplateDirectory = resourcesDirectory + "\\" + GetProjectName();
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	colorBarTemplateDirectory = colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);
	const CString classColorsPath = colorBarTemplateDirectory + "\\" + DEFAULT_CLASS_COLORBAR;
	CStringArray colorBarTemplateFiles;
	Utilities::GetAllFileNames(colorBarTemplateFiles, colorBarTemplateDirectory, ".cb");
	const int foundIndex = Utilities::Find(colorBarTemplateFiles, DEFAULT_CLASS_COLORBAR);
	if (foundIndex == -1) {
		ColorBarExportOverwrite(classColorsPath);
	}
}

2021.05.11
I. Researching and implementing solution:                        

		else {
			const CString colorBarTemplateFile = m_colorBarTemplateFiles[iItem];
			if (m_colorBarColors[iItem].GetCount() == 0) {
				Utilities::LoadColorBar(m_colorBarTemplateFiles[iItem], m_projectName, m_colorBarColors[iItem]);
			}
			CArray<COLORREF>& colorbarColors = m_colorBarColors[iItem];

			for (int i = 0; i < colorbarColors.GetCount() && i < m_maxColorSize; i++) {				
				const COLORREF color = colorbarColors[i];
				dc.FillSolidRect(rBlockRect.left + i * colorWidth, rBlockRect.top, colorWidth, rBlockRect.Height(), color);
			}
		}

-----

	Utilities::GetAllFileNames(m_colorBarTemplateFiles, colorBarTemplateDirectory, ".cb");

m_tempPathName = "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj"


2021.05.12
I. Researching and implementing solution:  

void CColorBarCombo::SetProjectName(CString name)
{
	m_projectName = name;

	m_colorBarTemplateFiles.RemoveAll();
	m_colorBarColors.RemoveAll();

	// Get user defined color bar templates for this project
	CStringArray userDefinedTemplateFiles;
	Utilities::GetAllFileNames(m_projectName, userDefinedTemplateFiles);
	
	// Load generated color bar template files
	Utilities::GetColorbarTemplateNames(m_colorBarTemplateFiles);

	for(int j = 0; j < userDefinedTemplateFiles.GetCount(); j++) {
		m_colorBarTemplateFiles.Add(userDefinedTemplateFiles[j]);
	}
	m_colorBarColors.SetSize(m_colorBarTemplateFiles.GetCount());

	for (int i = 0; i < m_colorBarTemplateFiles.GetCount(); i++) {
		AddString(m_colorBarTemplateFiles[i]);
	}
	TRACE("CColorBarCombo::SetProjectName m_colorBarTemplateFiles.GetCount() = %d", m_colorBarTemplateFiles.GetCount());
}

c:\sound-qi_source\soundqi-branch\rm_branch\common\colorbarcombo.cpp(44) : atlTraceGeneral - CColorBarCombo::SetProjectName m_colorBarTemplateFiles.GetCount() = 26'QI-Pro.exe' (Win32): Loaded 'C:\Windows\System32\dwmapi.dll'.

-----

void Utilities::LoadColorBar(CString colorBarTemplateFile, CString projectName, CArray<COLORREF>& colors)
{
	if (colorBarTemplateFile == "") return;

	CStringArray fileContents;
	CStdioFile cFile;
	const CString appDataDir = GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "ColorBarTemplates";
	const CString inputFilePath = resourcesDirectory + "\\" + colorBarTemplateFile;
	
	if (cFile.Open(inputFilePath, CFile::modeRead) == 0) return;
	CString row;

	while (cFile.ReadString(row))
	{
		fileContents.Add(row + "\n");
	}

	for (int i = 0; i < fileContents.GetCount(); i++) {
		const CString sFrom = fileContents[i];

		int j = 0;
		CStringArray saItems;
		int nTokenPos = 0;
		CString strToken = sFrom.Tokenize(_T("\t "), nTokenPos);

		while (!strToken.IsEmpty())
		{
			if (strToken != " ") {
				saItems.Add(strToken);
			}
			strToken = sFrom.Tokenize(_T("\t "), nTokenPos);
		}

		if (saItems.GetCount() >= 3) {
			int red = atoi(saItems[0]);
			int grn = atoi(saItems[1]);
			int blu = atoi(saItems[2]);
			colors.Add(RGB(red, grn, blu));
		}
	}
	cFile.Close();
}

Where:
colorBarTemplateFile = "ClassColors.cb"

-----

				CArray<COLORREF> colorbarColors;
				CString colorBarTemplateFile = this->GetItemText(row, pCD->iSubItem);
				Utilities::LoadColorBar(colorBarTemplateFile, m_projectName, colorbarColors, m_classCount);

				for (int i = 0; i < colorbarColors.GetCount() && i < m_maxColorSize; i++) {
					const COLORREF color = colorbarColors[i];
					hDc->FillSolidRect(rect.left + i * colorWidth, rect.top, colorWidth, rect.Height(), color);
				}

                                
fname = "ClassColors.cb"

-----

void CColorBarCombo::SetProjectName(CString name)
{
	m_projectName = name;

	m_colorBarTemplateFiles.RemoveAll();
	m_colorBarColors.RemoveAll();

	// Get user defined color bar templates for this project
	CStringArray userDefinedTemplateFiles;
	Utilities::GetAllFileNames(m_projectName, userDefinedTemplateFiles);

	for (int j = 0; j < userDefinedTemplateFiles.GetCount(); j++) {
		m_colorBarTemplateFiles.Add(userDefinedTemplateFiles[j]);
	}
	CStringArray templateFiles;
	
	// Load generated color bar template files
	Utilities::GetColorbarTemplateNames(templateFiles);

	for (int i = 0; i < templateFiles.GetCount(); i++) {
		m_colorBarTemplateFiles.Add(templateFiles[i]);
	}

	m_colorBarColors.SetSize(m_colorBarTemplateFiles.GetCount());

	//TRACE("CColorBarCombo::SetProjectName m_colorBarTemplateFiles.GetCount() = %d\r\n", m_colorBarTemplateFiles.GetCount());
}

--------------------------------------------------------------------------------

void CColorBarView::OnCbOpen() 
{
	FILE *pf;
	char buffer[BUFSIZE];
	char *token;
	char delimiters[] = " ,\t\n";
	CString msg, fname;
	CString fileFilter = "Colorbar Files (*.cb)|*.cb|All Files (*.*)|*.*|";
	CIMACDoc* pDoc = GetDocument();

	int cbSize = GetColorBarSize();
	COLORREF *pColorbar = GetColorBarPtr();

	CFileDialog fileDialog(TRUE, "cb", NULL, OFN_HIDEREADONLY|OFN_FILEMUSTEXIST, fileFilter, this);
	if (fileDialog.DoModal() == IDOK)
	{
		fname = fileDialog.GetPathName();
		if ((pf=fopen(fname, "r"))==NULL) {		
			msg.Format("Cannot open file %s", fname);
			AfxMessageBox(msg);
			return;
		}
		int newCount = 0;
		int red, grn, blu;
		CString className;
		while (!feof(pf)) {
			memset(buffer, 0, BUFSIZE);
			if (fgets(buffer, BUFSIZE, pf) == NULL) {
				if (ferror(pf)) {
					msg.Format("Error reading file %s", fname);
					AfxMessageBox(msg);
					fclose(pf);
					return;
				}
				continue; // eof
			}
			token = strtok(buffer, delimiters);
			if (token) {
				sscanf(token, "%d", &red);
				token = strtok(NULL, delimiters);
			}
			if (token) {
				sscanf(token, "%d", &grn);
				token = strtok(NULL, delimiters);
			}			
			if (token) {
				sscanf(token, "%d", &blu);
			} else {
				continue;
			}
			char *p = &token[strlen(token)+1];
			if (strlen(p)>0) {
				className = p;
			} else {
				className.Empty();
			}
			if (newCount > MAXCLASS) {
				CString msg;
				msg.Format("maximum colors allowed: %d", MAXCLASS);
				AfxMessageBox(msg);
				newCount = MAXCLASS;
				break;
			}
			pColorbar[newCount] = RGB(red, grn, blu);
			if (!pDoc->IsThirdAttributeMode(pDoc->GetViewInstance()) && !pDoc->IsColorbarOpenedFromCSI()) {
				pDoc->SetClassName(newCount, className);
			}
			newCount++;
		}
		fclose(pf);
		
		if (pDoc->IsThirdAttributeMode(pDoc->GetViewInstance())) {
			pDoc->SetColorBarSize(pDoc->GetViewInstance(), newCount);
			pDoc->m_bNewColorFlag = 0xffffffff;
		} else if (pDoc->IsColorbarOpenedFromCSI()) {
			pDoc->SetCurrentColorBarCount(newCount);
		} else {
			pDoc->SetNClass(newCount);
			pDoc->m_bNewColorFlag = 0xffffffff;
		}

		m_colorbarIndex = -1;
		pDoc->SendColorbarToHeadwave();
		Invalidate(FALSE);
		pDoc->UpdateViews();
	}	
}

fname
"C:\\Users\\moorer\\OneDrive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\colour bar 24.cb"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\OneDrive - sound-qi.com\\Workspace\\SoundQI\\Features\\ColourBarTemplates\\colour bar 24.cb"

    
C:\Users\moorer\OneDrive - sound-qi.com\Workspace\SoundQI\Features\ColourBarTemplates\colour bar 24.cb

colorBarTemplateDirectory
"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\QI-Pro Laurie complete"

2021.05.13
I. Researching and implementing solution:  

const int colorWidth = m_maxColorSize / m_classCount;
    
Unhandled exception at 0x00007FF75C7B8BCB in QI-Pro.exe: 0xC000041D: An unhandled exception was encountered during a user callback.    

-----

pDoc->GetColorBarComboPointer()->SetClassCount(pDoc->GetClassCount());

-----

ColorBarFrame.cpp line 244:

		const int linesToSkip = templateSrcLineCount / pDoc->GetClassCount();

Unhandled exception at 0x00007FF6E01BDF47 in QI-Pro.exe: 0xC0000094: Integer division by zero.                

-----

file = "Rock Properties.cb"

-----

m_cursor = IDC_SIZENS;

m_cursor = IDC_SIZEALL;

if (hotSpot == ePOLYVERTEX) {
		m_bEditPolyVertex=TRUE;
		m_lbuttondown=TRUE;
		ClipCursor(&Rect);
		m_cursor = IDC_HAND;

	// edit the axis of an ellipse
	}

LPTSTR m_cursor;
int m_externalCursor;

/*
 * Standard Cursor IDs
 */
#define IDC_ARROW           MAKEINTRESOURCE(32512)
#define IDC_IBEAM           MAKEINTRESOURCE(32513)
#define IDC_WAIT            MAKEINTRESOURCE(32514)
#define IDC_CROSS           MAKEINTRESOURCE(32515)
#define IDC_UPARROW         MAKEINTRESOURCE(32516)
#define IDC_SIZE            MAKEINTRESOURCE(32640)  /* OBSOLETE: use IDC_SIZEALL */
#define IDC_ICON            MAKEINTRESOURCE(32641)  /* OBSOLETE: use IDC_ARROW */
#define IDC_SIZENWSE        MAKEINTRESOURCE(32642)
#define IDC_SIZENESW        MAKEINTRESOURCE(32643)
#define IDC_SIZEWE          MAKEINTRESOURCE(32644)
#define IDC_SIZENS          MAKEINTRESOURCE(32645)
#define IDC_SIZEALL         MAKEINTRESOURCE(32646)
#define IDC_NO              MAKEINTRESOURCE(32648) /*not in win3.1 */

IDC_ARROW

BOOL CCrossPlotView::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message)
{
	CIMACDoc *pDoc = CIMACDoc::GetIMACDocPtr();
	if (m_cursor && !pDoc->IsDragMode()) {
		if (m_cursor == IDC_NO) {
			SetCursor(AfxGetApp()->LoadCursor(m_externalCursor));
		} else {
			SetCursor(AfxGetApp()->LoadStandardCursor(m_cursor));
		}
		return TRUE;
	}
	return CView::OnSetCursor(pWnd, nHitTest, message);
}

afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);

OnInitialUpdate:

m_cursor = 0;


		// The slider
		if (point.x > m_rcSlider.left &&
			point.x < (m_rcSlider.right + 80) &&
			point.y > m_rcSlider.top &&
			point.y < m_rcSlider.bottom)
		{
			m_cursor = IDC_HAND;
		}
		else {
				m_cursor = IDC_ARROW;
		}


-----
                
Check Third Attribute combo in Crossplot settings dialog (IDD_XPLOTPARM):
                
DDX_Control(pDX, IDC_ATTRIBUTE_COMBO, m_thirdAttribute);

GetDlgItem(IDC_ATTRIBUTE_COMBO)->EnableWindow(bAttr);

ON_CBN_SELCHANGE(IDC_ATTRIBUTE_COMBO, OnSelchangeAttributeCombo)

COMBOBOX        IDC_ATTRIBUTE_COMBO,517,279,316,64,CBS_DROPDOWNLIST | WS_VSCROLL | WS_TABSTOP

IDD_WIGGLE_OVERLAY DLGINIT
BEGIN
    IDC_ATTRIBUTE_COMBO, 0x403, 1, 0
"\000" 
    0
END

PUSHBUTTON      "Color Map",IDC_COLORMAP,783,245,50,14,WS_GROUP

IDC_COLORMAP_COMBO


CColorBarCombo* m_cmbColorTemplate;

OnSelchangeColorBarTemplateCombo

    DDX_Control(pDX, IDC_COLORMAP, m_btnColorMap);

	ON_BN_CLICKED(IDC_COLORMAP, OnClickedColormap)

void CCrossPlotSettingsDlg::OnClickedColormap()
{
	CIMACDoc *pDoc = CIMACDoc::GetIMACDocPtr();
	pDoc->SetViewInstance(m_viewInstance);

	//set the color flag, so the view can use the new colormap
	DWORD theMagicBit = 0x1 << (m_viewInstance + 2);
	pDoc->m_bNewColorFlag |= theMagicBit;		// turn on the update bit

	AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_EDIT_COLORBAR);
	OnOK();
}

ASSERT(pWnd->m_hWnd == NULL);   // only do once

Severity	Code	Description	Project	File	Line	Suppression State
Error	C2664	'BOOL CComboBox::Create(DWORD,const RECT &,CWnd *,UINT)': cannot convert argument 3 from 'HWND' to 'CWnd *'	IMAC	c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp	163	


2021.05.14
I. Researching and implementing solution:  
>

	const int foundIndex = Utilities::Find(colorBarTemplateFiles, DEFAULT_CLASS_COLORBAR);
	if (foundIndex == -1) {
		//Put *.cb file in project color bar dir and .txt color template dir
		ColorBarExportOverwrite(classColorsPath);
		CString fname = DEFAULT_CLASS_COLORBAR;
		CString fsaveName = fname.Mid(fname.ReverseFind('\\') + 1);
		int fSaveNameExtPos = fsaveName.ReverseFind('.');
		CString rootName = fsaveName.Left(fSaveNameExtPos);
		CopyFile(classColorsPath,
			resourcesDirectory + "\\" + rootName + ".txt", FALSE);
	}


-----

ColorBarFrame.cpp: line 215ff
        
inputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\ClassColors.txt"

--------------------------------------------------------------------------------

Problem is that when I change the CComboBarCombo selected value from CColorBarView the color bar changes do not propagate to the CV window.  This is because the message pump does not receive a message from QI-Pro when the SetCurSel() is called from C++ code; a message is generated only sent when the user changes the value by clicking on the combo box (see https://stackoverflow.com/questions/37907524/the-cbn-selchange-notification-not-works-when-i-use-the-function-combobox-setcur).

"[05-14 1:28 p.m.] Roger Moore
    So I guess this does not get called if you change the ComboBox value programmatically:
​[05-14 1:28 p.m.] Roger Moore
    ON_CBN_SELCHANGE
​[05-14 1:29 p.m.] Roger Moore
    That is, no message is sent for the message pump
"

-> Solution:

			int nDex = pColorBarCombo->FindStringExact(0, rootName + ".cb");
			if (nDex != CB_ERR)
			{
				pColorBarCombo->SetCurSel(nDex);
				::SendMessage(pColorBarCombo->GetParentFrame()->GetSafeHwnd(), WM_COMMAND,
					MAKEWPARAM(pColorBarCombo->GetDlgCtrlID(), CBN_SELCHANGE), reinterpret_cast<LPARAM>(pColorBarCombo->GetSafeHwnd()));
			}

See also the following where initially the combobox value was being set but the value was not being propagated to CV:

void CColorBarCombo::AddColorBarTemplateFile(CString file)
{
	int index = AddString(file);
	SetItemData(index, m_colorBarTemplateFiles.GetCount());
	m_colorBarTemplateFiles.Add(file);
	m_colorBarColors.SetSize(m_colorBarColors.GetSize() + 1);
}


void CColorBarView::OnCbOpen():
			// Add value to color bar template combobox
			CColorBarCombo* pColorBarCombo = pDoc->GetColorBarComboPointer();
			pColorBarCombo->AddColorBarTemplateFile(rootName + ".cb");
                        
2021.05.17
I. Researching and implementing solution:  

-After changing Crossplot settings color combo:

Exception thrown: read access violation.
**this** was 0xFFFFFFFFFFFFFFBF.

_AFXWIN_INLINE int CComboBox::GetCurSel() const
	{ ASSERT(::IsWindow(m_hWnd)); return (int)::SendMessage(m_hWnd, CB_GETCURSEL, 0, 0); }

Called from "GetCurSel()" in:



2021.05.18
I. Researching and implementing solution:  

CString	CColorBarCombo::GetSelectedColorbarFile() const 
{ 
	if (GetCurSel() == -1) return CString();
	else {
		int index = GetCurSel();
		int colorbarIndex = (int) GetItemData(index);
		return m_colorBarTemplateFiles[colorbarIndex];
	}
};



void CIMACDoc::SaveClassColorbar()
{
	const CString appDataDir = Utilities::GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "ColorBarTemplates";
	CString colorBarTemplateDirectory = resourcesDirectory + "\\" + GetProjectName();
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	colorBarTemplateDirectory = colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);
	const CString classColorsPath = colorBarTemplateDirectory + "\\" + DEFAULT_CLASS_COLORBAR;
	CStringArray colorBarTemplateFiles;
	Utilities::GetColorbarTemplateNames(colorBarTemplateFiles);
	const int foundIndex = Utilities::Find(colorBarTemplateFiles, DEFAULT_CLASS_COLORBAR);
	if (foundIndex == -1) {
		//Put *.cb file in project color bar dir and .txt color template dir
		ColorBarExportOverwrite(classColorsPath);
		//CString fname = DEFAULT_CLASS_COLORBAR;
		//CString fsaveName = fname.Mid(fname.ReverseFind('\\') + 1);
		//int fSaveNameExtPos = fsaveName.ReverseFind('.');
		//CString rootName = fsaveName.Left(fSaveNameExtPos);
		//CopyFile(classColorsPath,
		//	resourcesDirectory + "\\" + rootName + ".txt", FALSE);
	}
}

2021.05.19
I. Researching and implementing solution:  

DDX_Control(pDX, IDC_COLORMAP, m_btnColorMap);

ON_BN_CLICKED(IDC_COLORMAP, OnClickedColormap)

void CCrossPlotSettingsDlg::OnSelchangeColorBarTemplateCombo()

void CCrossPlotSettingsDlg::OnClickedColormap()
{
	CIMACDoc *pDoc = CIMACDoc::GetIMACDocPtr();
	pDoc->SetViewInstance(m_viewInstance);

	//set the color flag, so the view can use the new colormap
	DWORD theMagicBit = 0x1 << (m_viewInstance + 2);
	pDoc->m_bNewColorFlag |= theMagicBit;		// turn on the update bit

	AfxGetMainWnd()->SendMessage(WM_COMMAND, ID_EDIT_COLORBAR);
	OnOK();
}

ON_UPDATE_COMMAND_UI(ID_EDIT_COLORBAR, OnUpdateColorbar)

void CIMACView::OnUpdateColorbar(CCmdUI * pCmdUI)
{
	pCmdUI->Enable(GetDocument()->GetFileCount() > 0);
	pCmdUI->SetCheck(FALSE);
}

void CCrossPlotSettingsDlg::OnOK()
{
	if (!IsValid()) {
		return;
	}
	if (HasWarnings()) {
		return;
	}
	ApplyChanges();
	CIMACDoc* pDoc = CIMACApp::GetDocument();
	pDoc->SetColorbarOpenedFromCrossplotSettings(FALSE);

	CDialog::OnOK();
}

-----

"-Will have to change the serialization of the crossplot, to save the color bar combobox name (see code for well stuff, IMACView, the drawing of the wells, how it takes the color bar name, and gets the list of wells)."

void CIMACView::DrawWellOverlay_Depth(CDC * pDC):
				CString colorbarName = pWell->GetCurveColorbarName(colorIndex);
				CArray<COLORREF> colorbar;
				Utilities::LoadColorBar(colorbarName, pDoc->GetProjectName(), colorbar);
				if (colorbar.GetCount() == 0) {
					for (int i = 0; i < pDoc->GetClassCount(); i++) {
						colorbar.Add(pDoc->GetColorBar()[i]);
					}
				}


See also CCurve:

CString		m_colorbarName;

	CString GetCurveColorbarName(int n);
	void	SetCurveColorbarName(int n, CString colorbar);

CString CWell::GetCurveColorbarName(int n)
{
	if (n < 0 || n >= nCurves) return RGB(0, 0, 0);
	CCurve* pCurve = m_curveList.GetAt(m_curveList.FindIndex(n));
	return pCurve->m_colorbarName;
}

void CWell::SetCurveColorbarName(int n, CString colorbar)
{
	if (n < 0 || n >= nCurves) return;
	CCurve* pCurve = m_curveList.GetAt(m_curveList.FindIndex(n));
	pCurve->m_colorbarName = colorbar;
}

void CCurve::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		int nVersion = masterArVersion;	// ar version info for application use
		ar << nVersion;
		ar << m_name;
		ar << m_units;
		ar << m_description;
		int state = m_state;
		ar << state;
		if (nVersion >= 90) ar << m_color;
		if (nVersion >= 91) ar << m_colorbarName;
	} else {
		int nVersion;
		ar >> nVersion;
		ar >> m_name;
		ar >> m_units;
		ar >> m_description;
		int state;
		ar >> state;
		m_state = (eWellState) state;
		m_color = RGB(0, 0, 0);
		if (nVersion >= 90) ar >> m_color;
		if (nVersion >= 91) ar >> m_colorbarName;

	}
}


				CString colorbarName = pWell->GetCurveColorbarName(colorIndex);
				CArray<COLORREF> colorbar;
				Utilities::LoadColorBar(colorbarName, pDoc->GetProjectName(), colorbar);
				if (colorbar.GetCount() == 0) {
					for (int i = 0; i < pDoc->GetClassCount(); i++) {
						colorbar.Add(pDoc->GetColorBar()[i]);
					}
				}

m_tempPathName = "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj"

	// Create directory for project data if it doesn`t exist
	CString colorBarTemplateDirectory =
		resourcesDirectory + "\\" + tempPathName.Mid(tempPathName.ReverseFind('\\') + 1);
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	colorBarTemplateDirectory = colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);


m_logList.SetProjectName(m_projectName);

CString CIMACDoc::GetProjectFullPath()
{
	return m_strPathName;
}

m_strPathName = "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj"

2021.05.20
I. Researching and implementing solution:  

	CString colorBarItem;
	int n;
	
	if (m_cmbColorTemplate.GetCurSel() == -1) {
		int j;
		for (j = 0; j < m_cmbColorTemplate.GetCount(); j++)
		{
			n = m_cmbColorTemplate.GetLBTextLen(j);
			m_cmbColorTemplate.GetLBText(j, colorBarItem.GetBuffer(n));
			if (colorBarItem == m_parms.m_colorbarName) {
				m_cmbColorTemplate.SetCurSel(j);
				break;
			}
			colorBarItem.ReleaseBuffer();
		}

		if (j == m_cmbColorTemplate.GetCount()) {
			m_cmbColorTemplate.SetCurSel(m_cmbColorTemplate.FindString(0, DEFAULT_CLASS_COLORBAR));
		}
	}

2021.05.21
I. Researching and implementing solution:  

-Error on "_CrtDbgBreak()":

QI-Pro.exe has triggered a breakpoint.

        if (_CRT_ASSERT == nRptType && _InterlockedIncrement(&_crtAssertBusy) > 0)
        {
            /* use only 'safe' functions -- must not assert in here! */

            _ERRCHECK(_itoa_s(nLine, szLineMessage, DBGRPT_MAX_MSG, 10));

            __acrt_OutputDebugStringA("Second Chance Assertion Failed: File ");
            __acrt_OutputDebugStringA(szFile ? szFile : "<file unknown>");
            __acrt_OutputDebugStringA(", Line ");
            __acrt_OutputDebugStringA(szLineMessage);
            __acrt_OutputDebugStringA("\n");

            _CrtDbgBreak();
            retval=-1;
            __leave;
        }

void Utilities::LoadColorBar(CString colorBarTemplateFile, CString projectDirectory, CArray<COLORREF>& colors, int classCount)
{
	if (colorBarTemplateFile == "") return;

	CStringArray cbFileContents;
	CStringArray fileContents;
	CStdioFile cFile;
	CString inputFilePath;
	const CString appDataDir = GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "ColorBarTemplates";
	const int projectsPos = projectDirectory.Find("Projects");
	
	if (projectsPos != -1) {
		const CString projectRootDirectory = projectDirectory.Left(projectsPos);
		inputFilePath = projectRootDirectory + colorBarTemplateFile;
	
		if (GetFileAttributes(inputFilePath) != INVALID_FILE_ATTRIBUTES) {
			if (cFile.Open(inputFilePath, CFile::modeRead) == 0) return;
			CString row;

			while (cFile.ReadString(row))
			{
				cbFileContents.Add(row + "\n");
			}
		}
		else {
			CString file = colorBarTemplateFile;
			CString msg;
			const int extensionPos = file.Find(".");
			CString rootName = file.Left(extensionPos);
			inputFilePath = resourcesDirectory + "\\" + rootName + ".txt";

			if (cFile.Open(inputFilePath, CFile::modeRead) == FALSE) {
				msg.Format("Cannot open file %s", inputFilePath);
				AfxMessageBox(msg);
				return;
			}

			// Get number of lines in the source file
			int templateSrcLineCount = 0;
			CString row;
			try {
				while (cFile.ReadString(row))
				{
					templateSrcLineCount++;
					fileContents.Add(row);
				}
			}
			catch (CFileException& ex) {
				TCHAR   szCause[255];
				ex.GetErrorMessage(szCause, 255);
				AfxMessageBox(szCause);
			}
			const int linesToSkip = templateSrcLineCount / classCount;

			// Write template to *.cb file based on number of classes
			CString line;
			try {
				int k = 0;
				for (int j = 0; j < fileContents.GetCount(); j++) {
					if (j % linesToSkip == 0) {
						if (k < fileContents.GetCount()) {
							line = fileContents[j];
							line = line.TrimRight();
							line.Append("\r\n");
							cbFileContents.Add(line);
						}
						k++;
					}
				}
			}
			catch (CFileException& ex) {
				TCHAR   szCause[255];
				ex.GetErrorMessage(szCause, 255);
				AfxMessageBox(szCause);
			}
		}
		for (int i = 0; i < cbFileContents.GetCount(); i++) {
			const CString sFrom = cbFileContents[i];

			int j = 0;
			CStringArray saItems;
			int nTokenPos = 0;
			CString strToken = sFrom.Tokenize(_T("\t "), nTokenPos);

			while (!strToken.IsEmpty())
			{
				if (strToken != " ") {
					saItems.Add(strToken);
				}
				strToken = sFrom.Tokenize(_T("\t "), nTokenPos);
			}

			if (saItems.GetCount() >= 3) {
				int red = atoi(saItems[0]);
				int grn = atoi(saItems[1]);
				int blu = atoi(saItems[2]);
				colors.Add(RGB(red, grn, blu));
			}
		}
	}

	cFile.Close();
}

Where:

colorBarTemplateFile = "Baha.cb"

			const CString colorBarTemplateFile = m_colorBarTemplateFiles.GetAt(colorbarIndex);
			if (m_colorBarColors[colorbarIndex].GetCount() == 0) {
				Utilities::LoadColorBar(colorBarTemplateFile, m_projectDirectory, m_colorBarColors[colorbarIndex], m_classCount);
			}
			CArray<COLORREF>& colorbarColors = m_colorBarColors[colorbarIndex];

			for (int i = 0; i < colorbarColors.GetCount() && i < m_classCount; i++) {
				const COLORREF color = colorbarColors[i];
				dc.FillSolidRect(rBlockRect.left + i * colorWidth, rBlockRect.top, colorWidth, rBlockRect.Height(), color);
			}

const CString colorBarTemplateFile = m_colorBarTemplateFiles.GetAt(colorbarIndex);

m_colorBarTemplateFiles = {m_pData=0x000002f3269f8e80 "Baha.cb" m_nSize=27 m_nMaxSize=29 ...}

		else if (m_colorbarSubitemLow >= 0 && lvhit.iSubItem >= m_colorbarSubitemLow && lvhit.iSubItem <= m_colorbarSubitemHi) {
			CRect rect;
			GetSubItemRect(lvhit.iItem, lvhit.iSubItem, LVIR_BOUNDS, rect);
			m_colorbarComboWnd.Create(WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL | CBS_HASSTRINGS | CBS_OWNERDRAWFIXED, rect, this, 0);
			m_colorbarComboWnd.SetProjectName(m_projectName);
			m_colorbarComboWnd.SetClassCount(m_classCount);
			m_colorbarComboWnd.SetMaxColors(m_maxColorSize);

			CString strItem = this->GetItemText(lvhit.iItem, lvhit.iSubItem);
			int ix = m_colorbarComboWnd.FindStringExact(-1, strItem);
			if (ix == CB_ERR) ix = 0;
			m_colorbarComboWnd.SetCurSel(ix);
			m_colorbarComboWnd.m_item = lvhit.iItem;
			m_colorbarComboWnd.m_subitem = lvhit.iSubItem;
			m_colorbarComboWnd.SetFont(GetFont());
			m_colorbarComboWnd.ShowDropDown(TRUE);
		}


			CString file = colorBarTemplateFile;
			CString msg;
			const int extensionPos = file.Find(".");
			CString rootName = file.Left(extensionPos);
			inputFilePath = resourcesDirectory + "\\" + rootName + ".txt";

Where:
                        
inputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Baha.txt"

colorBarTemplateFile = "ClassColors.cb"

-----

const CString colorBarTemplateFile = m_colorBarTemplateFiles.GetAt(colorbarIndex);

_AFXCOLL_INLINE const CString& CStringArray::GetAt(INT_PTR nIndex) const
	{ ASSERT(nIndex >= 0 && nIndex < m_nSize);
		if( nIndex < 0 || nIndex >= m_nSize )
			AfxThrowInvalidArgException();
		return m_pData[nIndex]; }
_AFXCOLL_INLINE void CStringArray::

m_colorBarTemplateFiles = {m_pData=0x000001a5bb2f4990 "Baha.cb" m_nSize=13 m_nMaxSize=13 ...}

colorbarIndex = 13

-----

Check if combobox contains string already or not:

	//m_cmbColorTemplate.SetProjectName(pDoc->GetProjectName());
	m_cmbColorTemplate.SetProjectDirectory(pDoc->GetProjectPath());
	CString colorBarItemText;
	int colorBarItemTextLength;
	
	if (m_cmbColorTemplate.GetCurSel() == -1) {
		int j;
		for (j = 0; j < m_cmbColorTemplate.GetCount(); j++)
		{
			colorBarItemTextLength = m_cmbColorTemplate.GetLBTextLen(j);
			m_cmbColorTemplate.GetLBText(j, colorBarItemText.GetBuffer(colorBarItemTextLength));
			if (colorBarItemText == m_parms.m_colorbarName) {
				m_cmbColorTemplate.SetCurSel(j);
				break;
			}
			colorBarItemText.ReleaseBuffer();
		}

		if (j == m_cmbColorTemplate.GetCount()) {
			m_cmbColorTemplate.SetCurSel(m_cmbColorTemplate.FindString(0, DEFAULT_CLASS_COLORBAR));
		}
	}

        
	// the Color Bar Template select combo box
	CSize extent = pDC->GetTextExtent("1234567");
	rect.top += 5;
	rect.left = rect.right;
	rect.right = rect.left + extent.cx + 140;
	if (!m_wndToolBar.m_cmbColorTemplate.Create(WS_CHILD | WS_VISIBLE | CBS_DROPDOWNLIST | WS_VSCROLL | CBS_HASSTRINGS | CBS_OWNERDRAWFIXED | CBS_SORT,
		rect, &m_wndToolBar, IDC_COMBO_COLORBAR)) {
		TRACE0("Failed to create color bar tempate combo Box\n");
		return -1;
	}


curveProps.SetProjectDirectory(pDoc->GetProjectPath());

GetXplotParms

-> Is this why the CV changes when I select a new value in the Crossplot Settings dialog for the color bar?

	// initalize the cutoff line list box
	CRect rItem;
	pDoc->SetColorbarOpenedFromCrossplotSettings(TRUE);
	COLORREF* pColorbar = pDoc->GetColorBar();
	m_lstCutoffLines.ResetSubItemColorArray();
	m_colorList.RemoveAll();
	COLORREF whiteColor = RGB(255, 255, 255);
	
	for (int i = 0; i < pDoc->GetClassCount(); i++) {
		m_colorList.Add(pColorbar[i]);
		m_lstCutoffLines.SetSubitemColor(COL_CLASS_ABOVE_IN, i, pColorbar[i]);
		m_lstCutoffLines.SetSubitemColor(COL_CLASS_BELOW_OUT, i, pColorbar[i]);
		m_lstCutoffLines.SetSubitemColor(COL_APPLY, i, pColorbar[i]);
	}

        
-----

void Utilities::LoadColorBar(CString colorBarTemplateFile, CString projectDirectory, CArray<COLORREF>& colors, int classCount)
{
	if (colorBarTemplateFile == "") return;

	CStringArray cbFileContents;
	CStringArray fileContents;
	CStdioFile cFile;
	CString inputFilePath;
	const CString appDataDir = GetAppDataDirectory();
	const CString resourcesDirectory = appDataDir + "ColorBarTemplates";
	const int projectsPos = projectDirectory.Find("Projects");
	
	if (projectsPos != -1) {
		const CString projectRootDirectory = projectDirectory.Left(projectsPos);
		inputFilePath = projectRootDirectory + colorBarTemplateFile;
	
		if (GetFileAttributes(inputFilePath) != INVALID_FILE_ATTRIBUTES) {
			if (cFile.Open(inputFilePath, CFile::modeRead) == 0) return;
			CString row;

			while (cFile.ReadString(row))
			{
				cbFileContents.Add(row + "\n");
			}
		}
		else {
			CString file = colorBarTemplateFile;
			CString msg;
			const int extensionPos = file.Find(".");
			CString rootName = file.Left(extensionPos);
			inputFilePath = resourcesDirectory + "\\" + rootName + ".txt";

			if (cFile.Open(inputFilePath, CFile::modeRead) == FALSE) {
				msg.Format("Cannot open file %s", inputFilePath);
				AfxMessageBox(msg);
				return;
			}
                        // ...
                }
        }
}

-Called from:


	// initalize the cutoff line list box
	CRect rItem;
	pDoc->SetColorbarOpenedFromCrossplotSettings(TRUE);
	colorBarItemTextLength = m_cmbColorTemplate.GetLBTextLen(m_cmbColorTemplate.GetCurSel());
	m_cmbColorTemplate.GetLBText(m_cmbColorTemplate.GetCurSel(), colorBarItemText.GetBuffer(colorBarItemTextLength));
	CArray<COLORREF> colorbarColors;
	CString colorBarTemplateFile = colorBarItemText;
	Utilities::LoadColorBar(colorBarTemplateFile, pDoc->GetProjectPath(), colorbarColors, pDoc->GetClassCount());

2021.05.25
I. Researching and implementing solution:          
    
color = 9474192

			if (saItems.GetCount() >= 3) {
				int red = atoi(saItems[0]);
				int grn = atoi(saItems[1]);
				int blu = atoi(saItems[2]);
				colorbarColors[i] = RGB(red, grn, blu);
			}


	CArray<COLORREF> colorbarColors;
	CString colorBarTemplateFile = colorBarItemText;
	Utilities::LoadColorBar(colorBarTemplateFile, pDoc->GetProjectPath(), colorbarColors, pDoc->GetClassCount());

zip error: Zip file structure invalid (QiProSetup-v4.6.0.zip)


        
2021.05.26
I. Researching and implementing solution:

inputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Rock Properties.txt"

inputFilePath = "C:\\QI-Pro Demo\\2020 12 16 Blackfoot Demo\\QI-Pro Blackfoot Demo\\Rock Properties.cb"

-----

	CIMACDoc* pDoc = GetDocument();	

	CFileDialog fileDialog(FALSE, "cb", NULL, OFN_HIDEREADONLY|OFN_PATHMUSTEXIST, fileFilter, this);
	CString path = pDoc->GetProjectPath();

        
filePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Blackfoot SW Exercise-1\\Rock Properties.cb"

2021.05.27
I. Researching and implementing solution:

See https://stackoverflow.com/questions/9933448/change-the-item-background-color-of-a-combobox-in-mfc

	CSize extent(0, 0);
	CDC *pDC = m_staticCtrl.GetDC();
	if (pDC != NULL) {
		extent = pDC->GetTextExtent(text);
		m_staticCtrl.ReleaseDC(pDC);
	}

        
Unhandled exception at 0x00007FF6CB180526 in QI-Pro.exe: 0xC000041D: An unhandled exception was encountered during a user callback.

2021.06.01
I. Researching and implementing solution:

_AFXWIN_INLINE HICON CWnd::SetIcon(HICON hIcon, BOOL bBigIcon)
	{ ASSERT(::IsWindow(m_hWnd)); return (HICON)::SendMessage(m_hWnd, WM_SETICON, bBigIcon, (LPARAM)hIcon); }

        
// Functions used by the framework to manage the window once created.
// Will create the frame window.
CFrameWnd* CFrame::CreateFrame( UINT nID )
{
	//TRACE("CreateFrame nID=%d\n", nID);
    // Create the window and validate it.
    CMDIChildWndEx* pNewFrameWnd	= ( CMDIChildWndEx* )( CreateNewFrame( m_pDocument, NULL ) );
    HICON hicon = AfxGetApp()->LoadIcon(GetIconID());
    pNewFrameWnd->SetIcon(hicon, false);
    // ...
}    

// Method to open the frame associated with the event id.
BOOL CDocFrameMgr::OnCmdMsg( UINT _nID, int _nCode, void* _pExtra )
{
	//TRACE ("OnCmdMsg nID=%d nCode=%d *pExtra=%d\n", _nID, _nCode, _pExtra);
	CFrame* pChosenFrame = FindFrame( _nID );
	//TRACE ("OnCmdMsg returned from FindFrame eID=%d\n", pChosenFrame->GetEventID);
    if ( _nCode == CN_COMMAND && pChosenFrame )
    {
        // Try to create the frame.
        return pChosenFrame->ShowOrCreateFrame( _nID );
    }
    // ...
}

wincore.cpp:

	CATCH_ALL(e)
	{
		lResult = AfxProcessWndProcException(e, &pThreadState->m_lastSentMsg);
		TRACE(traceAppMsg, 0, "Warning: Uncaught exception in WindowProc (returning %ld).\n",
			lResult);
		DELETE_EXCEPTION(e);
	}

D:\a01\_work\6\s\src\vctools\vc7libs\ship\atlmfc\include\atlexcept.h(66) : atlTraceException - AtlThrow: hr = 0x80070057
D:\a01\_work\6\s\src\vctools\VC7Libs\Ship\ATLMFC\Src\MFC\olemisc.cpp(423) : AppMsg - Warning: constructing COleException, scode = E_INVALIDARG ($80070057).
Exception thrown at 0x00007FFBB4A14B89 in QI-Pro.exe: Microsoft C++ exception: COleException at memory location 0x000000AAB1FE98A8.
D:\a01\_work\6\s\src\vctools\VC7Libs\Ship\ATLMFC\Src\MFC\wincore.cpp(274) : AppMsg - Warning: Uncaught exception in WindowProc (returning -1)

--------------------------------------------------------------------------------

II. Updates based on Kevin`s Feedback:

From: Kevin Lee <kevin@sound-qi.com> 
Sent: May 28, 2021 3:27 PM
To: Roger Moore <roger@sound-qi.com>; Brenda Maloff <brenda@sound-qi.com>
Subject: RE: code review: color bar templates

-	Point density should honor the selected color map

 


-	The cutoff elements should always use the class colors, never the point density or 3rd attribute colors…
 


-	Seismic attribute always uses blue-white-red…

 

Loading a new colorbar file , the dialog retains the .cb

 



Loading new color bars leaves them scattered around on the dropdown
 



From: Roger Moore <roger@sound-qi.com> 
Sent: Friday, May 28, 2021 1:23 PM
To: Brenda Maloff <brenda@sound-qi.com>; Kevin Lee <kevin@sound-qi.com>
Subject: RE: code review: color bar templates

Thanks for the feedback.  Here are my responses in blue:

1.	There will be an issue if anyone ever puts a dot in the color bar name because of how you try to find the extension. You need to do a reverse find for the dot, otherwise everything after the first dot will be considered an extension.
	Updated the code to do a reverse find for the extension.
2.	There is an issue with the serialization…..I assume that you did a merge, and got my version change from 92 to 93. You changed the A_ArchiveVersion.h to be 94, however you never changed your serialization code to use 94 instead of 93…..which means anyone who saved a project using the 93 version will crash when they use this latest code. You need to change XPlotParms.cpp to use 94 instead of 93 as well.
	Yes, I realize now that if your changes used 93 and my changes used 93, that would cause a problem, so I have updated serialization to use 94 in XPlotParms.cpp.
3.	You’ve changed the text color on the color combo to be a very light gray, which makes it very hard to read. I thought that you were going to change the background item color to be light grey and not the text color for .cb files.
	Please note that I had tried to change the background but it didn’t work, which I haven’t figured out yet.  To resolve the above issue, I have now changed the color for custom user templates to be blue instead of light grey.
4.	The selected color bar is now only drawing the name and not the colorbar in the colorbar window
	When I look through the repository history for ColorBarCombo.cpp, I don’t see that drawing the color portion with the name was ever present in QI-Pro.  Off the top of my head, I am not sure how to accomplish this, because CColorBarCombo::DrawItem is not called until the user actually clicks on the combobox.
5.	You’ve seemed to have added more code in the colorbarview that deals with is this the third attribute color…..I thought since you added the colorbar to the crossplot parms dialog, that there will never be a way to get to the colorbarview as a third attribute. You should be removing anything in the colorbarview that has to deal with the third attribute color.
	Please note that I had removed it, but then I re-added it because when I changed the color bar in the XplotParms then it would propagate the changes to the CV, so I put it back, but it turns out I didn’t need to put it back.  All I had to do was stop using pColorBar in XplotParms, so I have removed it again.

Please find the latest code changes here:

Changeset 1424: -Updated search for .cb extension by doing a reverse search in case anyone ever - Repos

From: Brenda Maloff <brenda@sound-qi.com> 
Sent: May 27, 2021 5:06 PM
To: Roger Moore <roger@sound-qi.com>; Kevin Lee <kevin@sound-qi.com>
Subject: RE: code review: color bar templates

Couple of things I saw when looking at the code…..
1.	There will be an issue if anyone ever puts a dot in the color bar name because of how you try to find the extension. You need to do a reverse find for the dot, otherwise everything after the first dot will be considered an extension.
2.	There is an issue with the serialization…..I assume that you did a merge, and got my version change from 92 to 93. You changed the A_ArchiveVersion.h to be 94, however you never changed your serialization code to use 94 instead of 93…..which means anyone who saved a project using the 93 version will crash when they use this latest code. You need to change XPlotParms.cpp to use 94 instead of 93 as well.
3.	You’ve changed the text color on the color combo to be a very light gray, which makes it very hard to read. I thought that you were going to change the background item color to be light grey and not the text color for .cb files.
4.	The selected color bar is now only drawing the name and not the colorbar in the colorbar window
5.	You’ve seemed to have added more code in the colorbarview that deals with is this the third attribute color…..I thought since you added the colorbar to the crossplot parms dialog, that there will never be a way to get to the colorbarview as a third attribute. You should be removing anything in the colorbarview that has to deal with the third attribute color.

Just what I have seen by having a quick look
   Brenda

From: Roger Moore <roger@sound-qi.com> 
Sent: May-27-21 3:44 PM
To: Brenda Maloff <brenda@sound-qi.com>; Kevin Lee <kevin@sound-qi.com>
Subject: RE: code review: color bar templates

Hi Kevin & Brenda, please find the code updates here:

Changeset 1422: -Color Bar Templates: When importing, change the file filter to be *.txt; *.cb - Repos
Changeset 1423: -Changed user-defined color bar templates text color to gray in CColorBarCombo - Repos

Please let me know if this is what you were looking for.

-----

		// Third Attribute mode //
		else if (pXpParms->m_nScatterMode == eATTR) {
			m_tracePoint = 60;
			// display the third attribute color bar
			COLORREF *colorbar;
			colorbar = pDoc->GetColorBarPtr(m_viewInstance);
			int colorBarSize = pDoc->GetColorBarSize(m_viewInstance);

			pDC->SelectObject(m_pNormPen);
			CRect rcBar;
			rcBar.left = rcClient.right - RIGHTBORDER + DEN_WIDTH;
			rcBar.right = rcBar.left + DEN_WIDTH;
			rcBar.top = 2 * BORDER;
			rcBar.bottom = rcClient.bottom - 2 * BORDER;
			int inc = (rcBar.bottom - rcBar.top) / colorBarSize;
			rcBar.bottom = rcBar.top + (colorBarSize*inc);
			
			CRect rcPlot = rcBar;
			rcPlot.bottom = rcPlot.top + inc;
			for (int i = colorBarSize; i>0; i--) {
				pDC->FillRect(rcPlot, &CBrush(colorbar[i - 1]));
				rcPlot.top += inc;
				rcPlot.bottom += inc;
			}
			pDC->MoveTo(rcBar.left, rcBar.top);
			pDC->LineTo(rcBar.right, rcBar.top);
			pDC->LineTo(rcBar.right, rcBar.bottom);
			pDC->LineTo(rcBar.left, rcBar.bottom);
			pDC->LineTo(rcBar.left, rcBar.top);
			CRect rcText = rcBar;

			sText.Format("%6g", pXpParms->m_attrColorBarMax);
			rcText.bottom = rcText.top;
			rcText.top -= dxy;
			rcText.left -= dxy;
			rcText.right += dxy;
			pDC->DrawText(sText, rcText, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
			rcText.top = rcBar.bottom;
			rcText.bottom = rcBar.bottom + dxy;
			sText.Format("%6g", pXpParms->m_attrColorBarMin);
			pDC->DrawText(sText, rcText, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

			// draw the name of the 3rd attribute rotated along the right side the colorbar
			// The GetOutputTextExtent() function returns the extents of the unrotated text. So we have to adjust for the vertical orientation.
			CFont *pOldFont = pDC->SelectObject(m_pFont270);
			CSize sizeText = pDC->GetOutputTextExtent(pXpParms->GetColorAttr());
			rcText.left = rcBar.left;
			rcText.bottom = rcBar.bottom;
			rcText.right = rcBar.right + sizeText.cx + sizeText.cy + DEN_WIDTH;
			rcText.top = rcBar.top + ((rcBar.bottom - rcBar.top) / 2) - (sizeText.cx / 2);
			pDC->DrawText(pXpParms->GetColorAttr(), rcText, DT_RIGHT | DT_TOP | DT_SINGLELINE);

			pDC->SelectObject(pOldFont);
		}

-----

void CCrossPlotView::DoOnDraw(CDC* pDCin) 
{
    // ...
    
		// allocate colors for the density plots
		COLORREF *densitybar = pDoc->GetDensityColorBar();
		for (int j=0, i=MAXCLASS; j<DENSITYBARSIZE; j++, i++) {
			if (pTracePen[i]==NULL) {
				pTracePen[i] = new CPen(PS_SOLID, 1, densitybar[j]);
				if (!pTracePen[i]) {
					AfxMessageBox("Error allocating Trace Pen array");
					return;
				}
			}
			if (pTraceBrush[i]==NULL) {
				pTraceBrush[i] = new CBrush(densitybar[j]);
				if (!pTraceBrush[i]) {
					AfxMessageBox("Error allocating Trace Brush array");
					return;
				}
			}
		}
    // ...
}    

void CCrossPlotView::DrawScatter(CDC *pDC, int viewInstance, CSegy *pSegyX, CSegy *pSegyY,
    CSegy *pSegyAttr, int startTrace, int endTrace, CViewZoneArray *pSelectedZones, BOOL *pClassListArray, int nDraw, BOOL *bFoundHighlight,
    int *densityTable, CRect rect, CPen **pTracePen, CBrush **pTraceBrush, CPen *highlightPen1, CBrush *highlightBrush1, CPen* highlightPen2, CBrush* highlightBrush2)
{
    // ...
            // Points Density mode
            if (pXpParms->m_nScatterMode == eDENSITY) {
                int index = k + (j*nsamps);
                if (densityTable[index] == -1) {
                    bDrawpoint = FALSE;  // turn the point off
                }
                if (nDraw == 1 && bHighlight) {

                } else {
					float factor = (float)(DENSITYBARSIZE - 1) / (float)(pXpParms->m_colorBarMax - pXpParms->m_colorBarMin);
					ixpen = (int)((float)(densityTable[index] - pXpParms->m_colorBarMin) * factor) + MAXCLASS;
					if (ixpen >= MAXCLASS + DENSITYBARSIZE) ixpen = MAXCLASS + DENSITYBARSIZE - 1;
                    if (ixpen < MAXCLASS) ixpen = MAXCLASS;
                }
            }
    
    // ...
}    


void CCrossPlotView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
    // ...
	 else if (command == 'M') {
		if (pXpParms->m_nScatterMode == eDENSITY) {
			pXpParms->m_nScatterMode = eCLASS;
		} else {
			pXpParms->m_nScatterMode = eDENSITY;	
		}
		pDoc->UpdateViews();
	}
    // ...
}    

UpdateDensityColorsFromColorComboValue(CIMACDoc *pDoc);

void CCrossPlotView::OnDraw(CDC* pDCin)
{
	__try {
		DoOnDraw(pDCin);
	}
	__except (SEH_Filter(GetExceptionCode()))
	{
		char msg[512];
		char sCode[20];
		if (!m_suppress) {
			if (m_code == STATUS_ACCESS_VIOLATION) {
				strcpy(sCode, "ACCESS_VIOLATION");
			} else {
				sprintf(sCode, "exception %0X", m_code);
			}
			sprintf(msg, "Caught %s in CrossPlotView::OnDraw() tracePoint=%d\nSuppress messages like this?", sCode, m_tracePoint);
			if (AfxMessageBox(msg, MB_YESNO) == IDYES) m_suppress = TRUE;
		}
	}
}

[[noreturn]] _CRTIMP2_PURE void __cdecl _Throw_Cpp_error(int code) { // throw error object
    _THROW(system_error(static_cast<int>(codes[code]), _STD generic_category(), msgs[code]));
}

Unhandled exception at 0x00007FFBB4A14B89 in QI-Pro.exe: Microsoft C++ exception: std::system_error at memory location 0x000000786FBE9668.


-----

2021.06.02
I. Researching and implementing solution:

		int istat = (int) dlg.DoModal();
		if (dlg.GetSuppressButtonState()) {
			pDoc->SuppressCutoffMessage(TRUE);
		}
		if (istat == IDCANCEL) return true;

                
-In LoadColorBar, the following concatenation was failing:

			CString inputFilePath = projectRootDirectory + colorBarTemplateFile;

Where:

projectRootDirectory = "C:\\QI-Pro Demo\\Horn River Demo\\"
colorBarTemplateFile = "Greyscale.cb"

After steppnig past the above line:

inputFilePath = "C:\\QI-Pro Demo\\Horn River Demo\\"

The issue was that the null character was not getting added to the end of the string in these lines:

	CString colorBarItemText;
	int colorBarItemTextLength = m_cmbColorTemplate.GetLBTextLen(m_cmbColorTemplate.GetCurSel());
	m_cmbColorTemplate.GetLBText(m_cmbColorTemplate.GetCurSel(), colorBarItemText.GetBuffer(colorBarItemTextLength));

-> Solution: Don`t set the size of the string length when getting the string:

	CString colorBarItemText;
	m_cmbColorTemplate.GetLBText(m_cmbColorTemplate.GetCurSel(), colorBarItemText);

--------------------------------------------------------------------------------


m_nScatterMode

	bool bScatter = m_nScatter > 0;
	bool bDensity = bScatter && (m_nScatterMode==eDENSITY);
        bool bAttr = bScatter && (m_nScatterMode == eATTR);
        
m_densityColorBarCurSel

-----

void CCrossPlotSettingsDlg::AddFile(CString attr, CString file, int favorite, CHeaderMap* pHeaderMap)
{
	m_attr[m_fileCount] = attr;
	m_file[m_fileCount] = file;
	m_favorite[m_fileCount] = favorite;
	m_pHeaderMap[m_fileCount] = pHeaderMap;
	m_fileCount++;
}

Called from:

	for (int i=0; i<pDoc->GetFileCount(); i++) {
		crossPlotSettingsDlg.AddFile(pDoc->GetAttr(i), pDoc->GetFile(i), pDoc->GetFavorite(i), pDoc->GetSegyInPtr(i)->GetHeaderMap());
	}

Where:

attr
"angle_stack_15"
    ATL::CSimpleStringT<char,1>: "angle_stack_15"
file
"C:\\QI-Pro Demo\\Horn River Demo\\Seismic\\demo_angle_stack_15_shift_subset.sgy"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Seismic\\demo_angle_stack_15_shift_subset.sgy"
favorite
1
pHeaderMap
0x0000029e4a818578 {sampleInterval={m_index=16 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...} nSamps={m_index=...} ...}
    CObject: {...}
    sampleInterval: {m_index=16 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    nSamps: {m_index=20 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    formatCode: {m_index=24 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    coordUnits: {m_index=54 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    revisionNumber: {m_index=300 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    fixedLengthFlag: {m_index=302 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    lineseqno: {m_index=0 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    fileseqno: {m_index=4 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    ff: {m_index=8 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    fftr: {m_index=12 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    shotPoint: {m_index=16 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    cdp: {m_index=20 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    cdptr: {m_index=24 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    trid: {m_index=28 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}
    dataUse: {m_index=34 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    distance: {m_index=36 m_type=eINT (1) m_size=eVAR_4BYTE (4) ...}
    recElev: {m_index=40 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    shotElev: {m_index=44 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    recDatum: {m_index=52 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    shotDatum: {m_index=56 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    elevScalar: {m_index=68 m_type=eINT (1) m_size=eVAR_4BYTE (4) ...}
    coordScalar: {m_index=68 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}
    sourceX: {m_index=72 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    sourceY: {m_index=76 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    recX: {m_index=80 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    recY: {m_index=84 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    lagTime: {m_index=104 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}
    startTime: {m_index=108 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}
    trHdrNsamp: {m_index=114 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    trHdrSI: {m_index=117 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    cdpX: {m_index=180 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    cdpY: {m_index=184 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    inlineNum: {m_index=188 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    xlineNum: {m_index=192 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    cdpSp: {m_index=196 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}
    spScalar: {m_index=200 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}

-		pDoc->GetSegyInPtr(i)->GetHeaderMap()	0x0000029e4a818578 {sampleInterval={m_index=16 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...} nSamps={m_index=...} ...}	CHeaderMap *
+		CObject	{...}	CObject
+		sampleInterval	{m_index=16 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		nSamps	{m_index=20 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		formatCode	{m_index=24 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		coordUnits	{m_index=54 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		revisionNumber	{m_index=300 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		fixedLengthFlag	{m_index=302 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		lineseqno	{m_index=0 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		fileseqno	{m_index=4 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		ff	{m_index=8 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		fftr	{m_index=12 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		shotPoint	{m_index=16 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		cdp	{m_index=20 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		cdptr	{m_index=24 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		trid	{m_index=28 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		dataUse	{m_index=34 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		distance	{m_index=36 m_type=eINT (1) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		recElev	{m_index=40 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		shotElev	{m_index=44 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		recDatum	{m_index=52 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		shotDatum	{m_index=56 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		elevScalar	{m_index=68 m_type=eINT (1) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		coordScalar	{m_index=68 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		sourceX	{m_index=72 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		sourceY	{m_index=76 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		recX	{m_index=80 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		recY	{m_index=84 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		lagTime	{m_index=104 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		startTime	{m_index=108 m_type=eINT (1) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		trHdrNsamp	{m_index=114 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		trHdrSI	{m_index=117 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}	CHeaderVar
+		cdpX	{m_index=180 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		cdpY	{m_index=184 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		inlineNum	{m_index=188 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		xlineNum	{m_index=192 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		cdpSp	{m_index=196 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar
+		spScalar	{m_index=200 m_type=eUINT (0) m_size=eVAR_4BYTE (4) ...}	CHeaderVar

CHeaderMap m_headerMap;

segyUtil.SegyPropertiesFromHeader(pBinary, GetHeaderMap(), &nsamp, (DWORD *)&m_nSi, (DWORD *)&m_nFormatCode, &m_dataEndian);

				pSegy->Reset();
				int ntrace = (int) pData->GetCount();
				pSegy->Create(ntrace, pSegy->GetSegyIndexPtr()->GetSampleCount());
				if (pSegy->LoadIndexedLine(GetFile(i), 0, GetInLineMin(), GetInLineMax(), GetXLineMin(), GetXLineMax(), GetInlineXlineMode(), pData) < 0) {
					return -1;
				}

                                
2021.06.03
I. Researching and implementing solution:

-		crossPlotSettingsDlg	{hWnd=0x0000000000000000 <NULL>}	CCrossPlotSettingsDlg
+		CDialog	{hWnd=0x0000000000000000 <NULL>}	CDialog
+		m_lstCutoffLines	{hWnd=0x0000000000000000 <NULL>}	CEditListCtrl
+		m_btnCutoffDelete	{hWnd=0x0000000000000000 <NULL>}	CButton
+		m_btnCutoffAdd	{hWnd=0x0000000000000000 <NULL>}	CButton
+		m_edtTitleBox	{hWnd=0x0000000000000000 <NULL>}	CEdit
+		m_btnScanXAttr	{hWnd=0x0000000000000000 <NULL>}	CButton
+		m_btnScanYAttr	{hWnd=0x0000000000000000 <NULL>}	CButton
+		m_btnScanAttribute	{hWnd=0x0000000000000000 <NULL>}	CButton
+		m_btnCSIX	{hWnd=0x0000000000000000 <NULL>}	CButton
+		m_btnCSIY	{hWnd=0x0000000000000000 <NULL>}	CButton
+		m_xAttrCombo	{hWnd=0x0000000000000000 <NULL>}	CComboBox
+		m_yAttrCombo	{hWnd=0x0000000000000000 <NULL>}	CComboBox
+		m_thirdAttribute	{hWnd=0x0000000000000000 <NULL>}	CComboBox
+		m_cmbColorTemplate	{hWnd=0x0000000000000000 <NULL>}	CColorBarCombo
+		m_ImageBrowse	{hWnd=0x0000000000000000 <NULL>}	CButton
		m_xMin	0.00000000	float
		m_xMax	0.00000000	float
		m_yMin	0.00000000	float
		m_yMax	0.00000000	float
+		m_colorbarName	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_ImageFile	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_strXAttr	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_strTitleBox	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_strYAttr	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_strColorAttr	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		m_bDisableImage	0	int
		m_nScatter	1	int
		m_xLabelInterval	0.00000000	float
		m_yLabelInterval	0.00000000	float
		m_xTickInterval	0.00000000	float
		m_yTickInterval	0.00000000	float
+		m_title	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		m_dotSize	2	int
		m_nScatterMode	0	int
		m_binXsize	0.00000000	float
		m_binYsize	0.00000000	float
		m_colorBarMin	0	int
		m_colorBarMax	0	int
		m_bFineTuneMode	0	int
		m_csiXstate	0	int
		m_csiYstate	0	int
		m_attrColorBarMin	0.00000000	float
		m_attrColorBarMax	0.00000000	float
		m_viewInstance	0	int
		m_densityColorBarCurSel	647620233	int
		m_thirdAttrColorBarCurSel	47	int
+		m_colorList	{m_pData=0x0000000000000000 {???} m_nSize=0 m_nMaxSize=0 ...}	CArray<unsigned long,unsigned long &>
+		m_comboStrings	{m_pData=0x0000000000000000 <NULL> m_nSize=0 m_nMaxSize=0 ...}	CStringArray
		m_fileCount	0	int
+		m_attr	0x0000002f2699dd70 {"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ...}	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>[100]
+		m_file	0x0000002f2699e090 {"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ...}	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>[100]
+		m_favorite	0x0000002f2699e3b0 {4, 0, 1, -858993460, 0, 47, 0, 0, 647619696, 47, 846751015, 32763, -858993460, -858993460, ...}	int[100]
+		m_pHeaderMap	0x0000002f2699e540 {0xcccccccccccccccc {sampleInterval={m_index=??? m_type=??? m_size=??? ...} nSamps=...}, ...}	CHeaderMap *[100]
+		m_minSize	{cx=0 cy=0}	CSize
+		m_parms	{m_xLabelInterval=0.00000000 }	CXplotParms
+		m_cutoffParmsList	{m_pNodeHead=0x0000000000000000 <NULL> m_pNodeTail=0x0000000000000000 <NULL> m_nCount=0 ...}	CList<CCutoffParms,CCutoffParms &>
+		m_appliedParms	{m_xLabelInterval=0.00000000 }	CXplotParms
		m_applied	false	bool
		m_cutoffsChanged	false	bool
		m_fromAA	false	bool

void CCrossPlotSettingsDlg::AddFile(CString attr, CString file, int favorite, CHeaderMap* pHeaderMap)
{
	m_attr[m_fileCount] = attr;
	m_file[m_fileCount] = file;
	m_favorite[m_fileCount] = favorite;
	m_pHeaderMap[m_fileCount] = pHeaderMap;
	m_fileCount++;
}


m_cmbColorTemplate.GetLBText(m_densityColorBarCurSel, colorBarItemText);

m_densityColorBarCurSel = -858993460

-----

pXpParms->m_nScatterMode = 0

		DWORD theMagicBit = 0x1 << (m_viewInstance+2);	// check the bitmask to see if color has changed.
		if (pDoc->m_bNewColorFlag & theMagicBit) {
			pDoc->m_bNewColorFlag ^= theMagicBit;		// xor the bit off
			COLORREF *colorbar;
			if (pXpParms->m_nScatterMode == eATTR) {
				colorbar = pDoc->GetColorBarPtr(m_viewInstance);
			}
			else if (pXpParms->m_nScatterMode == eDENSITY) {
				colorbar = pDoc->GetDensityColorBar();
			}
			else {
				colorbar = pDoc->GetColorBar();
			}
                        // ...
                }
                

                        

2021.06.04
I. Researching and implementing solution:
                        
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1350) : atlTraceGeneral - CCrossPlotSettingsDlg::UpdateDensityColorsFromColorComboValue() colorBarItemText = Greyscale.cb
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 255, R, G, B = 255, 0, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 8447, R, G, B = 255, 32, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16639, R, G, B = 255, 64, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 24831, R, G, B = 255, 96, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 33023, R, G, B = 255, 128, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 41215, R, G, B = 255, 160, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 49407, R, G, B = 255, 192, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 57599, R, G, B = 255, 224, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65535, R, G, B = 255, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65504, R, G, B = 224, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65472, R, G, B = 192, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65440, R, G, B = 160, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65408, R, G, B = 128, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65376, R, G, B = 96, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65344, R, G, B = 64, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65312, R, G, B = 32, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 65280, R, G, B = 0, 255, 0
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 2162432, R, G, B = 0, 255, 32
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 4259584, R, G, B = 0, 255, 64
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 6356736, R, G, B = 0, 255, 96
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 8453888, R, G, B = 0, 255, 128
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 10551040, R, G, B = 0, 255, 160
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 12648192, R, G, B = 0, 255, 192
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 14745344, R, G, B = 0, 255, 224
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16776960, R, G, B = 0, 255, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16769024, R, G, B = 0, 224, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16760832, R, G, B = 0, 192, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16752640, R, G, B = 0, 160, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16744448, R, G, B = 0, 128, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16736256, R, G, B = 0, 96, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16728064, R, G, B = 0, 64, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16719872, R, G, B = 0, 32, 255
c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotsettingsdlg.cpp(1359) : atlTraceGeneral - densitybar[j] = 16711680, R, G, B = 0, 0, 255                        

                        
-----

+		m_densitybar	0x000002692b441a54 {16777215}	unsigned long *
		m_densitybar[0]	16777215	unsigned long
		m_densitybar[1]	16250871	unsigned long
		m_densitybar[2]	15790320	unsigned long
		m_densitybar[3]	15329769	unsigned long
		m_densitybar[4]	14869218	unsigned long
		m_densitybar[5]	14474460	unsigned long
		m_densitybar[6]	14013909	unsigned long

2021.06.07
I. Researching and implementing solution:

Exception thrown at 0x00007FF795B383E2 in QI-Pro.exe: 0xC0000005: Access violation reading location 0xFFFFFFFFFFFFFFFF.
                        
		m_densitybar = pDoc->GetDensityColorBar();
		for (int j = 0, i = MAXCLASS; j < DENSITYBARSIZE; j++, i++) {
			TRACE("m_densitybar[j] = %u, R, G, B = %u, %u, %u\n", m_densitybar[j], GetRValue(m_densitybar[j]), GetGValue(m_densitybar[j]), GetBValue(m_densitybar[j]));
			if (pTracePen[i] != NULL)
			{
				delete pTracePen[i];
			}
                        // ...
                }
                        
i = 70

-----

Exception thrown at 0x00007FF6332F83E2 in QI-Pro.exe: 0xC0000005: Access violation reading location 0x0000000100000008.                        
                        
pTracePen[i]
0x00000163da023d90 {...}
    CGdiObject: {m_hObject=0x0000000000000000 }

                        
-----
 
msg = 0x00000078923bc6e0 "Caught ACCESS_VIOLATION in CrossPlotView::OnDraw() tracePoint=3\nSuppress messages like this?"

-----
                        
Exception thrown at 0x00007FF7CA9C83E3 in QI-Pro.exe: 0xC0000005: Access violation reading location 0xFFFFFFFFFFFFFFFF.                        




-		pXpParms	0x000001afd65c8660 {m_xLabelInterval=0.00000000 }	CXplotParms *
		m_xLabelInterval	0.00000000	float
+		CObject	{...}	CObject
+		m_cutoffParmsList	{m_pNodeHead=0x000001afda1ddae8 {pNext=0x000001afda1ddc00 {pNext=0x000001afda1ddd18 {pNext=0x000001afda1dde30 {...} ...} ...} ...} ...}	CList<CCutoffParms,CCutoffParms &>
+		m_title	"porosity"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_strXAttr	"lambda_rho"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_strYAttr	"mu_rho"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		m_strColorAttr	"angle_stack_15"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		x1	171	int
		y1	81	int
		x2	502	int
		y2	389	int
		m_fXMin	0.00000000	float
		m_fXMax	50.0000000	float
		m_fYMin	0.00000000	float
		m_fYMax	120.000000	float
+		m_colorbarName	""	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		m_densityColorBarCurSel	0	int
		m_thirdAttrColorBarCurSel	0	int
		m_yLabelInterval	0.00000000	float
		m_xTickInterval	0.00000000	float
		m_yTickInterval	0.00000000	float
		m_dotSize	1	int
		m_nScatter	1	int
		m_nScatterMode	1	int
		m_binXsize	2.00000000	float
		m_binYsize	4.80000019	float
		m_colorBarMin	0	int
		m_colorBarMax	14733	int
		m_bFineTuneMode	0	int
		m_bFirstWinPlacement	0	int
+		m_rcParentWin	{LT(-16, 0) RB(1920, 1056)  [1936 x 1056]}	CRect
+		m_strImageFile	"C:\\QI-Pro Demo\\Horn River Demo\\Templates\\HornRiver_LMR_CrossPlot.bmp"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		m_bDisableImage	0	int
		m_bGroupMove	1	int
		m_bEnabled	1	int
		m_csiXstate	0	int
		m_csiYstate	0	int
+		rcWinFrame	{LT(818, 88) RB(1679, 747)  [861 x 659]}	CRect
+		rcWinClient	{LT(0, 0) RB(637, 562)  [637 x 562]}	CRect
+		pSegyX	0x000001afd65599b0 {m_file={hFile=0xffffffffffffffff name=""} m_nSamps=651 pBuf=0x000001afdafaf280 "J\x15" ...}	CSegy *
		segyXindex	-842150451	int
+		pSegyY	0x000001afd6564a30 {m_file={hFile=0xffffffffffffffff name=""} m_nSamps=651 pBuf=0x000001afdafd0030 "J\x15" ...}	CSegy *
		segyYindex	-842150451	int
		m_bDeleteUndoStack	0	int
		m_bNewAxisFlag	0	int
		m_densityModeUpdateFlag	0	int
+		m_classSelectState	{m_pData=0x000001afd66715b0 {1} m_nSize=50 m_nMaxSize=50 ...}	CArray<int,int>
+		m_zoneSelectState	{m_pData=0x000001afd6670f50 {0} m_nSize=50 m_nMaxSize=50 ...}	CArray<int,int>
		m_activeButton	1	int
		m_allButton	0	int
		m_attrColorBarMin	0.00000000	float
		m_attrColorBarMax	0.00000000	float
+		m_densityTable	0x000001afdfe19070 {101}	int *
-		m_arrNodes	0x000001afdff54070 {x=-11.7386932 y=30.9639740 index=8042 ...}	density_node *
		x	-11.7386932	float
		y	30.9639740	float
		index	8042	int
		ignore	0	int
		pNext	0x0000000000000000	void *
+		m_matrix	0x000001afdb155c10 {count=0 ptr=0x0000000000000000 }	matrix_node *
		m_densityTable_size	303601	int
		m_arrNodes_size	303601	int
		m_matrix_size	44238	int
                        
m_appliedParms.CutoffParmsAddTail(&newCutoff);

		CCutoffParms newCutoff = m_cutoffParmsList.GetAt(m_cutoffParmsList.FindIndex(i));
		// if its a brand new cutoff, don`t try to scale it
		if (newCutoff.lx1 != -1 || newCutoff.lx2 != -1 || newCutoff.ly1 != -1 || newCutoff.ly2 != -1) {
			if (fMin.x != fNewMin.x || fMax.x != fNewMax.x) {
				newCutoff.ScaleCutoff(origin.x, end.x, fMin.x, fMax.x, fNewMin.x, fNewMax.x, eCUT_XAXIS);
				m_appliedParms.m_bNewAxisFlag = TRUE;
			}
			if (fMin.y != fNewMin.y || fMax.y != fNewMax.y) {
				newCutoff.ScaleCutoff(origin.y, end.y, fMin.y, fMax.y, fNewMin.y, fNewMax.y, eCUT_YAXIS);
				m_appliedParms.m_bNewAxisFlag = TRUE;
			}
		}
		m_cutoffParmsList.SetAt(m_cutoffParmsList.FindIndex(i), newCutoff);

		m_appliedParms.CutoffParmsAddTail(&newCutoff);

-----

-		newCutoff	{m_strCutoffName="Impedance Cutoff\n" m_nClassBelow=0 m_nClassOutside=0 ...}	CCutoffParms
+		CObject	{...}	CObject
+		m_strCutoffName	"Impedance Cutoff\n"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		m_nClassBelow	0	int
		m_nClassOutside	0	int
		m_nClassAbove	12	int
		m_nClassInside	12	int
		m_applyTo	0	int
		m_fIntercept	58.1595116	float
		m_fSlope	-0.412269950	float
		lx1	171	int
		ly1	240	int
		lx2	502	int
		ly2	293	int
		rlx1	0.147173494	float
		rly1	0.412065446	float
		rlx2	0.825536072	float
		rly2	0.526584864	float
		m_cutoffType	0	int
		m_nGroupID	1	int
		m_bEnabled	1	int
		m_nPolyData	0	int
+		m_arrPolyData	{m_pData=0x00000155c9c8d250 {x=0 y=0} m_nSize=50 m_nMaxSize=50 ...}	CArray<CPoint,CPoint>
+		m_arrScalars	{m_pData=0x00000155ca385400 {x=-1.00000000 y=-1.00000000 } m_nSize=50 m_nMaxSize=50 ...}	CArray<CFloatPoint,CFloatPoint>
+		polyRgn	{...}	CRgn
		m_bPolyCreated	0	int
+		m_ellipse	{m_version=94 m_xOrigin=0.00000000 m_yOrigin=0.00000000 ...}	CEllipse
		m_nVersion	-858993460	int
		m_this	0xcccccccccccccccc	void *
                        
	if (m_densityTable) delete m_densityTable;
	if (m_arrNodes) delete m_arrNodes;
	if (m_matrix) delete m_matrix;

                        
-------------------------------------------------------------------------------

Only first 7 rows being colored in "Class Above/In" on the CrossPlotSettingsDlg:


BOOL CCrossPlotSettingsDlg::OnInitDialog()
{

	// ...
	
    static const int COL_CLASS_ABOVE_IN = 4;
    static const int COL_CLASS_BELOW_OUT = 5;
	
	// ...
	
	m_lstCutoffLines.InsertColumn(COL_CLASS_ABOVE_IN,"Class Above/In",	LVCFMT_LEFT, rItem.Width()*17/100);
	
	// ...
	
	for (int i = 0; i < pDoc->GetClassCount(); i++) {
		m_colorList.Add(pColorbar[i]);
		m_lstCutoffLines.SetSubitemColor(COL_CLASS_ABOVE_IN, i, pColorbar[i]);
		m_lstCutoffLines.SetSubitemColor(COL_CLASS_BELOW_OUT, i, pColorbar[i]);
		m_lstCutoffLines.SetSubitemColor(COL_APPLY, i, pColorbar[i]);
	}

	// ...

	m_lstCutoffLines.m_colorComboMap.SetAt(COL_CLASS_ABOVE_IN, &m_colorList);
	m_lstCutoffLines.m_colorComboMap.SetAt(COL_CLASS_BELOW_OUT, &m_colorList);
	
	// ...
	
	m_lstCutoffLines.InsertColumn(COL_CLASS_ABOVE_IN,"Class Above/In",	LVCFMT_LEFT, rItem.Width()*17/100);
	m_lstCutoffLines.InsertColumn(COL_CLASS_BELOW_OUT,"Class Below/Out",LVCFMT_LEFT, rItem.Width()*18/100);

	
	// ...
}	

void CCrossPlotSettingsDlg::AddCutoffToList(int index, CCutoffParms& pCutoff)
{
	char ibuf[NBUF];
	m_lstCutoffLines.InsertItem(index, _itoa(index + 1, ibuf, 10));
	m_lstCutoffLines.SetCheckboxState(index, pCutoff.m_bEnabled);
	m_lstCutoffLines.SetItem(index, COL_NAME, LVIF_TEXT, pCutoff.m_strCutoffName, 0, 0, 0, 0);
	CString txt = (pCutoff.m_cutoffType == eLINE) ? _T("Line") :
		(pCutoff.m_cutoffType == ePOLY) ? _T("Polygon") :
		(pCutoff.m_cutoffType == eELLIPSE) ? _T("Ellipse") : _T("Undefined");
	m_lstCutoffLines.SetItem(index, COL_TYPE, LVIF_TEXT, txt, 0, 0, 0, 0);
	m_lstCutoffLines.SetItem(index, COL_CLASS_ABOVE_IN, LVIF_TEXT, _itoa(pCutoff.m_nClassAbove, ibuf, 10), 0, 0, 0, 0);
	m_lstCutoffLines.SetItem(index, COL_CLASS_BELOW_OUT, LVIF_TEXT, _itoa(pCutoff.m_nClassBelow, ibuf, 10), 0, 0, 0, 0);
	m_lstCutoffLines.SetItem(index, COL_APPLY, LVIF_TEXT, _itoa(pCutoff.m_applyTo, ibuf, 10), 0, 0, 0, 0);
	m_lstCutoffLines.SetItem(index, COL_GROUP, LVIF_TEXT, _itoa(pCutoff.m_nGroupID, ibuf, 10), 0, 0, 0, 0);

	COLORREF color = m_colorList[pCutoff.m_nClassAbove];
	m_lstCutoffLines.SetSubitemColor(COL_CLASS_ABOVE_IN, index, color);
	color = m_colorList[pCutoff.m_nClassBelow];
	m_lstCutoffLines.SetSubitemColor(COL_CLASS_BELOW_OUT, index, color);
	color = m_colorList[pCutoff.m_applyTo];
	m_lstCutoffLines.SetSubitemColor(COL_APPLY, index, color);
}

m_parms.m_strColorAttr = "angle_stack_15"

	else {
		m_attrColorBarMin = m_parms.m_attrColorBarMin;
		m_attrColorBarMax = m_parms.m_attrColorBarMax;
	}

	//if (isClassColors) {
		colorBarItemText = DEFAULT_CLASS_COLORBAR;
	//}
	//else {
		//m_cmbColorTemplate.GetLBText(m_cmbColorTemplate.GetCurSel(), colorBarItemText);
	//}
	CArray<COLORREF> colorbarColors;
	Utilities::LoadColorBar(colorBarItemText, pDoc->GetProjectPath(), colorbarColors, pDoc->GetClassCount());

        
-----

			CStringArray templateFiles;
			Utilities::GetColorbarTemplateNames(templateFiles);
			CString selectedTemplate = templateFiles[pXpParms->m_thirdAttrColorBarCurSel];
			CArray<COLORREF> colorbarColors;
			Utilities::LoadColorBar(selectedTemplate, pDoc->GetProjectPath(), colorbarColors, pDoc->GetClassCount());

                        
		// allocate colors for the density plots
		COLORREF *densitybar = pDoc->GetDensityColorBar();
		for (int j = 0, i = MAXCLASS; j < DENSITYBARSIZE; j++, i++) {
			//TRACE("densitybar[j] = %u, R, G, B = %u, %u, %u\n", densitybar[j], GetRValue(densitybar[j]), GetGValue(densitybar[j]), GetBValue(densitybar[j]));

			try {
				if (pTracePen != nullptr && pTracePen[i])
				{
					delete pTracePen[i];
				}
			}
			catch (std::exception const& e) {
				TRACE("CCrossPlotView::DoOnDraw error = %s", e.what());
			}
			pTracePen[i] = new CPen(PS_SOLID, 1, densitybar[j]);
			if (!pTracePen[i]) {
				AfxMessageBox("Error allocating Trace Pen array");
				return;
			}

			try {
				if (pTraceBrush != nullptr && pTraceBrush[i])
				{
					delete pTraceBrush[i];
				}
			}
			catch (std::exception const& e) {
				TRACE("CCrossPlotView::DoOnDraw error = %s", e.what());
			}
			pTraceBrush[i] = new CBrush(densitybar[j]);
			if (!pTraceBrush[i]) {
				AfxMessageBox("Error allocating Trace Brush array");
				return;
			}
		}

                
-----

	try {
		DWORD theMagicBit = 0x1 << (m_viewInstance+2);	// check the bitmask to see if color has changed.
		if (pDoc->m_bNewColorFlag & theMagicBit) {
			pDoc->m_bNewColorFlag ^= theMagicBit;		// xor the bit off
			COLORREF* colorbar;
			CArray<COLORREF> colorbarColors;
			if (pXpParms->m_nScatterMode == eATTR) {
				CStringArray templateFiles;
				Utilities::GetColorbarTemplateNames(templateFiles);
				CString selectedTemplate = templateFiles[pXpParms->m_thirdAttrColorBarCurSel];
				Utilities::LoadColorBar(selectedTemplate, pDoc->GetProjectPath(), colorbarColors, pDoc->GetClassCount());
				colorbar = &colorbarColors[0];
			}
			else if (pXpParms->m_nScatterMode == eDENSITY) {
				colorbar = pDoc->GetDensityColorBar();
			}
			else {
				colorbar = pDoc->GetColorBar();
			}

			for (int i = 0; i < classCount; i++) {
				if (pTracePen[i] != NULL) delete pTracePen[i];
				TRACE("colorbar[i] = %u, R, G, B = %u, %u, %u\n", colorbar[i], GetRValue(colorbar[i]), GetGValue(colorbar[i]), GetBValue(colorbar[i]));
				pTracePen[i] = new CPen(PS_SOLID, 1, colorbar[i]);
				if (!pTracePen[i]) {
					AfxMessageBox("Error allocating Trace Pen array");
					return;
				}
				if (pTraceBrush[i] != NULL) delete pTraceBrush[i];
				pTraceBrush[i] = new CBrush(colorbar[i]);
				if (!pTraceBrush[i]) {
					AfxMessageBox("Error allocating Trace Brush array");
					return;
				}
			}
		}
                

				CStringArray templateFiles;
				Utilities::GetColorbarTemplateNames(templateFiles);
				CString selectedTemplate = templateFiles[pXpParms->m_thirdAttrColorBarCurSel];
				Utilities::LoadColorBar(selectedTemplate, pDoc->GetProjectPath(), colorbarColors, pDoc->GetClassCount());
				colorbar = &colorbarColors[0];

                
-----

			CArray<COLORREF> colorbarColors;
			Utilities::GetColorBarColors(pDoc->GetProjectPath(), colorbarColors, pDoc->GetClassCount(), pXpParms->m_thirdAttrColorBarCurSel);

                
		m_colorBarMax	14733	int



2021.06.09
I. Researching and implementing solution:  

-Updating class colors in Xplot Settings Dlg when user changes the main color bar in CColorBarFrame:

	m_classTitle.Create(_T("Class Filter:"), WS_CHILD|WS_VISIBLE, 
		CRect(PANESIDE, y, winRect.Width()-PANESIDE, y+PANEROW), pWnd);                
                
	m_classListBox.AddImage(&m_dim);
	m_classListBox.AddImage(&m_bright);
	m_classListBox.SetColorbar(pDoc->GetColorBar());

                
-----

void CColorBarCombo::SetTemplatesProjectDirectory(CString directory, bool addCustomUserTemplates)

			m_colorbarComboWnd.SetTemplatesProjectDirectory(m_projectDirectory);

	m_logList.SetProjectDirectory(m_projectDirectory);
	m_logList.SetProjectName(m_projectName);

	pDoc->GetColorBarComboPointer()->SetProjectName(pDoc->GetProjectName());
	pDoc->GetColorBarComboPointer()->SetTemplatesProjectDirectory(pDoc->GetProjectFullPath());

const CString projectRootDirectory = m_tempPathName.Left(projectsPos);

projectRootDirectory = "C:\\QI-Pro Demo\\Horn River Demo\\"

//PathFileExists(inputFilePath)

                
userColorBarFilesProjectDir
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete"

-----

ovoid CIMACDoc::SaveClassColorbar()
{
	const CString userColorBarFiles = "UserColorBarFiles";
	const CString projects = "Projects";
	const int projectsPos = m_tempPathName.Find(projects);
	const CString colorBarTemplateDirectory =
		"\\" + m_tempPathName.Mid(m_tempPathName.ReverseFind('\\') + 1);
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	const CString userColorBarFilesDir = m_tempPathName.Left(projectsPos) + projects + "\\" + userColorBarFiles;
	const CString userColorBarFilesProjectDir = userColorBarFilesDir + colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);
	const CString classColorsPath = userColorBarFilesProjectDir + "\\" + DEFAULT_CLASS_COLORBAR;

	try {
		if (projectsPos != -1) {
			if (!PathFileExists(userColorBarFilesDir)) {
				if (CreateDirectory(userColorBarFilesDir, NULL)) {
					if (!PathFileExists(userColorBarFilesProjectDir)) {
						if (CreateDirectory(userColorBarFilesProjectDir, NULL)) {
							ColorBarExportOverwrite(classColorsPath);
						}
					}
				}
			}
			else if (PathFileExists(userColorBarFilesDir) &&
				PathFileExists(userColorBarFilesProjectDir)) {
				ColorBarExportOverwrite(classColorsPath);
			}
		}
	}
	catch (std::exception ex) {
		AfxMessageBox(ex.what());
	}
}                

                
pDoc->GetProjectFullPath()

                
userColorBarFilesProjectDir
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete"

inputFilePath
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\Rainbow.cb"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\Rainbow.cb"

inputFilePath
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\ClassColors.cb"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\ClassColors.cb"

inputFilePath
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\Rainbow.cb"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\Rainbow.cb"

inputFilePath
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\ClassColors.cb"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\ClassColors.cb"

                
                
    int GetColorBarComboCurSel() { return m_cmbColorCurSel; }
    void SetColorBarComboCurSel(int index) { m_cmbColorCurSel = index; }

                
void CColorBarView::OnLButtonUp(UINT nFlags, CPoint point) 
{
	m_lbuttondown=FALSE;
	CIMACDoc* pDoc = GetDocument();
	BOOL isColorbarModified = FALSE;
	
	// The colorbar
	if (point.x > m_rcColorBar.left &&
		point.x < (m_rcColorBar.right + 80) &&
		point.y > m_rcColorBar.top &&
		point.y < m_rcColorBar.bottom)
	{
		isColorbarModified = TRUE;
		COLORREF colorbar[MAXCBSIZE];
		CStringArray arrNames;
		COLORREF* pColorbar = GetColorBarPtr();
		
		arrNames.SetSize(MAXCLASS);
		CClassNameDlg dlg(this);
		dlg.m_pDoc = pDoc;

		// Exchange color bar items due to drag action
		colorbar[m_colorbarIndex] = pColorbar[m_colorbarIndexMouseMove];
		arrNames[m_colorbarIndex] = pDoc->GetClssName(m_colorbarIndexMouseMove);

		colorbar[m_colorbarIndexMouseMove] = pColorbar[m_colorbarIndex];
		arrNames[m_colorbarIndexMouseMove] = pDoc->GetClssName(m_colorbarIndex);

		pColorbar[m_colorbarIndex] = colorbar[m_colorbarIndex];
		pDoc->SetClassName(m_colorbarIndex, arrNames[m_colorbarIndex]);

		pColorbar[m_colorbarIndexMouseMove] = colorbar[m_colorbarIndexMouseMove];
		pDoc->SetClassName(m_colorbarIndexMouseMove, arrNames[m_colorbarIndexMouseMove]);

		dlg.m_arrNames[m_colorbarIndex] = arrNames[m_colorbarIndex];
		dlg.m_arrNames[m_colorbarIndexMouseMove] = arrNames[m_colorbarIndexMouseMove];
	}
	ClipCursor(NULL);

	if (isColorbarModified == TRUE) {
		Invalidate(FALSE);
		pDoc->SetUpdateXplotPaneFlagsAll(TRUE);
		pDoc->m_bNewColorFlag = 0xffffffff;
		pDoc->UpdateViews();
	}
}

                
2021.06.10
I. Researching and implementing solution:  


'QI-Pro.exe' (Win32): Loaded 'C:\Windows\System32\wtsapi32.dll'. Symbols loaded.
onecore\com\combase\dcomrem\resolver.cxx(2299)\combase.dll!00007FFAB80B206D: (caller: 00007FFAB80B4F4E) ReturnHr(1) tid(d5d0) 80070005 Access is denied.
onecore\com\combase\dcomrem\resolver.cxx(2507)\combase.dll!00007FFAB80B4F76: (caller: 00007FFAB80B1A05) ReturnHr(2) tid(d5d0) 80070005 Access is denied.
The thread 0xd5d0 has exited with code 0 (0x0).
'QI-Pro.exe' (Win32): Loaded 'C:\Windows\System32\UIAutomationCore.dll'. Symbols loaded.                

-----

void CColorBarView::OnCbSave() 
{	
	CString fname, fsaveName;
	CString fileFilter = "Colorbar Files (*.cb)|*.cb|All Files (*.*)|*.*|";
	CIMACDoc* pDoc = GetDocument();	

	CFileDialog fileDialog(FALSE, "cb", NULL, OFN_HIDEREADONLY|OFN_PATHMUSTEXIST, fileFilter, this);
	CString projectDirectory = pDoc->GetProjectFullPath();
	const CString userColorBarFiles = "UserColorBarFiles";
	const CString projects = "Projects";
	const int projectsPos = projectDirectory.Find(projects);
	const CString colorBarTemplateDirectory =
		"\\" + projectDirectory.Mid(projectDirectory.ReverseFind('\\') + 1);
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	const CString userColorBarFilesDir = projectDirectory.Left(projectsPos) + projects + "\\" + userColorBarFiles;
	const CString userColorBarFilesProjectDir = userColorBarFilesDir + colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);
	fileDialog.m_ofn.lpstrInitialDir = userColorBarFilesProjectDir;
	
	if (fileDialog.DoModal() == IDOK)
	{
		fname = fileDialog.GetPathName();
        pDoc->ColorBarExport(fname);

		// Get directory for for color bar templates
		const CString appDataDir = Utilities::GetAppDataDirectory();
		const CString resourcesDirectory = appDataDir + "ColorBarTemplates";
		const int fnameExtPos = fname.ReverseFind('.');
		CString ext = fname.Mid(fnameExtPos, 4);
		fsaveName = fname.Mid(fname.ReverseFind('\\') + 1);
		int fSaveNameExtPos = fsaveName.ReverseFind('.');
		CString rootName = fsaveName.Left(fSaveNameExtPos);

		//Put *.cb file in project color bar dir 
		CopyFile(fname,
			userColorBarFilesProjectDir + fsaveName, FALSE);
	}	
}
                
void CDrawStatic::OnLButtonDown(UINT nFlags, CPoint point)
{
	CPaintDC dc(this);
	CRect rcClient;
	GetClientRect( &rcClient );

	COLORREF colorClick;
	if (CColorBarView::DoLButtonClick(&dc, point, rcClient, m_rcSlider, m_rcColorBar, m_lbuttondown, m_intensity, colorClick)) {
		*m_pColor = colorClick;
		 m_pStatic->m_selectedColor = colorClick;
		 m_pStatic->Invalidate(FALSE);
	}

	Invalidate(FALSE);
}

	static BOOL DoLButtonClick(CDC *pDC, CPoint point, CRect rcClient, CRect rcSlider, CRect rcColorBar, 
		BOOL &m_lbuttonDown, float intensity, COLORREF &colorclick);
                
	static BOOL DoLButtonClick(CDC* pDC, CPoint point, CRect rcClient, CRect rcSlider, CRect rcColorBar,
		BOOL& m_lbuttonDown, float intensity, COLORREF& colorclick);

                
void CColorBarView::DoLButtonDown (CDC *pDC, CPoint point, CRect rcClient, CRect rcSlider, CRect rcColorBar, 
	BOOL &m_lbuttondown, float m_intensity, int m_palletIndex, int &m_colorbarIndex)
{
	int dx, xOrigin, yOrigin;

	CIMACDoc *pDoc = CIMACApp::GetDocument();
	if (pDoc == NULL) return;
	
	BOOL bThirdAttribute = pDoc->IsThirdAttributeMode(pDoc->GetViewInstance());
	GetColorbarBaseData(rcClient, dx, xOrigin, yOrigin);

	int cbSize = GetColorBarSize();
	COLORREF *pColorbar = GetColorBarPtr();

	// intensity slider
	int iy = (int) ((float)(rcSlider.bottom - rcSlider.top) * (1.0-m_intensity) + 0.5) + rcSlider.top;
	if (point.x > rcSlider.left &&
		point.y > iy-5 &&
		point.y < iy+5) 
	{
		m_lbuttondown = TRUE;
		CRect windowRect, clipRect;
		clipRect = rcSlider;
		pDC->GetWindow()->ClientToScreen(clipRect);
		ClipCursor(clipRect);
	}

	// the colorbar
	if (point.x > rcColorBar.left &&
		point.x < (rcColorBar.right+80) && 
		point.y > rcColorBar.top &&
		point.y < rcColorBar.bottom )
	{
		m_colorbarIndex =(int) ( (float)(point.y-rcColorBar.top) /
			(float)(rcColorBar.bottom-rcColorBar.top) * cbSize);
		if (bThirdAttribute) m_colorbarIndex = cbSize - 1 - m_colorbarIndex;
	}

	// the pallet
	int red, grn, blu;
	int dist = (int)(sqrt((float)((point.x-xOrigin)*(point.x-xOrigin))  +
			              (float)((point.y-yOrigin)*(point.y-yOrigin))) /dx ) - 1;
	if (dist < NCOL && m_colorbarIndex >= 0) {
		if (m_palletIndex >= 0) {
			COLORREF *pallet = pDoc->GetPallet();
			COLORREF pixelColor = pallet[m_palletIndex];
			red = (int) (GetRValue(pixelColor) * m_intensity);
			grn = (int) (GetGValue(pixelColor) * m_intensity);
			blu = (int) (GetBValue(pixelColor) * m_intensity);
		} else {
			// the center greyshade was selected
			red = (int) (255 * m_intensity);
			grn = (int) (255 * m_intensity);
			blu = (int) (255 * m_intensity);
		}
		pColorbar[m_colorbarIndex] = RGB(red, grn, blu);

		// Final legend color update steps
		pDoc->m_bNewColorFlag=0xffffffff;
		pDoc->SendColorbarToHeadwave();
		pDoc->UpdateViews();
	}
}

                
		pColorbar[m_colorbarIndex]	8388863	unsigned long

			if (colorbarIndex >= 0 && colorbarIndex < m_colorBarTemplateFiles.GetCount()) {
				const CString colorBarTemplateFile = m_colorBarTemplateFiles.GetAt(colorbarIndex);
				if (m_colorBarColors[colorbarIndex].GetCount() == 0) {
					Utilities::LoadColorBar(colorBarTemplateFile, m_projectDirectory, m_colorBarColors[colorbarIndex], m_classCount);
				}
				CArray<COLORREF>& colorbarColors = m_colorBarColors[colorbarIndex];

				for (int i = 0; i < colorbarColors.GetCount() && i < m_classCount; i++) {
					const COLORREF color = colorbarColors[i];
					dc.FillSolidRect(rBlockRect.left + i * colorWidth, rBlockRect.top, colorWidth, rBlockRect.Height(), color);
				}
			}

                
pDoc->SetColorBarComboPointer(&m_wndToolBar.m_cmbColorTemplate);

    CColorBarCombo* GetColorBarComboPointer() { return m_cmbColorTemplate; }
    int GetColorBarComboCurSel() { return m_cmbColorCurSel; }

	pDoc->SaveClassColorbar();
	pDoc->GetColorBarComboPointer()->SetMaxColors(MAXCLASS);
	pDoc->GetColorBarComboPointer()->SetClassCount(pDoc->GetClassCount());
	pDoc->GetColorBarComboPointer()->SetProjectName(pDoc->GetProjectName());
	pDoc->GetColorBarComboPointer()->SetTemplatesProjectDirectory(pDoc->GetProjectFullPath());

                
GetSelectedColorbarFile

                CColorBarCombo* pColorBarCombo = pDoc->GetColorBarComboPointer();
                
		fsaveName = fname.Mid(fname.ReverseFind('\\') + 1);
		int fSaveNameExtPos = fsaveName.ReverseFind('.');
		rootName = fsaveName.Left(fSaveNameExtPos);
                
                // ...
                
		// Add value to color bar template combobox
		pColorBarCombo->AddColorBarTemplateFile(rootName + ".cb");

		// Select the new file in the combobox
		int nDex = pColorBarCombo->FindStringExact(0, rootName + ".cb");
		if (nDex != CB_ERR)
		{
			pColorBarCombo->SetCurSel(nDex);
			::SendMessage(pColorBarCombo->GetParentFrame()->GetSafeHwnd(), WM_COMMAND,
				MAKEWPARAM(pColorBarCombo->GetDlgCtrlID(), CBN_SELCHANGE), reinterpret_cast<LPARAM>(pColorBarCombo->GetSafeHwnd()));
		}

                
void SetClassName(int i, CString name) { m_arrClassNames.SetAt(i, name); }

pDoc->GetClssName(k)
""
    ATL::CSimpleStringT<char,1>: ""
pDoc->GetClssName(0)
""
    ATL::CSimpleStringT<char,1>: ""
pDoc->GetClssName(1)
""
    ATL::CSimpleStringT<char,1>: ""
pDoc->GetClssName(2)
""
    ATL::CSimpleStringT<char,1>: ""


	CStringArray arrNames;
	arrNames.SetSize(MAXCLASS);                
                
				else if (i < cbSelectedIndex) {
					colorbar[i] = pColorbar[i];
					arrNames[i] = pDoc->GetClssName(i);
				}

CIMACDoc* pDoc = GetDocument();                

		for (int i = 0; i < cbSize; i++) {
			if (point.y > ftop && point.y < fbottom) {
				cbSelectedIndex = i;
				break;
			}
			ftop += stepSize;
			fbottom += stepSize;
		}

                
2021.06.11
I. Researching and implementing solution:

2021.06.14
I. Researching and implementing solution:                  

                
netapi32.lib;Wbemuuid.lib;dhcpcsvc.lib;userenv.lib;libredir_std.lib;legacy_stdio_definitions.lib;lm_new.obj;libcrvs.lib;libsb.lib;lmgr.lib;libnoact.lib;lmgr_dongle_stub.lib;cblas.lib;gsl.lib;seiswared.lib$(SolutionDir)..\SeisWare SDK\10.5  BETA\cpp\src\SeisWare_VS2017\x64\DLLDebug;$(SolutionDir)..\gsl_2_4_msvc2015_64_r1\msvc2015_64\lib\gsl;$(SolutionDir)..\flexlm-x64\lib;$(SolutionDir)NativeUnitTests\Libraries;..\$(Configuration);%(AdditionalLibraryDirectories)

Linker -> "Additional Dependencies":                
netapi32.lib;Wbemuuid.lib;dhcpcsvc.lib;userenv.lib;libredir_std.lib;legacy_stdio_definitions.lib;lm_new.obj;libcrvs.lib;libsb.lib;lmgr.lib;libnoact.lib;lmgr_dongle_stub.lib;cblas.lib;gsl.lib;seiswared.lib

Linker -> "Command Line":
/OUT:"C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\x64\Debug-lib-build\NativeUnitTests.exe" /MANIFEST /LTCG:incremental /NXCOMPAT /PDB:"C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\x64\Debug-lib-build\NativeUnitTests.pdb" /DYNAMICBASE "netapi32.lib" "Wbemuuid.lib" "dhcpcsvc.lib" "userenv.lib" "libredir_std.lib" "legacy_stdio_definitions.lib" "lm_new.obj" "libcrvs.lib" "libsb.lib" "lmgr.lib" "libnoact.lib" "lmgr_dongle_stub.lib" "cblas.lib" "gsl.lib" "seiswared.lib" "C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\QI-Pro\x64\Debug-lib-build\QI-Pro.lib" /DEBUG /MACHINE:X64 /NODEFAULTLIB:"LIBCMT.lib" /PGD:"C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\x64\Debug-lib-build\NativeUnitTests.pgd" /SUBSYSTEM:CONSOLE /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /ManifestFile:"x64\Debug-lib-build\NativeUnitTests.exe.intermediate.manifest" /ERRORREPORT:PROMPT /NOLOGO /LIBPATH:"C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\..\SeisWare SDK\10.5  BETA\cpp\src\SeisWare_VS2017\x64\DLLDebug" /LIBPATH:"C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\..\gsl_2_4_msvc2015_64_r1\msvc2015_64\lib\gsl" /LIBPATH:"C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\..\flexlm-x64\lib" /LIBPATH:"C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\NativeUnitTests\Libraries" /LIBPATH:"..\Debug-lib-build" /TLBID:1
                
--------------------------------------------------------------------------------

Severity	Code	Description	Project	File	Line	Suppression State
Error	MSB3073	The command "xcopy C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\\C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\x64\Debug-lib-build\ C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\NativeUnitTests\Libraries /S /Y && xcopy C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\NativeUnitTests\Libraries C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\x64\Debug-lib-build\ /S /Y
:VCEnd" exited with code 4.	NativeUnitTests	C:\Program Files (x86)\Microsoft Visual Studio\2017\BuildTools\Common7\IDE\VC\VCTargets\Microsoft.CppCommon.targets	128	


                
xcopy $(SolutionDir)..\common\SortStringArray.cpp $(ProjectDir) /S /Y && xcopy $(SolutionDir)..\common\SortStringArray.h $(ProjectDir) /S /Y && xcopy $(TargetDir) $(SolutionDir)NativeUnitTests\Libraries /S /Y && xcopy $(SolutionDir)NativeUnitTests\Libraries $(OutDir) /S /Y

                
https://jeffpar.github.io/kbarchive/kb/120/Q120961/

                
-----

Severity	Code	Description	Project	File	Line	Suppression State
Error	LNK2019	unresolved external symbol "public: void __cdecl CSortStringArray::Sort(void)" (?Sort@CSortStringArray@@QEAAXXZ) referenced in function "public: void __cdecl CColorBarView::DoLButtonDown(class CDC *,class CPoint,class CRect,class CRect,class CRect,int &,float,int,int &)" (?DoLButtonDown@CColorBarView@@QEAAXPEAVCDC@@VCPoint@@VCRect@@22AEAHMH3@Z)	IMAC	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ColorBarView.obj	1	


					// Update combobox with newly created user file
					pColorBarCombo->AddColorBarTemplateFile(newUserColorFile);
					CSortStringArray& colorBarTemplateFiles = pColorBarCombo->GetColorBarTemplateFiles();
					CSortStringArray::Sort(colorBarTemplateFiles);

					for (int l = 0; l < colorBarTemplateFiles.GetCount(); l++) 	{
						if (colorBarTemplateFiles[l] == newUserColorFile) {
							pColorBarCombo->SetCurSel(l);
						}
					}

userColorBarFiles                

fileOutput
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\MagmaUserFile.cb"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\MagmaUserFile.cb"

			if (saItems.GetCount() >= 4) {
				for (int j = 3; j < saItems.GetCount(); j++) {
					className = saItems[j] + " ";
				}
			}

CString className = Utilities::m_classNames[k];

					if (selectedColorBarValue.Find(userFile) == -1) {
						pColorBarCombo->AddColorBarTemplateFile(newUserColorFile);
					}

Where:
userFile = "UserFile"

-----

					// Update combobox with newly created user file
					if (selectedColorBarValue.Find(userFile) == -1) {
						pColorBarCombo->AddColorBarTemplateFile(newUserColorFile);
					}
					CSortStringArray& colorBarTemplateFiles = pColorBarCombo->GetColorBarTemplateFiles();
					CSortStringArray::Sort(colorBarTemplateFiles);
					pColorBarCombo->SetCurSel(colorBarTemplateFiles.GetCount() - 1);
                
xcopy $(SolutionDir)..\common\SortStringArray.cpp $(ProjectDir) /S /Y && xcopy $(SolutionDir)..\common\SortStringArray.h $(ProjectDir) /S /Y &&

                
l = 3

                
resourcesDirectory = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates"

2021.06.15
I. Researching and implementing solution:                  
                
	else {
		const int classColorsIndex = m_wndToolBar.m_cmbColorTemplate.FindString(0, DEFAULT_CLASS_COLORBAR);

		if (classColorsIndex != -1) {
			m_wndToolBar.m_cmbColorTemplate.SetCurSel(classColorsIndex);
			pDoc->SetColorBarComboCurSel(classColorsIndex);
		}
		else {
			m_wndToolBar.m_cmbColorTemplate.SetCurSel(0);
			pDoc->SetColorBarComboCurSel(0);
		}
	}

                
colorBarTemplateFile = "Spectral.cb"

		const CString rootName = colorBarTemplateFile.Left(extensionPos);
		const CString templateInputFilePath = resourcesDirectory + "\\" + rootName + ".txt";

extensionPos = 8                
colorBarTemplateFile = "Spectral.cb"
rootName = "Spectral.cb"                
resourcesDirectory = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates"

+		msg	"Cannot open file C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\.txt"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>


		else if (pXpParms->m_nScatterMode == eATTR) {
			m_tracePoint = 60;
			// display the third attribute color bar
			int colorBarSize = pDoc->GetColorBarSize(m_viewInstance);
			CArray<COLORREF> colorbarColors;
			Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, pDoc->GetClassCount(), pXpParms->m_thirdAttrColorBarCurSel);
			
			pDC->SelectObject(m_pNormPen);
			CRect rcBar;
			rcBar.left = rcClient.right - RIGHTBORDER + DEN_WIDTH;
			rcBar.right = rcBar.left + DEN_WIDTH;
			rcBar.top = 2 * BORDER;
			rcBar.bottom = rcClient.bottom - 2 * BORDER;
			int inc = (rcBar.bottom - rcBar.top) / colorBarSize;
			rcBar.bottom = rcBar.top + (colorBarSize*inc);
			
			CRect rcPlot = rcBar;
			rcPlot.bottom = rcPlot.top + inc;
			for (int i = colorBarSize; i>0; i--) {
				pDC->FillRect(rcPlot, &CBrush(colorbarColors[i - 1]));
				rcPlot.top += inc;
				rcPlot.bottom += inc;
			}

selectedTemplate = "Magma.cb"

		pDoc->GetClassCount()	10	int

colorBarSize = 21

-> Solution: changed:

Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, pDoc->GetClassCount(), pXpParms->m_thirdAttrColorBarCurSel);
                        
To:                        

Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, colorBarSize, pXpParms->m_thirdAttrColorBarCurSel);
                        
-----
                        
pXpParms->m_thirdAttrColorBarCurSel = 13                        

-		templateInputFilePath	"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\BlueRed.txt"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>

                templateInputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Baha.txt"                        
                templateInputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\BlueRed.txt"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\BlueRed.txt"

                templateInputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Greyscale.txt"
    ATL::CSimpleStringT<char,1>: "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Greyscale.txt"
                        
--------------------------------------------------------------------------------

				Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, colorbarColors.GetCount(), pXpParms->m_thirdAttrColorBarCurSel);

                        
2021.06.16
I. Researching and implementing solution:                  

 COLORREF * GetColorBar() { return m_colorbar; }
    COLORREF * GetPallet() { return m_pallet; }
    COLORREF * GetDensityColorBar() { return m_densitybar; }
    COLORREF * GetColorBarPtr();
    COLORREF * GetColorBarPtr(int viewInstance);                        

-----

bool Utilities::GetColorBarColors(CString projectDirectory, CArray<COLORREF>& colorbarColors, int classCount, int templateIndex):
		const int extensionPos = colorBarTemplateFile.Find(".");
		const CString rootName = colorBarTemplateFile.Left(extensionPos);
		const CString templateInputFilePath = resourcesDirectory + "\\" + rootName + ".txt";

Where:
+		colorBarTemplateFile	"Parula.cb"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		extensionPos	6	const int
+		resourcesDirectory	"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		rootName	"Parula.cb"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		templateInputFilePath	"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\.txt"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>

                        
                        
See https://forums.codeguru.com/showthread.php?196317-If-I-have-a-filename-in-a-CString-var-ho-can-I-remove-the-file-ext

-----

If loaded from Horn river project "Laurie complete.prj":

bool Utilities::GetColorBarColors(CString projectDirectory, CArray<COLORREF>& colorbarColors, int classCount, int templateIndex):
		const int extensionPos = colorBarTemplateFile.Find(".");
		const CString rootName = colorBarTemplateFile.Left(extensionPos);
		const CString templateInputFilePath = resourcesDirectory + "\\" + rootName + ".txt";
                        
+		colorBarTemplateFile	"Parula.cb"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		extensionPos	6	const int
+		resourcesDirectory	"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		rootName	"Parula"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
+		templateInputFilePath	"C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\Parula.txt"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>

                        
-----

templateInputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\.txt"

templateInputFilePath = "C:\\Users\\moorer\\AppData\\Roaming\\Sound QI\\QI-Pro\\ColorBarTemplates\\.txt"

-----

tempPath = "C:\\Users\\moorer\\AppData\\Local\\Temp\\GUoM1gKPU4g9CnK"

                        
"C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\ClassColors.cb"
    ATL::CSimpleStringT<char,1>: "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete\\ClassColors.cb"

-----

line 1039:
Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, colorBarSize, pXpParms->m_thirdAttrColorBarCurSel);

                        
bool Utilities::GetColorBarColors(CString projectDirectory, CArray<COLORREF>& colorbarColors, int classCount, int templateIndex)
{
	bool returnCode = TRUE;

	try {
		CStringArray templateFiles;
		GetColorbarTemplateNames(templateFiles);
		CString selectedTemplate = templateFiles[templateIndex];
		LoadColorBar(selectedTemplate, projectDirectory, colorbarColors, classCount);
	}
	catch (CException& ex) {
		TCHAR   szCause[255];
		ex.GetErrorMessage(szCause, 255);
		AfxMessageBox(szCause);

		return FALSE;
	}

	return returnCode;
}

2021.06.17
I. Researching and implementing solution:                                          

void Utilities::GetUserColorbarNames(CStringArray& files, CString projectDirectory)
{
	const CString userColorBarFiles = "UserColorBarFiles";
	const CString projects = "Projects";
	const int projectsPos = projectDirectory.Find(projects);
	const CString colorBarTemplateDirectory =
		"\\" + projectDirectory.Mid(projectDirectory.ReverseFind('\\') + 1);
	const int colorBarTemplateDirectoryExtPos = colorBarTemplateDirectory.ReverseFind('.');
	const CString userColorBarFilesDir = projectDirectory.Left(projectsPos) + projects + "\\" + userColorBarFiles;
	const CString userColorBarFilesProjectDir = userColorBarFilesDir + colorBarTemplateDirectory.Left(colorBarTemplateDirectoryExtPos);

	if (projectsPos != -1) {
		GetAllFileNames(files, userColorBarFilesProjectDir, ".cb");
	}
}

Where:                        
                        
projectDirectory = "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj"
userColorBarFilesProjectDir = "C:\\QI-Pro Demo\\Horn River Demo\\Projects\\UserColorBarFiles\\QI-Pro Laurie complete"
                        
-----

	// initialize the cutoff line list box
	CRect rItem;
	pDoc->SetColorbarOpenedFromCrossplotSettings(TRUE);
	colorBarItemText = DEFAULT_CLASS_COLORBAR;
	CArray<COLORREF> colorbarColors;
	Utilities::LoadColorBar(colorBarItemText, pDoc->GetProjectFullPath(), colorbarColors, pDoc->GetClassCount(), pDoc->GetColorBarPtr());
	m_lstCutoffLines.ResetSubItemColorArray();
	m_colorList.RemoveAll();
	COLORREF whiteColor = RGB(255, 255, 255);
	
	for (int i = 0; i < pDoc->GetClassCount(); i++) {
		m_colorList.Add(colorbarColors[i]);
		m_lstCutoffLines.SetSubitemColor(COL_CLASS_ABOVE_IN, i, colorbarColors[i]);
		m_lstCutoffLines.SetSubitemColor(COL_CLASS_BELOW_OUT, i, colorbarColors[i]);
		m_lstCutoffLines.SetSubitemColor(COL_APPLY, i, colorbarColors[i]);
	}

Where:

colorbarColors = {m_pData=0x00000287ceb90390 {255} m_nSize=21 m_nMaxSize=21 ...}

i = 21

--------------------------------------------------------------------------------

-Receiving "Debug Assertion Failed! Program: ...\OSI\QI-Pro\x64\Debug\QI-Pro.exe File: ...\include\afxtempl.h Line: 320" on "pDC->FillRect" from 1034ff in CrossPlotView.cpp:
                        
		else if (pXpParms->m_nScatterMode == eATTR) {
			m_tracePoint = 60;
			// display the third attribute color bar
			int colorBarSize = pDoc->GetColorBarSize(m_viewInstance);
			CArray<COLORREF> colorbarColors;
			Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, colorBarSize, pXpParms->m_thirdAttrColorBarCurSel);
			
			pDC->SelectObject(m_pNormPen);
			CRect rcBar;
			rcBar.left = rcClient.right - RIGHTBORDER + DEN_WIDTH;
			rcBar.right = rcBar.left + DEN_WIDTH;
			rcBar.top = 2 * BORDER;
			rcBar.bottom = rcClient.bottom - 2 * BORDER;
			int inc = (rcBar.bottom - rcBar.top) / colorBarSize;
			rcBar.bottom = rcBar.top + (colorBarSize*inc);
			
			CRect rcPlot = rcBar;
			rcPlot.bottom = rcPlot.top + inc;
			for (int i = colorBarSize; i>0; i--) {
				pDC->FillRect(rcPlot, &CBrush(colorbarColors[i - 1]));
				rcPlot.top += inc;
				rcPlot.bottom += inc;
			}

                        
Where Line 320 is the ASSERT:

template<class TYPE, class ARG_TYPE>
AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
{
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
	if(nIndex >= 0 && nIndex < m_nSize)
		return m_pData[nIndex];
	AfxThrowInvalidArgException();
}                        

-> Solution:                         

Change:

           int colorBarSize = pDoc->GetColorBarSize(m_viewInstance);
            CArray<COLORREF> colorbarColors;
            Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, colorBarSize, pXpParms->m_thirdAttrColorBarCurSel);

To:

            CArray<COLORREF> colorbarColors;
            Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), colorbarColors, 0, pXpParms->m_thirdAttrColorBarCurSel);
            int colorBarSize = (int) colorbarColors.GetCount();

See full Teams discussion:

                        


But still getting this error:

-		msg	0x000000d497efe380 "Caught exception C0000094 in CrossPlotView::OnDraw() tracePoint=60\nSuppress messages like this?"	char[512]

                        
2021.06.18
I. Researching and implementing solution:                                          


Second Chance Assertion Failed: File c:\program files (x86)\microsoft visual studio\2017\buildtools\vc\tools\msvc\14.16.27023\atlmfc\include\afxtempl.h, Line 320                        
QI-Pro.exe has triggered a breakpoint.

AFX_INLINE TYPE& CArray<TYPE, ARG_TYPE>::ElementAt(INT_PTR nIndex)
{
	ASSERT(nIndex >= 0 && nIndex < m_nSize);
    // ...
}    
                        
At:                        
                        
UINT __cdecl CCrossPlotView::DrawScatterThreadTask(LPVOID pParm)
{                        
    // ...
    CCrossPlotView::DrawScatter(pDC, viewInstance, pSegyX, pSegyY, pSegyAttr, startTrace, endTrace,
        pSelectedZones, pClassListArray, nDraw, bFoundHighlight, densityTable, rect, *pData->pen, *pData->brush, hpen1, hbrush1, hpen2, hbrush2);
    return 0;    
}    

-----

QI-Pro.exe has triggered a breakpoint.
                        
-On line "pDC->SelectObject(pTracePen[ixpen]);":

void CCrossPlotView::DrawScatter(CDC *pDC, int viewInstance, CSegy *pSegyX, CSegy *pSegyY,
    CSegy *pSegyAttr, int startTrace, int endTrace, CViewZoneArray *pSelectedZones, BOOL *pClassListArray, int nDraw, BOOL *bFoundHighlight,
    int *densityTable, CRect rect, CArray<CPen*>& pTracePen, CArray<CBrush*>& pTraceBrush, CPen *highlightPen1, CBrush *highlightBrush1, CPen* highlightPen2, CBrush* highlightBrush2)
{
    // ...
            if (nDraw == 0 && bDrawpoint) {
				pDC->SelectObject(pTracePen[ixpen]);
                if (dotSize == 1) {
                    pDC->MoveTo(tmpx, tmpy);
                    pDC->LineTo(tmpx + 1, tmpy);
                }

                    // ...
            }
}    

Where:

pTracePen = {m_pData=0x0000000000000000 {???} m_nSize=0 m_nMaxSize=0 ...}
ixpen = -1
                        
colorbarColors = {m_pData=0x00000152b4735860 {9474192} m_nSize=25 m_nMaxSize=25 ...}

		CArray<COLORREF> colorbarColors;
		if (pXpParms->m_nScatterMode == eATTR) {
			Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), pXpParms->m_thirdAttrColorbarName, colorbarColors, 0);
		}
		else if (pXpParms->m_nScatterMode == eDENSITY) {
			Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), pXpParms->m_denistyColorbarName, colorbarColors, DENSITYBARSIZE);
		} else {
			COLORREF* colorbar = pDoc->GetColorBar();
			for (int i = 0; i < pDoc->GetColorBarSize(); i++) colorbarColors.Add(colorbar[i]);
		}

		FreePensAndBrushes();

                        
-----

	m_denistyColorbarName = DEFAULT_CLASS_COLORBAR;
	m_thirdAttrColorbarName = DEFAULT_CLASS_COLORBAR;


	m_denistyColorbarName = "";
	m_thirdAttrColorbarName = "";
                        
	CString GetDenistyColorbarName() { return m_denistyColorbarName; }
	CString GetThirdAttrColorbarName() { return m_thirdAttrColorbarName; }

-----

	for (int i=0; i<MAXCLASS+DENSITYBARSIZE; i++) {
		pTracePen[i] = NULL;
		pTraceBrush[i] = NULL;
	}

-> Solution: Add check for ixpen and add color bar values for density color bar if no previous color bar name was saved (so it will still work with older projects)

		CArray<COLORREF> colorbarColors;
		if (pXpParms->m_nScatterMode == eATTR) {
			if (pXpParms->GetThirdAttrColorbarName() == "") {
				pDoc->GenerateThirdAttributeColorbar();
			}
			else {
				Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), pXpParms->m_thirdAttrColorbarName, colorbarColors, 0);
			}
		}
		else if (pXpParms->m_nScatterMode == eDENSITY) {
			if (pXpParms->GetDenistyColorbarName() == "") {
				pDoc->GenerateDensityColorBar();
				COLORREF* densitybar = pDoc->GetDensityColorBar();

				for (int i = 0; i < 4 * DEN_NCOLOR; i++) {
					colorbarColors.Add(densitybar[i]);
				}
			}
			else {
				Utilities::GetColorBarColors(pDoc->GetProjectFullPath(), pXpParms->m_denistyColorbarName, colorbarColors, DENSITYBARSIZE);
			}
		} else {
			COLORREF* colorbar = pDoc->GetColorBar();
			
			for (int i = 0; i < pDoc->GetColorBarSize(); i++) {
				colorbarColors.Add(colorbar[i]);
			}
		}

Changed:

             if (nDraw == 0 && bDrawpoint) {
            	if (pTracePen.GetCount() > ixpen && pTracePen[ixpen] != NULL && dotSize == 1) {
					pDC->SelectObject(pTracePen[ixpen]);
                    pDC->MoveTo(tmpx, tmpy);
                    pDC->LineTo(tmpx + 1, tmpy);
                } else if (pTraceBrush.GetCount() > ixpen && pTraceBrush[ixpen] != NULL) {
                    pDC->SelectObject(pTraceBrush[ixpen]);
                    CRect selPoint;
                    selPoint.left = tmpx - dotSize / 2;
                    selPoint.top = tmpy - dotSize / 2;
                    selPoint.right = selPoint.left + dotSize;
                    selPoint.bottom = selPoint.top + dotSize;
                    pDC->Rectangle(selPoint);
                }
            }

To:

            if (nDraw == 0 && bDrawpoint) {
            	if (ixpen >= 0 && ixpen < pTracePen.GetCount() && dotSize == 1) {
					pDC->SelectObject(pTracePen[ixpen]);
                    pDC->MoveTo(tmpx, tmpy);
                    pDC->LineTo(tmpx + 1, tmpy);
                } else if (ixpen >= 0 && ixpen < pTraceBrush.GetCount()) {
                    pDC->SelectObject(pTraceBrush[ixpen]);
                    CRect selPoint;
                    selPoint.left = tmpx - dotSize / 2;
                    selPoint.top = tmpy - dotSize / 2;
                    selPoint.right = selPoint.left + dotSize;
                    selPoint.bottom = selPoint.top + dotSize;
                    pDC->Rectangle(selPoint);
                }
            }                        
                        
2021.06.21
I. Researching and implementing solution:                                                                  

Roger: Working on crossplot, getting errors in the DrawScatter in the CrossPlotView.cpp.  Three main issues:
1) CrossplotSettingsDlg: the color bar is missing user color bars 
2) Periodically it is getting an ixpen == - 1 
3) The color bar on the RHS is too long so need to scale it 
4) When you set the scatter point to anything but 1 then you get a square box 

-----

void CCrossPlotView::OnXplotDensityMode()
{
	CIMACDoc* pDoc = GetDocument();
	CXplotParms *pXpParms;
	pXpParms = pDoc->GetXplotParms(m_viewInstance);

	if (pXpParms->m_nScatterMode != eDENSITY) {
		pXpParms->m_nScatterMode = eDENSITY;
	}
	else {
		pXpParms->m_nScatterMode = eCLASS;
	}
	SetToolbarButtonState();

    //set the color flag, so the view can use the new colormap
    DWORD theMagicBit = 0x1 << (m_viewInstance + 2);
    pDoc->m_bNewColorFlag |= theMagicBit;		// turn on the update bit

	pDoc->UpdateViews();
}

void CCrossPlotView::SetToolbarButtonState()
{
	CIMACDoc* pDoc = GetDocument();
	CXplotParms *pXpParms;
	pXpParms=pDoc->GetXplotParms(m_viewInstance);

	m_bScatterBtn = (pXpParms->m_nScatter != 0)? TRUE: FALSE;
	m_bPicBtn = !pXpParms->m_bDisableImage;
	m_bGroupBtn = pXpParms->m_bGroupMove;
	m_bDensityBtn = (pXpParms->m_nScatterMode == eDENSITY);
}

void CIMACDoc::GenerateDensityColorBar()
{
	int i, cc1, cc2;
	cc1=DEN_INCREMENT;
	cc2=DEN_INCREMENT*(DEN_NCOLOR-1);
	// hard code the full on colors
	m_densitybar[0*DEN_NCOLOR] = RGB(  0,   0, 255); // blue
	m_densitybar[1*DEN_NCOLOR] = RGB(  0, 255, 255); // cyan
	m_densitybar[2*DEN_NCOLOR] = RGB(  0, 255,   0); // green
	m_densitybar[3*DEN_NCOLOR] = RGB(255, 255,   0); // yellow
	m_densitybar[4*DEN_NCOLOR] = RGB(255,   0,   0); // red
	// fill in the interpolated colors
	for (i=1; i<DEN_NCOLOR; i++, cc1+=DEN_INCREMENT, cc2-=DEN_INCREMENT) {
		m_densitybar[i+(0*DEN_NCOLOR)]=RGB(0,cc1,255);
		m_densitybar[i+(1*DEN_NCOLOR)]=RGB(0,255,cc2);
		m_densitybar[i+(2*DEN_NCOLOR)]=RGB(cc1,255,0);
		m_densitybar[i+(3*DEN_NCOLOR)]=RGB(255,cc2,0);
	}
}

void CIMACDoc::GenerateThirdAttributeColorbar()
{
	for (int j = 0; j < NXPLOT; j++) {
		// make a r-w-b default color bar
		for (int i = 0; i < MAXCBSIZE; i++) m_thirdAttributeBar[i + j * MAXCBSIZE] = NOCOLOR;
		m_thirdAttributBarSize[j] = 21;
		m_thirdAttributeBar[0 + j * MAXCBSIZE] = RGB(255, 0, 0);
		m_thirdAttributeBar[10 + j * MAXCBSIZE] = RGB(255, 255, 255);
		m_thirdAttributeBar[20 + j * MAXCBSIZE] = RGB(0, 0, 255);
		InterpolateColorbar(&m_thirdAttributeBar[j*MAXCBSIZE], 21);
	}
}

COLORREF m_thirdAttributeBar[MAXCBSIZE * NXPLOT];

CString GetDenistyColorbarName() { return m_denistyColorbarName; }

#define DEN_NCOLOR (256/DEN_INCREMENT)

Therefore:
                        
DEN_NCOLOR == (256/DEN_INCREMENT)
DEN_NCOLOR == (256/32)                   
DEN_NCOLOR == 8

4*DEN_NCOLOR

COLORREF m_densitybar[DENSITYBARSIZE];

-----

1>------ Build started: Project: IMAC, Configuration: Debug x64 ------
1>CrossPlotView.cpp
1>c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotview.cpp(1265): warning C4700: uninitialized local variable 'pSegyOut' used
1>c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotview.cpp(1269): warning C4700: uninitialized local variable 'tmpy' used
1>c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotview.cpp(1269): warning C4700: uninitialized local variable 'tmpx' used
1>c:\sound-qi_source\soundqi-branch\rm_branch\imac\crossplotview.cpp(1269): warning C4700: uninitialized local variable 'a' used
1>IMAC.vcxproj -> C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\OSI\QI-Pro\x64\Debug\QI-Pro.exe
1>Done building project "IMAC.vcxproj".

Revision: d9510558b8c57f4bbcef87e58fb8943e9a4e7df2
Author: Roger Moore <roger@sound-qi.com>
Date: 2021-06-21 3:35:39 PM
Message:
-Properly setting colour bar for third attribute if the user is working with an old project which does not have a value set for m_thirdAttrColorbarName

----
Modified: RM_Branch/IMAC/CrossPlotView.cpp
Modified: RM_Branch/IMAC/IMACDoc.h

-----

Draw the color bar in the xplot for the density mode:

		// Density mode //
		if (pXpParms->m_nScatterMode == eDENSITY) {
			m_tracePoint = 51;
			//TRACE("Tracepoint %d\n", m_tracePoint);
			
			// Populate the density table
			pXpParms->ComputeDensityTable(pDoc, m_viewInstance, startTime, endTime, selectedZones, m_classListArray);

			m_tracePoint = 52;

			m_binX = pXpParms->m_binXsize;
			m_binY = pXpParms->m_binYsize;
			m_startTime = startTime;
			m_endTime = endTime;
			m_colorBarMin = pXpParms->m_colorBarMin;
			m_colorBarMax = pXpParms->m_colorBarMax;

			// display the color bar
			pDC->SelectObject(m_pNormPen);
			CRect rcBar;
			rcBar.left   = rcClient.right-(RIGHTBORDER/2)-(DEN_WIDTH/2);
			rcBar.right  = rcBar.left + DEN_WIDTH;
			rcBar.top    = 2*BORDER;
			rcBar.bottom = rcClient.bottom-2*BORDER;
			int inc = (rcBar.bottom-rcBar.top) / DENSITYBARSIZE;
			rcBar.bottom = rcBar.top + (DENSITYBARSIZE*inc);

			CRect rcPlot = rcBar;
			rcPlot.bottom = rcPlot.top + inc;
			//TRACE("CCrossPlotView::DoOnDraw()\n");

			if (pXpParms->GetDenistyColorbarName() == "") {
				m_densitybar = pDoc->GetDensityColorBar();
				
				for (int i = DENSITYBARSIZE; i > 0; i--) {
					pDC->FillRect(rcPlot, &CBrush(m_densitybar[i - 1]));
					rcPlot.top += inc;
					rcPlot.bottom += inc;
				}
			}
			else {
				for (int i = (int)pTraceBrush.GetCount() - 1; i >= 0; i--) {
					pDC->FillRect(rcPlot, pTraceBrush[i]);
					//TRACE("densitybar[j] = %u, R, G, B = %u, %u, %u\n", m_densitybar[i-1], GetRValue(m_densitybar[i-1]), GetGValue(m_densitybar[i-1]), GetBValue(m_densitybar[i-1]));
					rcPlot.top += inc;
					rcPlot.bottom += inc;
				}
			}
			pDC->MoveTo(rcBar.left,  rcBar.top);
			pDC->LineTo(rcBar.right, rcBar.top);
			pDC->LineTo(rcBar.right, rcBar.bottom);
			pDC->LineTo(rcBar.left,  rcBar.bottom);
			pDC->LineTo(rcBar.left,  rcBar.top);
                        // ...
                }

Draw the color bar in the xplot for the third attribute mode:                

		// Third Attribute mode //
		else if (pXpParms->m_nScatterMode == eATTR) {
			m_tracePoint = 60;
			// display the third attribute color bar
			int colorBarSize = (int)pTraceBrush.GetCount();
			if (colorBarSize > 0) {
				pDC->SelectObject(m_pNormPen);
				CRect rcBar;
				rcBar.left = rcClient.right - RIGHTBORDER + DEN_WIDTH;
				rcBar.right = rcBar.left + DEN_WIDTH;
				rcBar.top = 2 * BORDER;
				rcBar.bottom = rcClient.bottom - 2 * BORDER;
				int inc = (rcBar.bottom - rcBar.top) / colorBarSize;
				rcBar.bottom = rcBar.top + (colorBarSize * inc);

				CRect rcPlot = rcBar;
				rcPlot.bottom = rcPlot.top + inc;
				if (pXpParms->GetThirdAttrColorbarName() == "") {
					COLORREF* colorbar;
					colorbar = pDoc->GetColorBarPtr(m_viewInstance);
					int colorBarSize = pDoc->GetColorBarSize(m_viewInstance);

					for (int i = colorBarSize; i > 0; i--) {
						pDC->FillRect(rcPlot, &CBrush(colorbar[i - 1]));
						rcPlot.top += inc;
						rcPlot.bottom += inc;
					}
				}
				else {
					for (int i = colorBarSize - 1; i >= 0; i--) {
						pDC->FillRect(rcPlot, pTraceBrush[i]);
						rcPlot.top += inc;
						rcPlot.bottom += inc;
					}
				}
				pDC->MoveTo(rcBar.left, rcBar.top);
				pDC->LineTo(rcBar.right, rcBar.top);
				pDC->LineTo(rcBar.right, rcBar.bottom);
				pDC->LineTo(rcBar.left, rcBar.bottom);
				pDC->LineTo(rcBar.left, rcBar.top);
				CRect rcText = rcBar;

				sText.Format("%6g", pXpParms->m_attrColorBarMax);
				rcText.bottom = rcText.top;
				rcText.top -= dxy;
				rcText.left -= dxy;
				rcText.right += dxy;
				pDC->DrawText(sText, rcText, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
				rcText.top = rcBar.bottom;
				rcText.bottom = rcBar.bottom + dxy;
				sText.Format("%6g", pXpParms->m_attrColorBarMin);
				pDC->DrawText(sText, rcText, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

				// draw the name of the 3rd attribute rotated along the right side the colorbar
				// The GetOutputTextExtent() function returns the extents of the unrotated text. So we have to adjust for the vertical orientation.
				CFont *pOldFont = pDC->SelectObject(m_pFont270);
				CSize sizeText = pDC->GetOutputTextExtent(pXpParms->GetColorAttr());
				rcText.left = rcBar.left;
				rcText.bottom = rcBar.bottom;
				rcText.right = rcBar.right + sizeText.cx + sizeText.cy + DEN_WIDTH;
				rcText.top = rcBar.top + ((rcBar.bottom - rcBar.top) / 2) - (sizeText.cx / 2);
				pDC->DrawText(pXpParms->GetColorAttr(), rcText, DT_RIGHT | DT_TOP | DT_SINGLELINE);

				pDC->SelectObject(pOldFont);
			}
                        
sText = "4528"

rcBar.bottom = 430

2021.06.22
I. Researching and implementing Solution:
                        
	GetDlgItem(IDC_STATIC_DOTSIZE)->EnableWindow(bScatter);
	GetDlgItem(IDC_EDIT_DOTSIZE)->EnableWindow(bScatter);                        

DDX_Text(pDX, IDC_EDIT_DOTSIZE, m_dotSize);                        
DDV_MinMaxInt(pDX, m_dotSize, 1, 20);
                        
void CCrossPlotView::OnXplotPointInc()
{
    CIMACDoc* pDoc = GetDocument();
    CXplotParms *pXpParms;
    pXpParms = pDoc->GetXplotParms(m_viewInstance);
    // if scatter is off, then turn it back on instead fo doing the increment.
    if (pXpParms->m_nScatter == 0) {
        pXpParms->m_nScatter = m_nPreviousScatterValue;
    } else if (pXpParms->m_dotSize < 20) {
        pXpParms->m_dotSize++;
    } else {
        AfxMessageBox("Dot size of 20 is the maximum allowed.");
    }
    SetToolbarButtonState();
    pDoc->UpdateViews();
}
                        
void CCrossPlotView::OnXplotPointDec()
{
    CIMACDoc* pDoc = GetDocument();
    CXplotParms *pXpParms;
    pXpParms = pDoc->GetXplotParms(m_viewInstance);
    // if scatter is off, then ignore this command.
    if (pXpParms->m_nScatter > 0) {
        if (pXpParms->m_dotSize == 1) {
            // turn off scatter if the decrement would go to zero (zero is not allowed)
            m_nPreviousScatterValue = 1;
            pXpParms->m_nScatter = 0;
        } else if (pXpParms->m_dotSize > 1) {
            pXpParms->m_dotSize--;
        }
    }
    SetToolbarButtonState();
    pDoc->UpdateViews();
}

m_dotSize

int dotSize = pXpParms->m_dotSize;

-----

            a = (pX[k] - pXpParms->m_fXMin) / (pXpParms->m_fXMax - pXpParms->m_fXMin);
            tmpx = (int)(a*(float)(x2 - x1)) + x1;
            a = (pY[k] - pXpParms->m_fYMin) / (pXpParms->m_fYMax - pXpParms->m_fYMin);
            tmpy = y2 - (int)(a*(float)(y2 - y1));
            if (nDraw == 0 && bDrawpoint) {
            	if (ixpen >= 0 && ixpen < pTracePen.GetCount() && dotSize == 1) {
                    pDC->SelectObject(pTracePen[ixpen]);
                    pDC->MoveTo(tmpx, tmpy);
                    pDC->LineTo(tmpx + 1, tmpy);
                } else if (ixpen >= 0 && ixpen < pTraceBrush.GetCount()) {
                    pDC->SelectObject(pTraceBrush[ixpen]);
                    CRect selPoint;
                    selPoint.left = tmpx - dotSize / 2;
                    selPoint.top = tmpy - dotSize / 2;
                    selPoint.right = selPoint.left + dotSize;
                    selPoint.bottom = selPoint.top + dotSize;
                    pDC->Rectangle(selPoint);
                }
            }

                        
                        
Severity	Code	Description	Project	File	Line	Suppression State
Error	LNK2019	unresolved external symbol "public: void __cdecl CIMACDoc::GenerateDensityColorBar(void)" (?GenerateDensityColorBar@CIMACDoc@@QEAAXXZ) referenced in function "public: void __cdecl CCrossPlotView::DoOnDraw(class CDC *)" (?DoOnDraw@CCrossPlotView@@QEAAXPEAVCDC@@@Z)	IMAC	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\CrossPlotView.obj	1	
Error	LNK2019	unresolved external symbol "public: static bool __cdecl Utilities::GetColorBarColors(class ATL::CStringT<char,class StrTraitMFC_DLL<char,class ATL::ChTraitsCRT<char> > >,class ATL::CStringT<char,class StrTraitMFC_DLL<char,class ATL::ChTraitsCRT<char> > >,class CArray<unsigned long,unsigned long const &> &,int)" (?GetColorBarColors@Utilities@@SA_NV?$CStringT@DV?$StrTraitMFC_DLL@DV?$ChTraitsCRT@D@ATL@@@@@ATL@@0AEAV?$CArray@KAEBK@@H@Z) referenced in function "public: void __cdecl CCrossPlotView::DoOnDraw(class CDC *)" (?DoOnDraw@CCrossPlotView@@QEAAXPEAVCDC@@@Z)	IMAC	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\CrossPlotView.obj	1	

m_parms.m_thirdAttrColorbarName = "ClassColors.cb"

m_parms.m_denistyColorbarName = ""
                        
