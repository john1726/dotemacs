Description:
A few clients have requested a dotted line indicating the position of the time slice displayed on the map.

2020.12.14
I. Researching and implementing solution:

	CEdit	   m_edtSliceTime;
	int        m_sliceTime;
	CComboBox  m_cmbSlice;

// Time slice controls
void CMapSelectDlg::OnClickedUpdateSlice()
{
	UpdateData(TRUE);
	if (ValidateSliceTime()) {
		CString sliceReference;
		m_cmbSlice.GetLBText(m_cmbSlice.GetCurSel(), sliceReference);
		pDoc->SetTimeSliceParms(m_sliceTime, sliceReference);
		pDoc->UpdateViews(TRUE);
	} else {
		m_bShowSliceFlag = FALSE;
	}
	UpdateControls();
}

		m_cmbSlice.GetCurSel()	Function CComboBox::GetCurSel has no address, possibly due to compiler optimizations.	

    m_sliceTime = 10                
    sliceReference = " Lwr_Keg_River"
    m_sliceReference = CHorizon::TIME_ZERO;
    
void CIMACDoc::SetTimeSliceParms(int time, CString ref) 
{ 
	m_timeSlice.SetSliceTime(time); 
	m_timeSlice.SetSliceReference(ref); 
	m_timeSlice.SetShowSliceFlag(TRUE); 
	m_timeSlice.SetLoadSliceFlag(TRUE);
	m_timeSlice.SetActiveFlag(TRUE);
}

void CIMACDoc::GetSliceParms(BOOL &bShow, BOOL &bLoad, int &time, CString &ref)
{
	bShow = m_timeSlice.isShowSliceFlag(); 
	bLoad = m_timeSlice.isLoadSliceFlag();
	time  = m_timeSlice.GetSliceTime(); 
	ref   = m_timeSlice.GetSliceReference();
}

    
	CString strReference = pTimeSlice->GetSliceReference();

-Which is called in:

int CSegy::LoadSliceData(int ixSlice, CString fname, CTimeSlice *pTimeSlice, CHorizon *pHorizon, const CUPDUPDATA* pProgress )
{
	clock_t start = clock();
	if (fname.IsEmpty()) return -1;

	CString strReference = pTimeSlice->GetSliceReference();
	int horIndex = -1;
	float *pHor = NULL;
	int horizonOffset = 0;
	int traceLength = 240 + GetSampleCount() * 4; 
	BYTE *pBuf;

	// Depending if there is a reference horizon the reference time will be absolute or relative.
	// find index of reference horizon
	if (strReference != CHorizon::TIME_ZERO && pHorizon->GetHorizonCount() > 0) {
		int j = 0;
		while (j < pHorizon->GetHorizonCount() && pHorizon->GetName(j) != strReference) j++;
		if (j < pHorizon->GetHorizonCount()) horIndex = j;
	}
	// reference horizon not found, so reset to default.
	if (horIndex == -1) {
		strReference = CHorizon::TIME_ZERO;
		pTimeSlice->SetSliceReference(strReference);
	} else {
		pHor = pHorizon->GetHorizonDataPtr(horIndex);
	}

	int si = GetSampleInterval();
	int segyStartTime = GetStartTime();
	int sliceTime = pTimeSlice->GetSliceTime(); 
	int sampleIndex;
	if (horIndex == -1) {
		// reference time is absolute;
		sampleIndex = Time2Index(sliceTime-segyStartTime, si);
		// check if in range
		if (sampleIndex < 0 || sampleIndex >= GetSampleCount()) {
			return -1;
		}
	} else {
		// reference time is relative to a horizon
		sampleIndex = Time2Index(sliceTime, si);
	}

	int sampleOffset = 240 + (sampleIndex * 4);

	CFile f;
	CFileException ex;
	CSegyIndex *pIndex = &m_index;
	float *pSliceData = pTimeSlice->GetDataPtr(ixSlice);
	float *pSlice     = pTimeSlice->GetSlicePtr();
	BOOL  *pDeadFlag  = pTimeSlice->GetFlagPtr();
	CDoublePointArray *pCoords = pTimeSlice->GetCoordPtr();
	 
	if (!m_file.Open(fname, CFile::modeRead|CFile::shareDenyWrite, &ex)) {
		TCHAR   szCause[255];
		ex.GetErrorMessage(szCause,255);
		AfxMessageBox(szCause);
		return -1;
	} else {
		DWORD inlineMin, inlineMax, xlineMin, xlineMax;
		pIndex->GetLineMinMax(inlineMin, inlineMax, xlineMin, xlineMax);

		int totalSamps = (xlineMax-xlineMin+1) * (inlineMax-inlineMin+1);
		int sampCount = 0;
		int iPercentDone = -1;
		DWORD sliceIndex = 0;
		DWORD ixTrace = 0;
		int   currIndex = 0;
		double nextTraceOffset = -1;
		pBuf = new BYTE[traceLength];
		int hits = 0;
		int misses = 0;

		BOOL bIgnore;
		DWORD inLine, xLine;
		double traceOffset, xcoord, ycoord;
		BOOL bNoHorizon = FALSE;

		while (!pProgress->ShouldTerminate() && pIndex->FindNextTrace(ixTrace, inLine, xLine, xcoord, ycoord, traceOffset, bIgnore) == 0) {
			ixTrace++;

			if (inLine < inlineMin || inLine > inlineMax) continue;
			if (xLine  < xlineMin  || xLine  > xlineMax ) continue;

			// report the progress
			float fPercentDone = (float)(sampCount++) / (float)totalSamps * 100.0f;
			if ((int)fPercentDone != iPercentDone) {
				//TRACE("percent=%d hits=%d misses=%d\n",iPercentDone, hits, misses);
				iPercentDone = (int)fPercentDone;
				pProgress->SetProgress(iPercentDone);
			}

			if (bIgnore) {
				// ignore this trace, no valid data.
				pSliceData[sliceIndex] = NODATA;
				pSlice[sliceIndex]     = NODATA;
				pDeadFlag[sliceIndex]  = TRUE;
			} else {	
				// get the horizon time for this trace
				if (horIndex >= 0) {
					if (pHorizon->FindIndex(inLine, xLine, currIndex) == 0) {
						int horTime = (int) pHor[currIndex];
						horizonOffset = Time2Index(horTime-segyStartTime, si) * 4;
						bNoHorizon = FALSE;
					} else {
						bNoHorizon = TRUE;
					}
				}

				pCoords->SetAtGrow(sliceIndex, CDoublePoint(xcoord, ycoord));

				// check if in range.
				if ((sampleOffset + horizonOffset) < 240 || (sampleOffset + horizonOffset) >= traceLength || bNoHorizon) {
					pSliceData[sliceIndex] = NODATA;
					pSlice[sliceIndex]     = NODATA;
					pDeadFlag[sliceIndex]  = TRUE;	
				} else {
					if (traceOffset != nextTraceOffset) {
						LARGE_INTEGER li;
						li.QuadPart = (__int64) traceOffset;
						SetFilePointer((HANDLE)m_file.m_hFile, li.LowPart, &li.HighPart, FILE_BEGIN);
						misses++;
					} else {
						hits++;
					}
					nextTraceOffset = traceOffset + traceLength;

					if(m_file.Read(pBuf, traceLength) != traceLength) {
						AfxMessageBox("Problem reading time slice data");
						break;
					}

					if (m_nFormatCode == 1) {
						ibm_ieee(&pBuf[sampleOffset + horizonOffset], &pSliceData[sliceIndex], 1, GetDataEndian());
					} else {
                        if (GetDataEndian() == eBIGENDIAN) {
                            flip_endian(&pBuf[sampleOffset + horizonOffset], (BYTE *)&pSliceData[sliceIndex], 1);
                        } else {
                            memcpy(&pSliceData[sliceIndex], &pBuf[sampleOffset + horizonOffset], sizeof(float));
                        }
					}
					pSlice[sliceIndex] = UNCLASSIFIED;
					pDeadFlag[sliceIndex] = FALSE;
				}
			}
			sliceIndex++;
		}
	}

	m_file.Close();
	delete pBuf;

	if(!pProgress->ShouldTerminate()) {
		pTimeSlice->SetDataLoadedFlag(ixSlice, TRUE);
	}

#if TIMERS == 1
	TRACE("Time Slice %d loaded in %5.3f seconds\n", ixSlice, (double) (clock()-start) / CLOCKS_PER_SEC);
#endif

	return 0;
}


See also which calls the above:

// static method run in the progress dialog thread
bool LoadTimesliceTask(const CUPDUPDATA* pCUPDUPData)
{
	LOAD_TIMESLICE_PARM* pTaskparm = (LOAD_TIMESLICE_PARM*) pCUPDUPData->GetAppData();
	CIMACDoc* pDoc = pTaskparm->pDoc;
	CTimeSlice* pTimeSlice = pTaskparm->pTimeSlice;
	int fileCount = pDoc->GetFileCount();
	int volumeCount = fileCount;

	// Update the timeslice with the document data and count the number of unique attributes that 
	// need to be loaded (for the message).
	int attributeCount = 0;
	for (int i = 0; i<fileCount; i++) {
		CString sAttr = pDoc->GetAttr(i);
		if (pDoc->GetFile(i) != pTimeSlice->GetFileName(i)) {
			pTimeSlice->SetFileName(i, pDoc->GetFile(i));
			pTimeSlice->SetDataLoadedFlag(i, FALSE);
		}
		if (sAttr != pTimeSlice->GetAttrName(i)) {
			pTimeSlice->SetAttrName(i, sAttr);
		}

		// check if this attribute is active
		if( !pTimeSlice->IsDataLoaded(i) ) {
			// skip loading if this attribute isn't being used in crossplot
			if (pDoc->IsAttributeInCrossPlot(sAttr) || pDoc->IsAttributeInVirtualVolumeInCrossPlot(sAttr)) {
					attributeCount++;
			}
		}
	}
	// now update the timeslice with the virtual volume attributes
	for (int i = 0; i < pDoc->GetVirtualVolumeCount(); i++){
		CString sAttr = pDoc->GetVirtualVolumeAttributeName(i);
		if (sAttr != pTimeSlice->GetAttrName(volumeCount)){
			pTimeSlice->SetFileName(volumeCount, "");
			pTimeSlice->SetDataLoadedFlag(volumeCount, FALSE);
			pTimeSlice->SetAttrName(volumeCount, sAttr);
		}

		// check if the virtual volume is active
		if (!pTimeSlice->IsDataLoaded(volumeCount)) {
			// skip loading if this attribute isn't being used in crossplot
			if (pDoc->IsAttributeInCrossPlot(sAttr)) {
				attributeCount++;
			}
		}
		volumeCount++;
	}

	if (attributeCount == 0) return TRUE; // return if there are no attribute to load 

	pTimeSlice->SetVolumeCount(volumeCount);

	// Load slice data from active files.
	int currentAttribute = 0;
	for (int i = 0; i<fileCount && !pCUPDUPData->ShouldTerminate(); i++) {
		CSegy *pSegy=pDoc->GetSegyInPtr(i);
		CString sAttr = pDoc->GetAttr(i);

		// check if this attribute is active
		BOOL bLoad = FALSE;
		if ( pDoc->IsAttributeInCrossPlot(sAttr) || pDoc->IsAttributeInVirtualVolumeInCrossPlot(sAttr)) {
			bLoad = TRUE;
		}

		if (!bLoad || pTimeSlice->IsDataLoaded(i)) continue;

		CString msg;
		msg.Format("Loading Attribute %d of %d: %s", ++currentAttribute, attributeCount, sAttr);
		pCUPDUPData->SetProgress(msg);

		if (pSegy->LoadSliceData(i, pDoc->GetFile(i), pTimeSlice, pDoc->GetHorizonDataPtr(), pCUPDUPData) != 0) 
		{
			msg.Format("Unable to load time slice data for %d ms in file:\n %s\nPlease check that the time slice lies within the project start and end time.",
				pTimeSlice->GetSliceTime(), pDoc->GetFile(i));
			AfxMessageBox(msg);
			return FALSE;
		}
	}

	// compute the virtual time slices.
	int vvCount = -1;
	for (int i = 0; i < pDoc->GetVVAttributeCount(); i++) {
		CVVAttribute& vvAttr = pDoc->GetVVAttributeRef(i);
		for (int j = 0; j < vvAttr.GetVVCount(); j++) {
			CString sAttr = vvAttr.GetVVName(j);
			vvCount++;

			if (!pDoc->IsAttributeInCrossPlot(sAttr) || pTimeSlice->IsDataLoaded(vvCount + fileCount)) continue;

			CString msg;
			msg.Format("Loading Attribute %d of %d: %s", ++currentAttribute, attributeCount, sAttr);
			pCUPDUPData->SetProgress(msg);

			// create completely expanded (substituted) equation of equation
				// NOTE:	GetSubstitutedEquation() replaces all attributes with a random variable and stores those attributes
				//			in a separate external list to save them. This is done so that the parsing will work accurately, in
				//			case there are 'illegal' characters in the attribute names. To get the variables, we use GetSubstitutedVariables()
			CVVEquation vvEquationRef(vvAttr.GetVVEquation(j).GetSubstitutedEquation());
			vvEquationRef.Parse();
			CStringArray* pVariableArray = vvAttr.GetVVEquation(j).GetSubstitutedVariables(); // NOTE: Get SubstitutedEquation must be called first for this to work

			// get the list of attribute names and their corresponding file indexes
			CIntArray attributeIndexes;
			for (int k = 0; k < pVariableArray->GetCount(); k++) {
				attributeIndexes.Add(pDoc->GetAttributeIndex(pVariableArray->GetAt(k)));
			}

			// with the equation and list of indexes, we can now compute the virtual timeslice.
			pTimeSlice->ComputeVirtualTimeSlice(vvCount + fileCount, vvEquationRef, &attributeIndexes);
			
		}
	}

	return TRUE;
}

See CMapSelectDlg::LoadUserLine()
See CTimeSlice::ComputeVirtualTimeSlice()

-----

void CIMACDoc::GetSliceParms(BOOL &bShow, BOOL &bLoad, int &time, CString &ref)
{
	bShow = m_timeSlice.isShowSliceFlag(); 
	bLoad = m_timeSlice.isLoadSliceFlag();
	time  = m_timeSlice.GetSliceTime(); 
	ref   = m_timeSlice.GetSliceReference();
}

-The above function is called here:

// reset the controls according to the document settings.
void CMapSelectDlg::UpdateControls()
{
	if (m_cmbSlice.m_hWnd == NULL) {
		TRACE("Error updating Time Slice Relative To combo box. Invalid window handle.\n");
		return;	// The dialog has probably been closed.
	}

	// time slice combo
	m_cmbSlice.ResetContent();  // this line of code breaks the redraw of the crossplot views.  See bug 237
	CString selectedString;
	pDoc->GetSliceParms(m_bShowSliceFlag, m_bLoadSliceFlag, m_sliceTime, selectedString);
	CString defaultString = CHorizon::TIME_ZERO;
	m_cmbSlice.AddString(defaultString);
	CHorizon *pHor = pDoc->GetHorizonDataPtr();
        // ...
}    

-In IMACDoc::UpdateViews:

	// Time Slice...
	if (m_timeSlice.isActive() && m_timeSlice.isShowSliceFlag()) {
		if (m_timeSlice.isLoadSliceFlag()) {
			if (!m_timeSlice.Create(GetFileCount()+GetVirtualVolumeCount(), GetSegyInPtr(0)->GetSegyIndexPtr())) {
				m_timeSlice.Destroy();
				m_timeSlice.SetShowSliceFlag(FALSE);
			}
		}
		LoadTimeSlice(&m_timeSlice);
  		m_timeSlice.SetLoadSliceFlag(FALSE);
        }

-		m_index	{m_pEbcdic=0xcccccccc000000a0 <Error reading characters of string.> m_pBinary=0xcccccccc00000d20 <Error reading characters of string.> ...}	CSegyIndex
+		CObject	{...}	CObject
+		m_pEbcdic	0xcccccccc000000a0 <Error reading characters of string.>	unsigned char[3200]
+		m_pBinary	0xcccccccc00000d20 <Error reading characters of string.>	unsigned char[400]
+		m_pTrHeader	0xcccccccc00000eb0 <Error reading characters of string.>	unsigned char[240]
		m_ntrace	<Unable to read memory>	
		m_nsamps	<Unable to read memory>	
		m_sampleInterval	<Unable to read memory>	
		m_trsize	<Unable to read memory>	
		m_inlineCount	<Unable to read memory>	
		m_xlineCount	<Unable to read memory>	
		m_liveInlineCount	<Unable to read memory>	
		m_liveXlineCount	<Unable to read memory>	
		m_startTime	<Unable to read memory>	
		m_endTime	<Unable to read memory>	
		m_pInline	<Unable to read memory>	
		m_pXline	<Unable to read memory>	
		m_pTmp	<Unable to read memory>	
		m_pXcoord	<Unable to read memory>	
		m_pYcoord	<Unable to read memory>	
		m_pOffset	<Unable to read memory>	
		m_bIgnore	<Unable to read memory>	
		m_bSaveIgnore	<Unable to read memory>	
		m_pLiveInline	<Unable to read memory>	
		m_pLiveXline	<Unable to read memory>	
		m_isIndexLoaded	<Unable to read memory>	
		m_isIgnoreListValid	<Unable to read memory>	
		m_isFileOpen	<Unable to read memory>	
+		m_filename	???	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>

int CIMACDoc::GetVirtualVolumeCount()
{
	int fileCount = 0;
	int vvCount = GetVVAttributeCount();
	for (int i = 0; i < vvCount; i++){
		CVVAttribute &vvAttr = GetVVAttributeRef(i);
		fileCount += vvAttr.GetVVCount();
	}
	return fileCount; 
}

vvCount = 11

fileCount = 13

typedef struct load_timeslice_parm {
	CIMACDoc* pDoc;
	CTimeSlice* pTimeSlice;
} LOAD_TIMESLICE_PARM;

Where:

class CTimeSlice : public CObject
{
public:
	CTimeSlice(); 
	virtual ~CTimeSlice();
        // ...
        void  SetSliceTime(int n){ m_sliceTime = n;}
        // ...
	BOOL  isActive()		 { return m_bActiveFlag; }
	void  SetShowSliceFlag(BOOL flg) { m_bShowSliceFlag = flg; }
	void  SetLoadSliceFlag(BOOL flg) { m_bLoadSliceFlag = flg; }
	void  SetActiveFlag(BOOL flg)    { m_bActiveFlag = flg; }
        // ...    
}

GetXplotCount()
3

CIMACApp *pApp = (CIMACApp *)AfxGetApp();

-What is a virtual volume?

CMapSelectDlg::OnPaint:

if (pParent->GetShowAllUseLines() && pDoc->GetInlineXlineMode() == eUSERLINE && mapMode != eMAP_DIGITIZE && m_bMouseEnter) {
        // ...
}        

Where:

CMapSelectDlg *pParent;

BOOL GetShowAllUseLines() {return m_showAllUserLines;}

BOOL CChildFrame::PreCreateWindow(CREATESTRUCT& cs)
{

	cs.style &= ~(LONG)FWS_ADDTOTITLE;
	cs.lpszName = "Classified Seismic Volume";

	return CMDIChildWndEx::PreCreateWindow(cs);

}

ID_VIEW_VIEW1    "Classified Seismic Volume\nClassified Seismic Volume"

	pDocTemplate->AddFrameTemplate(
        new CFrameTemplate( 
			menuID,
            RUNTIME_CLASS( CChildFrame ), 
            RUNTIME_CLASS( CIMACView ), 
            ID_VIEW_VIEW1, 
            SW_SHOWNORMAL, 
            TRUE ) );

-> *** Classified Seismic Volume is located in the CIMACView class ***        

 // Draw the timing lines at the specified "timingLine" interval.
void CIMACView::DrawTimingLines(CDC *pDC, int timingLine)
{
	CIMACDoc* pDoc = GetDocument();
	if (!pDoc->GetDisplayLinesDisplayToggle()) return;
	int si = pDoc->GetSI();
	int ixs = Time2Index(m_startTime, si);
	if (timingLine == 10) {
		pDC->SelectObject(m_normPen);
	} else {
		pDC->SelectObject(m_dotPen);
	}
	for (int i = m_startTime; i <= m_endTime; i++) {
		int displayTime = i;
		if (pDoc->IsPetrelTimeMode()) {
			displayTime = -(displayTime - (int) pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()));
		}
		if (displayTime != displayTime / timingLine * timingLine) continue;
		float ixLine = Time2IndexFloat(i, si);
		int iy = TOP + (int)((ixLine - ixs) * m_vScale);
		if (timingLine == 10) {
			// for 10 mil timing lines, draw our own dotted line
			for (int j = SIDE; j < SIDE + m_nTotalTrace * m_hScale; j += 6) {
				pDC->MoveTo(j, iy);
				pDC->LineTo(j + 2, iy);
			}
		} else {
			// draw the line using the DotPen
			pDC->MoveTo(SIDE, iy);
			pDC->LineTo(SIDE + m_nTotalTrace * m_hScale, iy);
		}
	}
}
       
// Draw the timing line labels at the specified "timingLine" interval.
void CIMACView::DrawTimingLineLabels(CDC *pDC, int timingLine)
{

	CRect rcItem;
	CString strItem;
	CIMACDoc* pDoc = GetDocument();
	if (!pDoc->GetDisplayLinesDisplayToggle()) return;
	int si = pDoc->GetSI();
	int ixs = Time2Index(m_startTime, si);
	int ixe = Time2Index(m_endTime, si);
	for (int i = m_startTime; i <= m_endTime; i++) {
		int displayTime = i;
		if (pDoc->IsPetrelTimeMode()) {
			displayTime = -(displayTime - (int) pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()));
		}
		if (displayTime != displayTime / timingLine * timingLine) continue;
		float ixLabel = Time2IndexFloat(i, si);
		rcItem.left = 0;
		rcItem.right = SIDE - DXY;
		int iy = TOP + (int)((ixLabel - ixs) * m_vScale);
		rcItem.top = iy - DXY;
		rcItem.bottom = iy + DXY;
		
		
		if (pDoc->IsPetrelTimeMode() && pDoc->GetFlatteningDisplayToggle() && pDoc->GetFlattenHorizonCheck())  strItem.Format("%d (%d)", displayTime, displayTime - (pDoc->GetFlatteningDatum()));
		else if (pDoc->GetFlatteningDisplayToggle() && pDoc->GetFlattenHorizonCheck())  strItem.Format("%d (%d)", displayTime, displayTime - pDoc->GetFlatteningDatum());
		else strItem.Format("%d", displayTime);

		pDC->DrawText(strItem, -1, rcItem, DT_RIGHT | DT_VCENTER | DT_SINGLELINE);
		rcItem.left = SIDE + m_nTotalTrace * m_hScale + DXY;
		rcItem.right = rcItem.left + SIDE;
		pDC->DrawText(strItem, -1, rcItem, DT_LEFT | DT_VCENTER | DT_SINGLELINE);
	}
}

Where:

for (int i = m_startTime; i <= m_endTime; i++) {
        // ...
        
}

m_startTime = 850
m_endTime = 1050

void CIMACDoc::ComputeSlice()
{ 
	clock_t start = clock();

	int fileCount = GetFileCount();
	if (fileCount == 0) return;

	CTimeSlice *pTimeSlice = GetTimeSlicePtr();
	if (!pTimeSlice->isShowSliceFlag() || pTimeSlice->isLoadSliceFlag()) return;
	float *pSlice = pTimeSlice->GetSlicePtr();
        // ...
}    
1)

if (pWell->m_xline == xLine && pWell->m_inline == inLine) {
        // ...
}
Where:

pWell = 0x000001d00bcd0290 {m_fileName="Z:\\QI-Pro Demo\\Horn River Demo\\Wells\\Well 1_logs.las" header="~VERSION INFORMATION\n VERS.                          2.0   : CWLS LOG ASCII STANDARD - VERSION 2.0\n WRAP.                          NO    : ONE LINE PER DEPTH..."

if (!pDoc->m_bDrawFlag || m_nTrace == 0) {
    // ...
}        


-----
2)

	// Get start and end times. If they fall outside the data range then adjust them.
	int segySampCount = pOutputSegy->GetSampleCount();
	int segyStartTime = pOutputSegy->GetStartTime();
	int segyEndTime = segyStartTime + Index2Time((segySampCount - 1), si);
	m_startTime = max(pDoc->GetStartTime(), segyStartTime);
	m_endTime = min(pDoc->GetEndTime(), segyEndTime);
	pDoc->SetStartEndTimes(m_startTime, m_endTime);
                            
		m_endTime	1050	int
		m_sampCount	101	int
		m_startTime	850	int
+		pDoc	0x000001d00bce8990 {m_tempPathName="C:\\QI-Pro Demo\\Horn River Demo\\Projects\\QI-Pro Laurie complete.prj" ...}	CIMACDoc *
		segyEndTime	1300	int
		si	2000	int

m_nTotalTrace = 551


	ON_UPDATE_COMMAND_UI(IDC_RADIO_USERLINE,
                             OnUpdateCommandThatDependsOnAttributes)
                             

        
		pDC->DrawText(strItem, -1, rcItem, DT_RIGHT | DT_VCENTER | DT_SINGLELINE);
		rcItem.left = SIDE + m_nTotalTrace * m_hScale + DXY;
		rcItem.right = rcItem.left + SIDE;
		pDC->DrawText(strItem, -1, rcItem, DT_LEFT | DT_VCENTER | DT_SINGLELINE);


2020.12.15
I. Researching and implementing solution:

void  CEditListCtrl::SetSubitemColor(int column, int index, DWORD color) 
{ 
	int arrSize = (int) m_arrColors[column].GetSize();
	if (index >= arrSize) {
		m_arrColors[column].SetSize(arrSize + 3);
	}
	m_arrColors[column][index] = color; 
}


2020.12.16
I. Researching and implementing solution:

// Radio buttons for Line Select Mode
void CMapSelectDlg::OnClickedMapInline() { DoSelectMode(); }
void CMapSelectDlg::OnMapUserLine()      { DoSelectMode(); }
void CMapSelectDlg::OnMapXline()         { DoSelectMode(); }
void CMapSelectDlg::DoSelectMode() 
{
	int oldSelectMode = m_selectMode;
	UpdateData(TRUE);
	if (m_selectMode == eUSERLINE) {
		if (pDoc->GetCurrentUserLinePtr() == NULL) {
			AfxMessageBox ("No user line defined yet");
			m_selectMode = oldSelectMode;
			UpdateData(FALSE);
			return;
		}
		int lineno = pDoc->GetSelectedUserLineNumber();
		SetUserLineData(lineno);

		m_cmbUserLine.EnableWindow(TRUE);
		m_checkShowAllUserLines.EnableWindow(TRUE);
	} else {
		ClearUserLineData();
		m_cmbUserLine.EnableWindow(FALSE);
		m_checkShowAllUserLines.EnableWindow(FALSE);
	}

	pDoc->SetInlineXlineMode((eLineMode)m_selectMode);
    pDoc->ResetAllLines();
	pDoc->LoadData();
	pDoc->UpdateViews();
}

    // Read the Segy data into memory for one segy line.
    int CIMACDoc::LoadData()
    {
	int i;
	int fileCount = GetFileCount();
	if (fileCount == 0) return 0;
        // ...

		// load user line

		CPointArray* pData = GetCurrentUserLinePtr();
		if (pData == NULL) {
			AfxMessageBox("No Userline has been selected");
			return -1;
		}    

		for (i=0; i<fileCount; i++) {
			CSegy* pSegy = GetSegyInPtr(i);
			if (!pSegy->isUserLineLoaded(pData)) {

				CString attrName = GetAttr(i);

				// skip loading if this attribute doesn`t appear on any xplot.
				if (!IsAttributeInUse(attrName) && i != segyToUseForOutput) {
					// check if the attribute is needed for a virtual volume
					if (!IsAttributeInVirtualVolumeInUse(attrName)) {
						continue;
					}
				}

				infoDlg.AddString(attrName);
				pSegy->Reset();
				int ntrace = (int) pData->GetCount();
				pSegy->Create(ntrace, pSegy->GetSegyIndexPtr()->GetSampleCount());
				if (pSegy->LoadIndexedLine(GetFile(i), 0, GetInlineXlineMode(), pData) < 0) {
					return -1;
				}
			}
		}
        

        // ...
    }    
    
Where:

fileCount = 13
ntrace = 551

    CString CIMACDoc::GetAttr(int n)
    {
	CString strRet;
	if (n < m_nFile) {
            strRet = m_arrAttributeNames[n];
	}
	return strRet;
    }

Where:    

strRet = "angle_stack_15"

DWORD  GetSampleCount()    { return m_nsamps; }

Where:

m_nsamps = 0

// Reset() must always be called before Create, otherwise you leak memory
void CSegy::Create(int nTrace, int nSamps)
{
	m_nTrace=nTrace;
	m_nSamps=nSamps;
	pInLine =	new int[nTrace];
	pXLine =	new int[nTrace];
	pXCoord =	new double[nTrace];
	pYCoord =	new double[nTrace];
	pData =		new float[nTrace*nSamps];
	pHdr =		new BYTE[nTrace*240];
	pEbcdic =	new BYTE[3200];
	pBinary =	new BYTE[400];
	memset(pData, 0, nTrace * nSamps * sizeof(float));
	memset(pHdr,  0, nTrace * 240 );
}

Where:

m_nTrace = 551
m_nSamps = 651

-----

DWORD  GetLineNumber(int n, int linemode);

	DWORD		m_ntrace;
	DWORD		m_nsamps;
	int			m_sampleInterval;
	DWORD		m_trsize;

-----

CString CIMACDoc::GetFile(int n)
{
	if (n< m_nFile) return m_arrAttributePaths[n];
	return "";
}

m_arrAttributePaths = 0x000001c884669868 {"Z:\\QI-Pro Demo\\Horn River Demo\\Seismic\\demo_angle_stack_15_shift_subset.sgy", ...}

// Use the SegyIndex to read the specifed line from the file.
int	CSegy::LoadIndexedLine(CString fname, int nLine, eLineMode linemode, CPointArray *pUserLine )
{
	return LoadIndexedLine( fname, nLine, linemode, &m_index, pUserLine );
}

int CSegy::LoadIndexedLine(CString fname, int nLine, eLineMode linemode, CSegyIndex *pIndex, CPointArray *pUserLine )
{
	CFile f;
	CFileException ex;
	DWORD *pIndexLine, *pInline, *pXline;
	DWORD trsize;
	int nLoaded = 0;

	if (linemode == eUSERLINE && pUserLine == NULL) return -1;

	if (fname.IsEmpty()) return -1;

	trsize = m_nSamps * 4 + 240;
	pBuf = new BYTE[trsize];

	if (!m_file.Open(fname, CFile::modeRead|CFile::shareDenyWrite, &ex)) {
		ex.GetErrorMessage((char *)pBuf,255);
		AfxMessageBox((char *)pBuf);
		delete pBuf;
		return -1;
	} else {
		if(m_file.Read(pEbcdic, 3200) != 3200) {
			m_file.Close();
			delete pBuf;
			return -1;
		}
		if(m_file.Read(pBinary, 400) != 400) {
			m_file.Close();
			delete pBuf;
			return -1;
		}

        DWORD nsamp;
        CSegyUtil segyUtil;
        segyUtil.SegyPropertiesFromHeader(pBinary, GetHeaderMap(), &nsamp, (DWORD *)&m_nSi, (DWORD *)&m_nFormatCode, &m_dataEndian);

		if (m_nFormatCode != 1 && m_nFormatCode != 5 && m_nFormatCode != 6) {
			AfxMessageBox("Unsupported Seg-Y format");
			delete pBuf;
			return -1;
		}

		if (linemode == eINLINE) {
			pIndexLine = pIndex->m_pInline;

		} else if (linemode == eXLINE) {
			pIndexLine = pIndex->m_pXline;

		} else if (linemode == eUSERLINE) {
			pInline = pIndex->m_pInline;
			pXline  = pIndex->m_pXline;
			nLine = 0;
			SetUserLinePtr(pUserLine);
		} else {
			return -1; // unsupported linemode
		}

		// the default is to load the first line
		if (linemode != eUSERLINE) {
			if (nLine == 0) nLine = pIndex->GetFirstLiveLine(linemode);
		}

		// check the trace length. If it`s different from the index we have to adjust.
		double segyNsamps = this->m_nSamps;
		double indexNsamps = pIndex->m_nsamps;
		bool bAdjustNsamp = (this->m_nSamps != pIndex->m_nsamps);
		
		// TRACE("%s, %d, %d\n", fname,  this->m_nSamps, pIndex->m_nsamps);

		// zip through the index and only read the traces that we need.
		if (linemode != eUSERLINE) {
			for (int i=0; i<(int)pIndex->GetTraceCount(); i++) {
				if (pIndex->m_bIgnore[i] == TRUE ) continue;
				if (pIndexLine[i] == (DWORD)nLine) {
					double offset = pIndex->m_pOffset[i];
					if (bAdjustNsamp) {
						offset -= 3600;
						double fTraceCount = offset / (240 + indexNsamps * 4);
						offset =  fTraceCount * (240 + segyNsamps * 4) + 3600;
					}
					LARGE_INTEGER li;
					li.QuadPart = (__int64) offset;
					SetFilePointer((HANDLE)m_file.m_hFile, li.LowPart, &li.HighPart, FILE_BEGIN);
					if(m_file.Read(pBuf, trsize) != trsize) {
						break; // TODO: check for errors here.
					}
					SetIndexedTrace(pBuf, nLoaded++);
				}
			}
		} else {
			DWORD ixTrace = 0;
			for (int i=0; i<pUserLine->GetCount(); i++) {
				int userInline = pUserLine->GetAt(i).x;
				int userXline  = pUserLine->GetAt(i).y;
				if (userInline < 0) userInline = -userInline; // remove the flag
				BOOL bIgnore;
				double offset = pIndex->FindTrace(userInline, userXline, ixTrace, bIgnore);
				if (bIgnore == TRUE ) continue;
				if (bAdjustNsamp) {
					offset -= 3600;
					double fTraceCount = offset / (240 + indexNsamps * 4);
					offset =  fTraceCount * (240 + segyNsamps * 4) + 3600;
				}
				LARGE_INTEGER li;
				li.QuadPart = (__int64) offset;
				SetFilePointer((HANDLE)m_file.m_hFile, li.LowPart, &li.HighPart, FILE_BEGIN);
				if(m_file.Read(pBuf, trsize) != trsize) {
					break; // TODO: check for errors here.
				}
				SetIndexedTrace(pBuf, nLoaded++);
			}
		}

		m_file.Close(); 
		delete pBuf;
	}

	m_currentLineNumber = nLine;
	m_inlineXlineMode = linemode;
	SetTraceCount(nLoaded);
	return nLoaded;
}

	trsize = m_nSamps * 4 + 240;
	pBuf = new BYTE[trsize];

-> Why is the above 4 + 240?
        
fname = "Z:\\QI-Pro Demo\\Horn River Demo\\Seismic\\demo_E_computed_shift_subset.sgy"        

CHeaderMap *GetHeaderMap()     { return &m_headerMap; }

m_headerMap
{sampleInterval={m_index=-572662307 m_type=-572662307 m_size=eVAR_1BYTE | eVAR_4BYTE | -572662312 (-572662307) ...} ...}
    CObject: {...}
    sampleInterval: {m_index=-572662307 m_type=-572662307 m_size=eVAR_1BYTE | eVAR_4BYTE | -572662312 (-572662307) ...}
    nSamps: {m_index=-572662307 m_type=-572662307 m_size=eVAR_1BYTE | eVAR_4BYTE | -572662312 (-572662307) ...}
    formatCode: {m_index=-572662307 m_type=-572662307 m_size=eVAR_1BYTE | eVAR_4BYTE | -572662312 (-572662307) ...}
    coordUnits: {m_index=-572662307 m_type=-572662307 m_size=eVAR_1BYTE | eVAR_4BYTE | -572662312 (-572662307) ...}


else if (linemode == eUSERLINE) {
			pInline = pIndex->m_pInline;
			pXline  = pIndex->m_pXline;
			nLine = 0;
			SetUserLinePtr(pUserLine);
		}

void    SetUserLinePtr(CPointArray *ptr) { m_userLinePtr = ptr; }

m_userLinePtr = 0x000001c88b4bd480 {m_pData=0x000001c88b4c7f80 {x=5450 y=1243} m_nSize=551 m_nMaxSize=1000 ...}

-----

	CHeaderMap *pMap = &m_headerMap;
	pInLine[n]= (int)pMap->inlineNum.GetValue(pTrace);
	pXLine[n] = (int)pMap->xlineNum.GetValue(pTrace);

*pMap
{sampleInterval={m_index=16 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...} nSamps={m_index=20 m_type=eUINT (0) ...} ...}
    CObject: {...}
    sampleInterval: {m_index=16 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    nSamps: {m_index=20 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    formatCode: {m_index=24 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    coordUnits: {m_index=54 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}
    revisionNumber: {m_index=300 m_type=eUINT (0) m_size=eVAR_2BYTE (2) ...}


InLine[n]
5450
pXLine[n]
1243

-----

LoadIndexedLine(CString fname, ...):

for (int i=0; i<pUserLine->GetCount(); i++) {
}        

pUserLine->GetCount()
551

Where are the 551 user lines in "Classified Seismic Volume"?

offset = 8689176.0000000000

li.QuadPart = (__int64) offset;
li.QuadPart = 9474120

SetTraceCount(nLoaded);
nLoaded = 3


SetUserLinePtr(pUserLine);
pUserLine = 0x000001c88b4bd480 {m_pData=0x000001c88b4c7f80 {x=5450 y=1243} m_nSize=551 m_nMaxSize=1000 ...}

-Is IMACDOC::GetCurrentUserLinePtr() what is used to get the lines to "Lwr_Keg_River", "Muskwa", etc?

-----
1)

// Load virtual volumes
// if *attributeName is NULL then load all the volumes that are in use.
void CIMACDoc::LoadVirtualVolumes(CModelessInfoDlg *pInfoDlg, const CUPDUPDATA *pCUPDUPData, CString *attributeName)
{
	int vvCount = GetVVAttributeCount();
    
}    

vvCount = 11

CPointArray *CIMACDoc::GetCurrentUserLinePtr() 
{ 
	return GetUserLinePtr(m_userLineSelected); 
}

m_userLineSelected = 1

CDoublePointArray *CIMACDoc::GetUserLineSmoothedCoordinatePtr(DWORD i)
{
    CDoublePointArray *pReturnVal = NULL;
    if (i < GetUserLineCount()) {
        pReturnVal = (CDoublePointArray *)m_userLineSmoothedCoordinateArray.GetAt(i);
    }
    return pReturnVal;
}

    if (GetInlineXlineMode() == eUSERLINE) {
        pSegyOut->SetUserLinePtr(GetCurrentUserLinePtr());
        pSegyOut->SetUserLineSmoothedCoordinatePtr(GetCurrentUserLineSmoothedCoordinatePtr());
    } else {
        pSegyOut->SetUserLinePtr(NULL);
        pSegyOut->SetUserLineSmoothedCoordinatePtr(NULL);
    }

GetUserLineCount()
3

m_userLineSmoothedCoordinateArray = {m_pData=0x000001c88b4c4070 {0x000001c88b4bcfb0} m_nSize=3 m_nMaxSize=1000 ...}

-		pReturnVal	0x000001c88b4bcae0 {m_pData=0x0000000000000000 <NULL> m_nSize=0 m_nMaxSize=0 ...}	CArray<CDoublePoint,CDoublePoint> *
-		CObject	{...}	CObject
+		__vfptr	0x00007ff612d6f5a8 {QI-Pro.exe!void(* CArray<CDoublePoint,CDoublePoint>::`vftable'[6])()} {0x00007ff612ad50c3 {QI-Pro.exe!CObject::GetRuntimeClass(void)const }, ...}	void * * '
+		m_pData	0x0000000000000000 <NULL>	CDoublePoint *
		m_nSize	0	__int64
		m_nMaxSize	0	__int64
		m_nGrowBy	1000	__int64

void CIMACDoc::ProjectWellsToCurrentLine()
{
	CSegy *pSegyOut = GetSegyOutPtr();

	// loop through the list of wells and project any deviation data onto the current line.
	WellList *pWellList = GetWellListPtr();
	POSITION pos = pWellList->GetHeadPosition();
	while (pos) {
		CWell *pWell = pWellList->GetNext(pos);

		// Project the deviation onto the current line.
		pSegyOut->ComputeDeviatedProjection(pWell);
	}
}

Where:

*pWellList
{m_pNodeHead=0x000001c886041248 {pNext=0x000001c886041260 {pNext=0x000001c886041278 {pNext=0x000001c886041290 {...} ...} ...} ...} ...}
    CObject: {...}
    m_pNodeHead: 0x000001c886041248 {pNext=0x000001c886041260 {pNext=0x000001c886041278 {pNext=0x000001c886041290 {pNext=...} ...} ...} ...}
    m_pNodeTail: 0x000001c886041290 {pNext=0x0000000000000000 <NULL> pPrev=0x000001c886041278 {pNext=0x000001c886041290 {...} ...} ...}
    m_nCount: 4
    m_pNodeFree: 0x000001c8860412a8 {pNext=0x000001c8860412c0 {pNext=0x000001c8860412d8 {pNext=0x000001c8860412f0 {pNext=...} ...} ...} ...}
    m_pBlocks: 0x000001c886041240 {pNext=0x0000000000000000 <NULL> }
    m_nBlockSize: 10

	pDocTemplate->AddFrameTemplate(
        new CFrameTemplate( 
			menuID,
            RUNTIME_CLASS( CChildFrame ), 
            RUNTIME_CLASS( CIMACView ), 
            ID_VIEW_VIEW1, 
            SW_SHOWNORMAL, 
            TRUE ) );

2)
                                            
return ntrace;

Where:
ntrace = 551                                            
                                            
3)

void CIMACDoc::UpdateViews(BOOL bSkipCombo):

	// Time Slice...
	if (m_timeSlice.isActive() && m_timeSlice.isShowSliceFlag()) {
		if (m_timeSlice.isLoadSliceFlag()) {
			if (!m_timeSlice.Create(GetFileCount()+GetVirtualVolumeCount(), GetSegyInPtr(0)->GetSegyIndexPtr())) {
				m_timeSlice.Destroy();
				m_timeSlice.SetShowSliceFlag(FALSE);
			}
		}
		LoadTimeSlice(&m_timeSlice);
		m_timeSlice.SetLoadSliceFlag(FALSE);
	}

        
-		m_timeSlice	{m_inlineMin=5440 m_inlineMax=5700 m_xlineMin=1225 ...}	CTimeSlice
+		CObject	{...}	CObject
		m_inlineMin	5440	unsigned long
		m_inlineMax	5700	unsigned long
		m_xlineMin	1225	unsigned long
		m_xlineMax	1500	unsigned long
		m_sampleCount	72036	unsigned long
+		m_pIndex	0x0000000000000000 <NULL>	CSegyIndex *
+		m_pSliceData	0x000001c88c7b4ee0 {9.00000000}	float *
+		m_pSliceDead	0x000001c88c7fb4b0 {0}	int *
+		m_pData	0x000001c88466a718 {0x000001c88c940a80 {676.302246}, 0x000001c88ca86050 {5.40736011e-37}, 0x000001c88cacc620 {...}, ...}	float *[200]
+		m_bDataLoaded	0x000001c88466ad58 {1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...}	int[200]
+		m_arrAttrNames	{m_pData=0x000001c885f42430 "angle_stack_15" m_nSize=200 m_nMaxSize=200 ...}	CStringArray
+		m_arrFileNames	{m_pData=0x000001c8860b9b50 "Z:\\QI-Pro Demo\\Horn River Demo\\Seismic\\demo_angle_stack_15_shift_subset.sgy" ...}	CStringArray
+		m_arrCoords	{m_pData=0x000001c88e5aa070 {x=628411.00000000000 y=6623159.0000000000 } m_nSize=72036 m_nMaxSize=73000 ...}	CArray<CDoublePoint,CDoublePoint>
		m_volumeCount	13	int
		m_sliceTime	-25	int
+		m_sliceReference	"Mid_Dev_Carb"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		m_bShowSliceFlag	1	int
		m_bLoadSliceFlag	0	int
		m_bActiveFlag	1	int

*** Notice "Mid_Dev_Carb"! ***                 

-----

	CString defaultString = CHorizon::TIME_ZERO;
	m_cmbSlice.AddString(defaultString);
	CHorizon *pHor = pDoc->GetHorizonDataPtr();
	for (int i=0; i<pHor->GetHorizonCount(); i++) {
		CString horizonName = pHor->GetName(i);
		m_cmbSlice.AddString(horizonName);
	}

horizonName = " Lwr_Keg_River"
horizonName = "Mid_Dev_Carb"
horizonName = "Muskwa"

	// enable/disable controls
	m_btnSliceButton.EnableWindow(m_bShowSliceFlag);

m_bShowSliceFlag = 1

-		pHor	0x000001eaa736da80 {m_pY=0x000001eaa83b6070 {6620608.5000000000} m_pX=0x000001eaa8077070 {616883.18999999994} ...}	CHorizon *
+		CObject	{...}	CObject
+		m_pY	0x000001eaa83b6070 {6620608.5000000000}	double *
+		m_pX	0x000001eaa8077070 {616883.18999999994}	double *
+		m_pInline	0x000001eaa86f3070 {5053}	int *
+		m_pXline	0x000001eaa8895070 {1153}	int *
		m_nRecs	418248	int
		m_nWords	3	int
		m_nHeader	0	int
		m_nullValue	-999.250000	float
+		m_pHorizon	0x000001eaa736dab8 {0x000001eaa8a32070 {1024.36633}, 0x000001eaa8bd5070 {986.298523}, 0x000001eaa8d7c070 {...}, ...}	float *[400]
+		m_displayMode	0x000001eaa736e738 {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, ...}	int[400]
+		m_lineWidth	0x000001eaa736ed78 {2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, ...}	int[400]
+		m_color	0x000001eaa736f3b8 {16720016, 16719904, 65280, 251658240, 251658240, 251658240, 251658240, 251658240, ...}	unsigned long[400]
+		m_arrNames	{m_pData=0x000001eaa0dff390 " Lwr_Keg_River" m_nSize=3 m_nMaxSize=3 ...}	CStringArray
		m_inLineMin	5053	int
		m_inLineMax	5718	int
		m_xLineMin	1153	int
		m_xLineMax	1780	int
		m_yMin	6620608.5000000000	double
		m_yMax	6640085.5000000000	double
		m_xMin	616244.13000000000	double
		m_xMax	636821.63000000000	double

CHorizon::LoadCSV()

...


CHorizon::LoadFile()

...

CHorizon::LoadHorizon()

...

CHorizon::LoadTxtFile()

...

CIMACDoc::AppendHorizonFile()

...

CHorizon::AllocateHorizonArrays()

--------------------------------------------------------------------------------

// load user line data from the document
void CMapSelectDlg::SetUserLineData(DWORD lineNumber)
{
	if (lineNumber >= pDoc->GetUserLineCount()) return;	

	// delete local user line data
	ClearUserLineData();

	// get the segyindex pointer
	CSegy *pSegy = pDoc->GetFirstLoadedSegyPtr();
	if (pSegy == NULL) return;
	CSegyIndex *pIndex = pSegy->GetSegyIndexPtr();
	if (pIndex == NULL) return;
	if (pIndex->GetTraceCount() == 0) return;

	// reload local user line data
	CPointArray *pLocalData = m_mapView.GetUserLine();
	CDoublePointArray *pLocalCoords = m_mapView.GetUserCoords();
	pLocalData->RemoveAll();
	pLocalCoords->RemoveAll();
	CPointArray *pDocData = pDoc->GetUserLinePtr(lineNumber);
	if (pDocData) {
		m_mapList.DeleteAllItems();
		for (int i=0, j=0; i<pDocData->GetCount(); i++) {
			CPoint pt = pDocData->GetAt(i);
			if (pt.x < 0) continue;  // skip the interpolated points
			pLocalData->SetAtGrow(j, pt);
			double xcoord, ycoord;
			pIndex->FindTraceCoordinates(pt.x, pt.y, xcoord, ycoord);
			pLocalCoords->SetAtGrow(j, CDoublePoint(xcoord, ycoord));
			AddItemToListCtrl (j, pt.x, pt.y);
			j++;
		}
	}
#if 0
    TRACE("DocData:\n");
    CDoublePointArray *pDoubleData = pDoc->GetUserLineSmoothedCoordinatePtr(lineNumber);
    for (int i = 0; i < pDocData->GetCount(); i++) {
        CPoint pt = pDocData->GetAt(i);
        CDoublePoint dpt;
        if (i < pDoubleData->GetCount()) {
            dpt = pDoubleData->GetAt(i);
        }
        TRACE("i=%d inline=%d xline=%d x=%f y=%f\n", i, pt.x, pt.y, dpt.x, dpt.y);
    }
    TRACE("MapData:\n");
    for (int i = 0; i<pLocalData->GetCount(); i++) {
        CPoint pt = pLocalData->GetAt(i);
        CDoublePoint dpt = pLocalCoords->GetAt(i);
        TRACE("i=%d inline=%d xline=%d x=%f y=%f\n", i, pt.x, pt.y, dpt.x, dpt.y);
    }
#endif

	m_mapView.SetDigitizeIndex();
}

Where:

pDocData->GetCount()
551

// Add a single item to the list control.
void CMapSelectDlg::AddItemToListCtrl(int nitem, DWORD inLine, DWORD xLine)
{
	// update the list control in the parent dialog
	CString txt;
	txt.Format("%d", nitem + 1);
	int iStat = m_mapList.InsertItem(nitem, txt);
	txt.Format("%d", inLine);
	m_mapList.SetItem(nitem, 1, LVIF_TEXT, txt, 0, 0, 0, 0);
	txt.Format("%d", xLine);
	m_mapList.SetItem(nitem, 2, LVIF_TEXT, txt, 0, 0, 0, 0);
}

	// user line combo box
	m_cmbUserLine.ResetContent();
	DWORD userLineCount = pDoc->GetUserLineCount();
	for (DWORD i=0; i<userLineCount; i++) {
		m_cmbUserLine.AddString(pDoc->GetUserLineName( i ));
	}

        
-----

void CMapView::OnPaint()
{
    // ...
	// draw the timeslice
	CTimeSlice *pTimeSlice = pDoc->GetTimeSlicePtr();
	float *pSlice = pTimeSlice->GetSlicePtr();
	if (pTimeSlice->isActive() && pTimeSlice->isShowSliceFlag() && pSlice!=NULL) {
		CRect rcItem;
		CDoublePointArray *pSliceCoords = pTimeSlice->GetCoordPtr();
		DWORD inlineMin, inlineMax, xlineMin, xlineMax;
		CSegyIndex *pIndex = pDoc->GetFirstLoadedSegyPtr()->GetSegyIndexPtr();
		pIndex->GetLineMinMax(inlineMin, inlineMax, xlineMin, xlineMax);
		int sliceIndex = 0;
		for (DWORD j=inlineMin; j<inlineMax; j++) {
			for (DWORD k=xlineMin; k<xlineMax; k++, sliceIndex++) {
				if (pSlice[sliceIndex] == NODATA) continue;
				CDoublePoint sliceCoord;
				sliceCoord = pSliceCoords->GetAt(sliceIndex);
				rcItem.left = Sx(sliceCoord.x) - nHalf;
				rcItem.right = rcItem.left + nPixel;
				rcItem.top = Sy(sliceCoord.y) - nHalf;
				rcItem.bottom = rcItem.top + nPixel;
				int sampleValue = (int)pSlice[sliceIndex];
				if (sampleValue < 0) {
					sampleValue = -sampleValue;
				}
				if (sampleValue >= nClass) {
					sampleValue = 0;	// Check for UNCLASSIFIED
				}
				pDC->FillRect(rcItem, &pTraceBrush[sampleValue]);
			}
		}
	}
    // ...
	// draw the line which is currently being displayed in the Seismic window
	if (pDoc->GetInlineXlineMode() != eUSERLINE) {
		iLine = pDoc->GetDisplayLine();
		if (iLine == 0) iLine = pIndex->GetFirstLiveLine(pDoc->GetInlineXlineMode());
		if (pIndex->GetLineEndCoords(iLine, pDoc->GetInlineXlineMode(), x1, y1, x2, y2) == 0) {
			DrawSingleLine(pDC, &fatwhitePen, CPoint(Sx(x1), Sy(y1)), CPoint(Sx(x2), Sy(y2)));
			pDC->SelectObject(&redPen);
			DrawLineAndText(pDC, iLine, CPoint(Sx(x1), Sy(y1)), CPoint(Sx(x2), Sy(y2)));
		}
	}
	// draw the trace that is being tracked from the Seismic window.
	CSize size;
	CRect rect;
	DWORD trackInLine, trackXLine;
	pDoc->GetTrackTrace(trackInLine, trackXLine);
	pIndex->FindTraceCoordinates(trackInLine, trackXLine, x1, y1);
	CPoint ptTrack(Sx(x1), Sy(y1));
	pDC->MoveTo(ptTrack + CSize(-5, -5));
	pDC->LineTo(ptTrack + CSize( 5,  5));
	pDC->MoveTo(ptTrack + CSize(-5,  5));
	pDC->LineTo(ptTrack + CSize( 5, -5));
    if (pDoc->GetInlineXlineMode() == eUSERLINE) {
        txt.Format("%d,%d", trackInLine, trackXLine);
    } else {
        iLine = (pDoc->GetInlineXlineMode() == eINLINE) ? trackXLine : trackInLine;
        txt.Format("%d", iLine);
    }
	size = pDC->GetTextExtent(txt);
	rect.top    = ptTrack.y + 5;
	rect.bottom = rect.top + size.cy;
	rect.left   = ptTrack.x - size.cx/2;
	rect.right  = rect.left + size.cx;
	pDC->DrawText(txt, rect, DT_CENTER | DT_VCENTER| DT_SINGLELINE);

    // ...

	// draw all user lines not selected 
	pDC->SelectObject(&greyPen);
	if (pParent->GetShowAllUseLines() && pDoc->GetInlineXlineMode() == eUSERLINE) {
		for (DWORD i = 0; i < pDoc->GetUserLineCount(); i++) {
			if (i == pDoc->GetSelectedUserLineNumber()) continue;
			CPointArray* pUserLine = pDoc->GetUserLinePtr(i);
			for (int j = 0; j < pUserLine->GetCount(); j++) {
				CPoint pt = pUserLine->GetAt(j);
				if (pt.x < 0) continue;  // skip the interpolated points
				double xcoord, ycoord;
				pIndex->FindTraceCoordinates(pt.x, pt.y, xcoord, ycoord);
				int hello = Sx(xcoord);
				if (j == 0)
					pDC->MoveTo(Sx(xcoord), Sy(ycoord));
				else
					pDC->LineTo(Sx(xcoord), Sy(ycoord));
			}
		}
	 }
	// draw the USER line
	for (int iteration=0; iteration<2; iteration++) {
		if (iteration == 0) 
			pDC->SelectObject(&fatwhitePen);
		else
			pDC->SelectObject(&redPen);

		for (int i=0; i<m_userLine.GetCount(); i++) {
			if (i == 0) 
				pDC->MoveTo(Sx(m_userCoord[i].x), Sy(m_userCoord[i].y));
			else
				pDC->LineTo(Sx(m_userCoord[i].x), Sy(m_userCoord[i].y));
		}
	}
	// draw the USER line text on each vertex
	for (int i=0; i<m_userLine.GetCount(); i++) {
		txt.Format("%d", i + 1);
		CPoint rcPoint;
		rcPoint.x = Sx(m_userCoord[i].x);
		rcPoint.y = Sy(m_userCoord[i].y);
		DrawMapText(pDC, rcPoint, txt);
	}    
}

Where:

1)

-		pTimeSlice	0x000001eaa0aea6e0 {m_inlineMin=5440 m_inlineMax=5700 m_xlineMin=1225 ...}	CTimeSlice *
+		CObject	{...}	CObject
		m_inlineMin	5440	unsigned long
		m_inlineMax	5700	unsigned long
		m_xlineMin	1225	unsigned long
		m_xlineMax	1500	unsigned long
		m_sampleCount	72036	unsigned long
+		m_pIndex	0x0000000000000000 <NULL>	CSegyIndex *
+		m_pSliceData	0x000001eaa736fa90 {9.00000000}	float *
+		m_pSliceDead	0x000001eaa73b6060 {0}	int *
+		m_pData	0x000001eaa0aea718 {0x000001eaa73fc630 {676.302246}, 0x000001eaa7442c00 {5.40736011e-37}, 0x000001eaa74891d0 {...}, ...}	float *[200]
+		m_bDataLoaded	0x000001eaa0aead58 {1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, ...}	int[200]
+		m_arrAttrNames	{m_pData=0x000001eaa0c42430 "angle_stack_15" m_nSize=200 m_nMaxSize=200 ...}	CStringArray
+		m_arrFileNames	{m_pData=0x000001eaa0db9630 "Z:\\QI-Pro Demo\\Horn River Demo\\Seismic\\demo_angle_stack_15_shift_subset.sgy" ...}	CStringArray
+		m_arrCoords	{m_pData=0x000001eaa90d8070 {x=628411.00000000000 y=6623159.0000000000 } m_nSize=72036 m_nMaxSize=73000 ...}	CArray<CDoublePoint,CDoublePoint>
		m_volumeCount	13	int
		m_sliceTime	-25	int
+		m_sliceReference	"Mid_Dev_Carb"	ATL::CStringT<char,StrTraitMFC_DLL<char,ATL::ChTraitsCRT<char>>>
		m_bShowSliceFlag	1	int
		m_bLoadSliceFlag	0	int
		m_bActiveFlag	1	int


inlineMin = 5440
inlineMax = 5700

xlineMin = 1225
xlineMax = 1500
                
2)

pDC->DrawText(txt, rect, DT_CENTER | DT_VCENTER| DT_SINGLELINE);

txt = "-1,-1"

	// draw the USER line text on each vertex
	for (int i=0; i<m_userLine.GetCount(); i++) {
		txt.Format("%d", i + 1);
		CPoint rcPoint;
		rcPoint.x = Sx(m_userCoord[i].x);
		rcPoint.y = Sy(m_userCoord[i].y);
		DrawMapText(pDC, rcPoint, txt);
	}

        
txt = "1"

m_userLine.GetCount()
6

CPointArray		    m_userLine;
CDoublePointArray	m_userCoord;

	void  SetSliceReference(CString ref) { m_sliceReference = ref; }
	CString GetSliceReference()    { return m_sliceReference; }

2020.12.17
I. Researching and implementing solution:
Scrum:
-See if "Show Time Slice" is checked in Map & Timeslices
-Put it in the Classified Seismic Volume "OnDraw"
-Frame and a View class 
-IMACView, find the code that draws the horizons; the way you draw it will be exactly like how a horizon is drawn, but it won`t actually be a horizon itself 
-Just call it time slice 

Scrum video link: https://web.microsoftstream.com/video/80c49d2f-14b9-4f30-9219-442dd0a1a733:
1:43ff:
Q: What is P impedance (Zp) vs Vp/Vs ratio?  How does this help to find a zone of interest in a seismic section?

-> Ask Carl Reine for an expert answer 
-Brenda: Petrophysics, a 2 year program.  
-Kevin: Initially there was just one receiver on the surface, so when the shot went off it would vibrate. The sound would reflect off of the different layers, and record vertically.  With the technique we use, quantitative interpretation, there is a 3-component (axis, x, y and z, or in other words, vertically, horizontally in-line, and horizontally crossline) geophone sitting on the surface.  There is one component of the sound called the sheer wave, so it records all kinds of components, the compressional wave, which is faster, and the sheer wave, so when you see Vp/Vs it is the velocity of the primary wave vs the velocity of the sheer wave.  
-In a reservior full of fluid such as oil or gas, the sheer wave won`t travel through a fluid, but the primary wave will.  
-When you have two molecules and one pushes the next, that is what the primary wave is like:  -> <-
-When you have a sheer (or perpendicular?) wave: ↑ <- the sheer wave won`t propagate.
-Brenda: Yes, the molecules are too far apart
-Kevin: So you can see those properties will highlight where the reservoir is  

-----

int sliceTime = pTimeSlice->GetSliceTime();
sliceTime = -25

See this for UI mock-up: https://web.microsoftstream.com/video/80c49d2f-14b9-4f30-9219-442dd0a1a733

-----

CIMACView::OnDraw:

-This is the part that updates the "Classified Seismic Volume" based on new values selected in the "Color Bar Editor":

	if (pDoc->m_bNewColorFlag & 0x1) {
		pDoc->m_bNewColorFlag ^= 0x1;		// xor the bit off
		try {
			COLORREF* colorbar = pDoc->GetColorBar();
			for (int i = 0; i < nClass; i++) {
				if (pTraceBrush[i] != NULL) delete pTraceBrush[i];
				pTraceBrush[i] = new CBrush(colorbar[i]);
				if (pTraceBrush[i] == NULL) {
					AfxMessageBox("Error allocating trace brush in IMACView");
					return;
				}
			}
		}
		catch (...) {
			AfxMessageBox("Error allocating memory for color brush in IMACView");
			return;
		}
	}

        
-Starting to get details on drawing horizons:

	// get some horizon info
	pDC->SelectObject(m_pFontSmall);
	CHorizon* pHorizon = pDoc->GetHorizonDataPtr();
	int horizonCount = pHorizon->GetHorizonCount();
	int horizonRecordCount = pHorizon->GetRecordCount();
	int currIndex = 0;
	int prevIndex = -1;
	int tstart = pDoc->GetStartTime();
	int tend = pDoc->GetEndTime();

	// create color pens for the corresponding horizons.
	for (int i = 0; i < horizonCount; i++) {
		if (pHorizonPen[i] != NULL) delete pHorizonPen[i];
		COLORREF horizonColor = pHorizon->GetLineColor(i);
		horizonColor &= 0x00FFFFFF; // color bits only.
		pHorizonPen[i] = new CPen(PS_SOLID, 1, horizonColor);
		if (pHorizonPen[i] == NULL) {
			CString txt;
			txt.Format("Error allocating color pen for horizon %d", i);
			AfxMessageBox(txt);
			return;
		}
	}

-Start drawing the horizons:

	//	Draw the horizons and wiggle overlay
	for (int i = 0, jtr = 0, trnum = firstTr; i < m_nTrace; i++, jtr++, trnum += incrementTr) {

		if (flatteningOffsets[i] == NULL_HORIZON_VALUE) continue;

		// check if we have an embedded well to plot, if so open a space.
		int wellTrace = -1;
		for (int iWell = 0; iWell < m_wellCount; iWell++) {
			wellTrace = m_listWellTraces[iWell];
			if (trnum == wellTrace) {
				jtr += pDoc->GetColorTrackWidth() + 2;
				break;
			}
		}

		float vAccumulator;
		DWORD traceOriginX = SIDE + jtr * m_hScale + (DWORD)(m_hScale / 2.0);

		if (pDoc->GetWiggleDisplayToggle()) {
			// plot the wiggle, scale to proper excursion
			if (pDoc->GetWiggleDrawingMode() > eNO_WIGGLE && pWiggleSegy && i % pDoc->GetWiggleTraceDecimation() == 0) {
				float* pWiggleData = pWiggleSegy->GetTraceDataPtr(trnum, m_startTime);
				vAccumulator = TOP + ((flatteningOffsets[i] * 1000 / si) * m_vScale);
				DWORD plotY = (DWORD)vAccumulator;
				pDC->SelectObject(m_normPen);

				int dx = 0;
				int prevDx = 0;

				// Wiggle Sinc Interpolation
				if (pDoc->GetWiggleInterpolationMode() == eWIGGLE_SINC) {
					double indPercentage = (double)(m_sampCount) / ((m_vScale * m_sampCount));

					for (int ind = 0; ind < m_vScale * m_sampCount; ind++) {
						double interpolatedSample = 0.0;
						for (int j = 0; j < m_sampCount; j++) {
							float sampleValue = pWiggleData[j];
							if (pDoc->GetWiggleClassifiedVolumeCheck()) {
								if (sampleValue == UNCLASSIFIED) {
									sampleValue = 0;
								}
								while (sampleValue >= SELECTION_BIAS) {
									sampleValue -= SELECTION_BIAS;
								}
							}
							interpolatedSample += sampleValue * sinc((ind * indPercentage) - j);
						}

						float dx_f = (float)(interpolatedSample * excursion / meanAllTraces);
						if (std::abs(dx_f) > m_hScale * pDoc->GetWiggleTraceClip()) { // check for trace clip
							if (dx_f > 0) dx_f = m_hScale * pDoc->GetWiggleTraceClip();
							else dx_f = -(m_hScale * pDoc->GetWiggleTraceClip());
						}
						dx = (int)std::round(dx_f);

						if (ind == 0) {
							pDC->MoveTo(traceOriginX + dx, plotY);
							prevDx = dx;
						}
						plotY = (DWORD)(vAccumulator++);  // increment vAccumulator here
						if (vAccumulator < TOP || vAccumulator + m_vScale > TOP + ((m_endTime * 1000 / si) * m_vScale)) {
							//pDC->LineTo(traceOriginX + dx, plotY);	// draw line to this point from previous point
							pDC->MoveTo(traceOriginX + dx, plotY);	// go back to where we started 
							continue;
						}

						pDC->LineTo(traceOriginX + dx, plotY);	// draw line to this point from previous point

						// draw the fill
						if (pDoc->GetWiggleDrawingMode() == eWIGGLE_FILL) {
							if (dx > 0) {
								pDC->LineTo(traceOriginX, plotY);  // draw line to origin
								pDC->MoveTo(traceOriginX + dx, plotY);	// go back to where we started 
							}
						}
					}
				}

				// Wiggle Linear Interpolation
				else if (pDoc->GetWiggleInterpolationMode() == eWIGGLE_LINEAR) {

					for (int ind = 0; ind < m_sampCount; ind++) {
						float sampleValue = pWiggleData[ind];
						if (pDoc->GetWiggleClassifiedVolumeCheck()) {
							if (sampleValue == UNCLASSIFIED) {
								sampleValue = 0;
							}
							while (sampleValue >= SELECTION_BIAS) {
								sampleValue -= SELECTION_BIAS;
							}
						}

						float dx_f = 0;
						if (meanAllTraces != 0.0) dx_f = (float)(sampleValue * excursion / meanAllTraces);
						if (std::abs(dx_f) > m_hScale * pDoc->GetWiggleTraceClip()) { // check for trace clip
							if (dx_f > 0) dx_f = m_hScale * pDoc->GetWiggleTraceClip();
							else dx_f = -(m_hScale * pDoc->GetWiggleTraceClip());
						}
						dx = (int)std::round(dx_f);

						if (ind == 0) {
							pDC->MoveTo(traceOriginX + dx, plotY);
							prevDx = dx;
						}
						plotY = (DWORD)(vAccumulator);  // point to the center pixel of the sample.

						// don`t draw above or below classified area
						if (vAccumulator < TOP || vAccumulator + m_vScale > TOP + ((m_endTime * 1000 / si) * m_vScale)) {
							pDC->MoveTo(traceOriginX + dx, plotY);	// go back to where we started 
							vAccumulator += m_vScale;
							prevDx = dx;
							continue;
						}

						pDC->LineTo(traceOriginX + dx, plotY);

						// draw the fill
						if (pDoc->GetWiggleDrawingMode() == eWIGGLE_FILL && ind > 0) {
							int fillStart = (DWORD)(vAccumulator - m_vScale);
							int fillEnd = (DWORD)vAccumulator;
							plotY -= (DWORD)m_vScale; // move y back one sample
							float xIncrement = (float)(dx - prevDx) / (float)(fillEnd - fillStart);
							if (dx > 0 || prevDx > 0) {
								for (int isamp = fillStart; isamp < fillEnd; isamp++) {
									int yIncrement = (isamp - fillStart);
									int fillx = (int)std::round(((float)(isamp - fillStart) * xIncrement) + prevDx);
									if (fillx > 0) {
										pDC->MoveTo(traceOriginX, plotY + yIncrement);
										pDC->LineTo(traceOriginX + fillx, plotY + yIncrement);
									}
								}
							}
							plotY = (DWORD)(vAccumulator); // go back to correct y pos
							pDC->MoveTo(traceOriginX + dx, plotY);
						}
						vAccumulator += m_vScale;
						prevDx = dx;
					}
				}

				//	Wiggle Block Interpolation
				else if (pDoc->GetWiggleInterpolationMode() == e_WIGGLE_BLOCKY) {

					for (int ind = 0; ind < m_sampCount; ind++) {
						float sampleValue = pWiggleData[ind];
						if (pDoc->GetWiggleClassifiedVolumeCheck()) {
							if (sampleValue == UNCLASSIFIED) {
								sampleValue = 0;
							}
							while (sampleValue >= SELECTION_BIAS) {
								sampleValue -= SELECTION_BIAS;
							}
						}

						// don`t draw above or below classified area
						if (vAccumulator < TOP || vAccumulator + m_vScale > TOP + ((m_endTime * 1000 / si) * m_vScale)) {
							pDC->MoveTo(traceOriginX, plotY + (int)m_vScale);
							vAccumulator += m_vScale;
							prevDx = dx;
							continue;
						}

						float dx_f = (float)(sampleValue * excursion / meanAllTraces);
						if (std::abs(dx_f) > m_hScale * pDoc->GetWiggleTraceClip()) { // check for trace clip
							if (dx_f > 0) dx_f = m_hScale * pDoc->GetWiggleTraceClip();
							else dx_f = -(m_hScale * pDoc->GetWiggleTraceClip());
						}
						dx = (int)std::round(dx_f);

						if (ind == 0) {
							pDC->MoveTo(traceOriginX + dx, plotY);
							prevDx = dx;
						}
						pDC->LineTo(traceOriginX + dx, plotY);  // draw horizontal line
						pDC->LineTo(traceOriginX + dx, plotY + (int)m_vScale);
						vAccumulator += m_vScale;

						// draw the fill
						if (pDoc->GetWiggleDrawingMode() == eWIGGLE_FILL) {
							int fillStart = (DWORD)std::round(vAccumulator - m_vScale);
							int fillEnd = (DWORD)vAccumulator;

							if (dx > 0 || prevDx > 0) {
								for (int isamp = fillStart; isamp < fillEnd; isamp++) {
									int yIncrement = isamp - fillStart;
									pDC->MoveTo(traceOriginX, plotY + yIncrement);
									pDC->LineTo(traceOriginX + dx, plotY + yIncrement);
								}
							}

							pDC->MoveTo(traceOriginX + dx, plotY + (int)m_vScale);
						}
						plotY = (DWORD)(vAccumulator);
						prevDx = dx;
					}
				}
			}
		}

		// Draw the horizon data
		if (pDoc->GetHorizonDisplayToggle() && horizonCount > 0 && horizonRecordCount > 0) {
			int inLine = pOutputSegy->GetInline(trnum);
			int xLine = pOutputSegy->GetCrossline(trnum);
			if (prevIndex == -1) {
				prevIndex = 0;
				if (pHorizon->FindIndex(inLine, xLine, prevIndex) < 0) prevIndex = -1;
			} else {
				if (pHorizon->FindIndex(inLine, xLine, currIndex) < 0) {
					currIndex = 0;
					prevIndex = -1;
				} else {
					// at each trace draw all the horizons from the previous trace to this one.
					if (trnum != wellTrace) {
						for (int j = 0; j < horizonCount; j++) {
							if (pHorizon->GetDisplayMode(j) == FALSE) continue;
							float* pHor = pHorizon->GetHorizonDataPtr(j);
							if (pHor[prevIndex] == NULL_HORIZON_VALUE || pHor[currIndex] == NULL_HORIZON_VALUE) {
								// TRACE("skipping j=%d previndex=%d currindex=%d\n", j, prevIndex, currIndex);
								continue;
							}
							if (flatteningOffsets[i - 1] == NULL_HORIZON_VALUE || flatteningOffsets[i] == NULL_HORIZON_VALUE) {
								continue;
							}

							float prevTime = 0;
							float currTime = 0;
							int yPrev;
							int yCurr;
							int xPrev;
							int xCurr;
							if (!pDoc->IsPetrelTimeMode()) {
								prevTime = pHor[prevIndex];
								currTime = pHor[currIndex];
							} else {
								prevTime = (int)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pHor[prevIndex];
								currTime = (int)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pHor[currIndex];
							}
							if (currTime < tstart || (tend && currTime > tend)) continue;
							prevTime -= tstart;
							currTime -= tstart;
							yPrev = TOP + ((int)((std::round(flatteningOffsets[i-1]) * 1000 / si) * m_vScale)) + (int)(prevTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
							yCurr = TOP + ((int)((std::round(flatteningOffsets[i]) * 1000 / si) * m_vScale)) + (int)(currTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
							xPrev = traceOriginX - m_hScale / 2;
							xCurr = xPrev + m_hScale;

							// to get straight line for flattened horizon
							if (pDoc->GetFlatteningDisplayToggle() && pDoc->GetFlattenHorizonCheck() && pHorizon->GetName(j) == pDoc->GetFlatteningHorizon()) {
								if (pDoc->IsPetrelTimeMode()) {
									prevTime = (float)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pDoc->GetFlatteningDatum();
									currTime = (float)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pDoc->GetFlatteningDatum();
								}
								else {
									prevTime = (float)pDoc->GetFlatteningDatum();
									currTime = (float)pDoc->GetFlatteningDatum();
								}
								if (currTime < tstart || (tend && currTime > tend)) continue;
								prevTime -= tstart;
								currTime -= tstart;
								yPrev = TOP + (int)(prevTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
								yCurr = TOP + (int)(currTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
							}

							// don`t draw above or below classified area
							if (yPrev < TOP || yCurr < TOP || 
								yPrev > TOP + ((m_endTime * 1000 / si) * m_vScale) + (int)(m_vScale / 2.0) || 
								yCurr > TOP + ((m_endTime * 1000 / si) * m_vScale) + (int)(m_vScale / 2.0))
							{
								continue;
							}

							// save the label coords for later
							if (horizonLabelData[j].firstFound) {
								CString horName = pHorizon->GetName(j);
								horizonLabelData[j].name = horName;
								horizonLabelData[j].lastY = yPrev;
								horizonLabelData[j].lastFound = TRUE;
							}
							else if (!horizonLabelData[j].firstFound) {
								CString horName = pHorizon->GetName(j);
								horizonLabelData[j].name = horName;
								horizonLabelData[j].firstFound = TRUE;
								horizonLabelData[j].firstY = yPrev;
							}
							
							int lineWidth = pHorizon->GetLineWidth(j);
							yPrev -= lineWidth / 2;
							yCurr -= lineWidth / 2;
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev - 1);
							pDC->LineTo(xCurr, yCurr - 1);
							// draw color the correct width
							pDC->SelectObject(pHorizonPen[j]);
							for (int k = 0; k < lineWidth; k++) {
								pDC->MoveTo(xPrev, yPrev++);
								pDC->LineTo(xCurr, yCurr++);
							}
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev);
							pDC->LineTo(xCurr, yCurr);
						}
					}
					prevIndex = currIndex;
				}
			}
		}
	}

	// draw the horizon labels, sort them and plot them in order with no overlap
	for (int m = 0; m < horizonCount; m++) {
		if (horizonLabelData[m].firstFound) {
			leftHorizonPt[leftCount] = horizonLabelData[m].firstY;
			leftHorizonName[leftCount++] = horizonLabelData[m].name;
		}
		if (horizonLabelData[m].lastFound) {
			rightHorizonPt[rightCount] = horizonLabelData[m].lastY;
			rightHorizonName[rightCount++] = horizonLabelData[m].name;
		}
	}
	QuickSort2ArgInplace(leftHorizonPt, leftHorizonName, leftCount);
	QuickSort2ArgInplace(rightHorizonPt, rightHorizonName, rightCount);

	for (int j = 0; j < 2; j++) {
		int horizonMaxY = TOP;  // to prevent over plotting of the label.
		int horizonX = SIDE;
		int count;
		int* pData;
		CString* pName;
		if (j == 0) {
			// left side
			count = leftCount;
			pData = leftHorizonPt;
			pName = leftHorizonName;
		} else {
			// right side
			count = rightCount;
			pData = rightHorizonPt;
			pName = rightHorizonName;
		}
		for (int i = 0; i < count; i++) {
			int horizonY = pData[i];
			CString horName = pName[i];
			CSize extent = pDC->GetTextExtent(horName);
			CRect horItem;
			horItem.top = horizonY - DXY / 2;
			if (horItem.top < horizonMaxY) horItem.top = horizonMaxY;
			horItem.bottom = horItem.top + DXY;
			horizonMaxY = horItem.bottom;
			if (j == 0) {
				horItem.left = SIDE - extent.cx - 15;
				horItem.right = SIDE - 10;
				pDC->SelectObject(m_normPen);
				pDC->MoveTo(horItem.right, horItem.top + DXY / 2);
				pDC->LineTo(SIDE, horizonY);
			} else {
				horItem.left = SIDE + (m_nTotalTrace * m_hScale) + 10;
				horItem.right = horItem.left + extent.cx + 10;
				pDC->SelectObject(m_normPen);
				pDC->MoveTo(horItem.left, horItem.top + DXY / 2);
				pDC->LineTo(horItem.left - 10, horizonY);
			}
			CBrush hbrBkGnd;
			hbrBkGnd.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
			pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
			pDC->FillRect(horItem, &hbrBkGnd);
			pDC->FrameRect(horItem, &CBrush(RGB(0, 0, 0)));
			pDC->DrawText(horName, -1, horItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		}
	}

-----

CTraceViewInfoArray m_traceViewInfoArray;

typedef CArray <CTraceViewInfo, CTraceViewInfo> CTraceViewInfoArray;

class CTraceViewInfo
{
public:
	// Member functions
	CTraceViewInfo();
	virtual ~CTraceViewInfo();	
	int traceNumber;
	int inLine;
	int xLine;
	int xPixel;
	double xCoord;
	double yCoord;
};

		pHorizonPen[i] = new CPen(PS_SOLID, 1, horizonColor);
		if (pHorizonPen[i] == NULL) {
			CString txt;
			txt.Format("Error allocating color pen for horizon %d", i);
			AfxMessageBox(txt);
			return;
		}

	for (int i = 0, jtr = 0, trnum = firstTr; i < m_nTrace; i++, jtr++, trnum += incrementTr) {

                // ...
        }

Where:

m_nTrace = 551

-		traceViewInfo	{traceNumber=0 inLine=5450 xLine=1243 ...}	CTraceViewInfo
+		__vfptr	0x00007ff6130da2b0 {QI-Pro.exe!void(* CTraceViewInfo::`vftable'[2])()} {0x00007ff612774151 {QI-Pro.exe!CTraceViewInfo::`vector deleting destructor'(unsigned int)}}	void * *
		traceNumber	0	int
		inLine	5450	int
		xLine	1243	int
		xPixel	152	int
		xCoord	-1.0000000000000000	double
		yCoord	-1.0000000000000000	double

Next iteration of loop:

-		traceViewInfo	{traceNumber=1 inLine=5451 xLine=1243 ...}	CTraceViewInfo
+		__vfptr	0x00007ff6130da2b0 {QI-Pro.exe!void(* CTraceViewInfo::`vftable'[2])()} {0x00007ff612774151 {QI-Pro.exe!CTraceViewInfo::`vector deleting destructor'(unsigned int)}}	void * *
		traceNumber	1	int
		inLine	5451	int
		xLine	1243	int
		xPixel	156	int
		xCoord	-1.0000000000000000	double
		yCoord	-1.0000000000000000	double

			pDC->FillRect(rcItem, pTraceBrush[k]);
			rcItem.top = (int)vAccumulator;
			vAccumulator += m_vScale;
			rcItem.bottom = (int)vAccumulator;

						pDC->LineTo(traceOriginX + dx, plotY);	// draw line to this point from previous point

						// draw the fill
						if (pDoc->GetWiggleDrawingMode() == eWIGGLE_FILL) {
							if (dx > 0) {
								pDC->LineTo(traceOriginX, plotY);  // draw line to origin
								pDC->MoveTo(traceOriginX + dx, plotY);	// go back to where we started 
							}
						}

                                                
pDC->LineTo(traceOriginX + dx, plotY);

-Draw wiggle traces:

					for (int ind = 0; ind < m_sampCount; ind++) {
						float sampleValue = pWiggleData[ind];
						if (pDoc->GetWiggleClassifiedVolumeCheck()) {
							if (sampleValue == UNCLASSIFIED) {
								sampleValue = 0;
							}
							while (sampleValue >= SELECTION_BIAS) {
								sampleValue -= SELECTION_BIAS;
							}
						}

						float dx_f = 0;
						if (meanAllTraces != 0.0) dx_f = (float)(sampleValue * excursion / meanAllTraces);
						if (std::abs(dx_f) > m_hScale * pDoc->GetWiggleTraceClip()) { // check for trace clip
							if (dx_f > 0) dx_f = m_hScale * pDoc->GetWiggleTraceClip();
							else dx_f = -(m_hScale * pDoc->GetWiggleTraceClip());
						}
						dx = (int)std::round(dx_f);

						if (ind == 0) {
							pDC->MoveTo(traceOriginX + dx, plotY);
							prevDx = dx;
						}
						plotY = (DWORD)(vAccumulator);  // point to the center pixel of the sample.

						// don`t draw above or below classified area
						if (vAccumulator < TOP || vAccumulator + m_vScale > TOP + ((m_endTime * 1000 / si) * m_vScale)) {
							pDC->MoveTo(traceOriginX + dx, plotY);	// go back to where we started 
							vAccumulator += m_vScale;
							prevDx = dx;
							continue;
						}

						pDC->LineTo(traceOriginX + dx, plotY);

						// draw the fill
						if (pDoc->GetWiggleDrawingMode() == eWIGGLE_FILL && ind > 0) {
							int fillStart = (DWORD)(vAccumulator - m_vScale);
							int fillEnd = (DWORD)vAccumulator;
							plotY -= (DWORD)m_vScale; // move y back one sample
							float xIncrement = (float)(dx - prevDx) / (float)(fillEnd - fillStart);
							if (dx > 0 || prevDx > 0) {
								for (int isamp = fillStart; isamp < fillEnd; isamp++) {
									int yIncrement = (isamp - fillStart);
									int fillx = (int)std::round(((float)(isamp - fillStart) * xIncrement) + prevDx);
									if (fillx > 0) {
										pDC->MoveTo(traceOriginX, plotY + yIncrement);
										pDC->LineTo(traceOriginX + fillx, plotY + yIncrement);
									}
								}
							}
							plotY = (DWORD)(vAccumulator); // go back to correct y pos
							pDC->MoveTo(traceOriginX + dx, plotY);
						}
						vAccumulator += m_vScale;
						prevDx = dx;
					}
				}

-Draw horizon label:
                                
			CBrush hbrBkGnd;
			hbrBkGnd.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
			pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
			pDC->FillRect(horItem, &hbrBkGnd);
			pDC->FrameRect(horItem, &CBrush(RGB(0, 0, 0)));
			pDC->DrawText(horName, -1, horItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);

Where:

horName = "Muskwa"

-Draw a horizon label:

	// draw the horizon labels, sort them and plot them in order with no overlap
	for (int m = 0; m < horizonCount; m++) {
                // ...
        }

        for (int j = 0; j < 2; j++) {
                // ...
		for (int i = 0; i < count; i++) {
			int horizonY = pData[i];
			CString horName = pName[i];
			CSize extent = pDC->GetTextExtent(horName);
			CRect horItem;
			horItem.top = horizonY - DXY / 2;
			if (horItem.top < horizonMaxY) horItem.top = horizonMaxY;
			horItem.bottom = horItem.top + DXY;
			horizonMaxY = horItem.bottom;
			if (j == 0) {
				horItem.left = SIDE - extent.cx - 15;
				horItem.right = SIDE - 10;
				pDC->SelectObject(m_normPen);
				pDC->MoveTo(horItem.right, horItem.top + DXY / 2);
				pDC->LineTo(SIDE, horizonY);
			} else {
				horItem.left = SIDE + (m_nTotalTrace * m_hScale) + 10;
				horItem.right = horItem.left + extent.cx + 10;
				pDC->SelectObject(m_normPen);
				pDC->MoveTo(horItem.left, horItem.top + DXY / 2);
				pDC->LineTo(horItem.left - 10, horizonY);
			}
			CBrush hbrBkGnd;
			hbrBkGnd.CreateSolidBrush(GetSysColor(COLOR_WINDOW));
			pDC->SetBkColor(GetSysColor(COLOR_WINDOW));
			pDC->FillRect(horItem, &hbrBkGnd);
			pDC->FrameRect(horItem, &CBrush(RGB(0, 0, 0)));
			pDC->DrawText(horName, -1, horItem, DT_CENTER | DT_VCENTER | DT_SINGLELINE);
		}
            // ...                
        }                

-**** Draw actual horizon here ****:

		// Draw the horizon data
		if (pDoc->GetHorizonDisplayToggle() && horizonCount > 0 && horizonRecordCount > 0) {
			int inLine = pOutputSegy->GetInline(trnum);
			int xLine = pOutputSegy->GetCrossline(trnum);
			if (prevIndex == -1) {
				prevIndex = 0;
				if (pHorizon->FindIndex(inLine, xLine, prevIndex) < 0) prevIndex = -1;
			} else {
				if (pHorizon->FindIndex(inLine, xLine, currIndex) < 0) {
					currIndex = 0;
					prevIndex = -1;
				} else {
					// at each trace draw all the horizons from the previous trace to this one.
					if (trnum != wellTrace) {
						for (int j = 0; j < horizonCount; j++) {
							if (pHorizon->GetDisplayMode(j) == FALSE) continue;
							float* pHor = pHorizon->GetHorizonDataPtr(j);
							if (pHor[prevIndex] == NULL_HORIZON_VALUE || pHor[currIndex] == NULL_HORIZON_VALUE) {
								// TRACE("skipping j=%d previndex=%d currindex=%d\n", j, prevIndex, currIndex);
								continue;
							}
							if (flatteningOffsets[i - 1] == NULL_HORIZON_VALUE || flatteningOffsets[i] == NULL_HORIZON_VALUE) {
								continue;
							}

							float prevTime = 0;
							float currTime = 0;
							int yPrev;
							int yCurr;
							int xPrev;
							int xCurr;
							if (!pDoc->IsPetrelTimeMode()) {
								prevTime = pHor[prevIndex];
								currTime = pHor[currIndex];
							} else {
								prevTime = (int)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pHor[prevIndex];
								currTime = (int)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pHor[currIndex];
							}
							if (currTime < tstart || (tend && currTime > tend)) continue;
							prevTime -= tstart;
							currTime -= tstart;
							yPrev = TOP + ((int)((std::round(flatteningOffsets[i-1]) * 1000 / si) * m_vScale)) + (int)(prevTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
							yCurr = TOP + ((int)((std::round(flatteningOffsets[i]) * 1000 / si) * m_vScale)) + (int)(currTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
							xPrev = traceOriginX - m_hScale / 2;
							xCurr = xPrev + m_hScale;

							// to get straight line for flattened horizon
							if (pDoc->GetFlatteningDisplayToggle() && pDoc->GetFlattenHorizonCheck() && pHorizon->GetName(j) == pDoc->GetFlatteningHorizon()) {
								if (pDoc->IsPetrelTimeMode()) {
									prevTime = (float)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pDoc->GetFlatteningDatum();
									currTime = (float)pDoc->CalculatePetrelOffset(pDoc->GetPetrelDatum()) - pDoc->GetFlatteningDatum();
								}
								else {
									prevTime = (float)pDoc->GetFlatteningDatum();
									currTime = (float)pDoc->GetFlatteningDatum();
								}
								if (currTime < tstart || (tend && currTime > tend)) continue;
								prevTime -= tstart;
								currTime -= tstart;
								yPrev = TOP + (int)(prevTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
								yCurr = TOP + (int)(currTime / si * 1000 * m_vScale) + (int)(m_vScale / 2.0);
							}

							// don`t draw above or below classified area
							if (yPrev < TOP || yCurr < TOP || 
								yPrev > TOP + ((m_endTime * 1000 / si) * m_vScale) + (int)(m_vScale / 2.0) || 
								yCurr > TOP + ((m_endTime * 1000 / si) * m_vScale) + (int)(m_vScale / 2.0))
							{
								continue;
							}

							// save the label coords for later
							if (horizonLabelData[j].firstFound) {
								CString horName = pHorizon->GetName(j);
								horizonLabelData[j].name = horName;
								horizonLabelData[j].lastY = yPrev;
								horizonLabelData[j].lastFound = TRUE;
							}
							else if (!horizonLabelData[j].firstFound) {
								CString horName = pHorizon->GetName(j);
								horizonLabelData[j].name = horName;
								horizonLabelData[j].firstFound = TRUE;
								horizonLabelData[j].firstY = yPrev;
							}
							
							int lineWidth = pHorizon->GetLineWidth(j);
							yPrev -= lineWidth / 2;
							yCurr -= lineWidth / 2;
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev - 1);
							pDC->LineTo(xCurr, yCurr - 1);
							// draw color the correct width
							pDC->SelectObject(pHorizonPen[j]);
							for (int k = 0; k < lineWidth; k++) {
								pDC->MoveTo(xPrev, yPrev++);
								pDC->LineTo(xCurr, yCurr++);
							}
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev);
							pDC->LineTo(xCurr, yCurr);
						}
					}
					prevIndex = currIndex;
				}
			}
		}

                
	//	Draw the horizons and wiggle overlay
	for (int i = 0, jtr = 0, trnum = firstTr; i < m_nTrace; i++, jtr++, trnum += incrementTr) {
                // ...
        }                

                                                        else if (!horizonLabelData[j].firstFound) {
								CString horName = pHorizon->GetName(j);
								horizonLabelData[j].name = horName;
								horizonLabelData[j].firstFound = TRUE;
								horizonLabelData[j].firstY = yPrev;
							}

Where:                                                        
    horizonLabelData[j].name = " Lwr_Keg_River"                                                        

							int lineWidth = pHorizon->GetLineWidth(j);
							yPrev -= lineWidth / 2;
							yCurr -= lineWidth / 2;
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev - 1);
							pDC->LineTo(xCurr, yCurr - 1);

Where:
		j	0	int

		xCurr	158	int
		xPrev	154	int
		yCurr	578	int
		yPrev	580	int

							// draw color the correct width
							pDC->SelectObject(pHorizonPen[j]);
							for (int k = 0; k < lineWidth; k++) {
								pDC->MoveTo(xPrev, yPrev++);
								pDC->LineTo(xCurr, yCurr++);
							}
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev);
							pDC->LineTo(xCurr, yCurr);

Where:

		xCurr	158	int
		xPrev	154	int
		yCurr	580	int
		yPrev	582	int
                
prevIndex = 249406
currIndex = 250034

-----
Where:

horizonLabelData[j].name = "Mid_Dev_Carb"

		xCurr	158	int
		xPrev	154	int
		yCurr	463	int
		yPrev	464	int


-----


						// Draw TimeSlice from Maps & Timeslices dialog
						for (int j = 0; j < horizonCount; j++) {
                
void CIMACDoc::GetSliceParms(BOOL &bShow, BOOL &bLoad, int &time, CString &ref)
{
	bShow = m_timeSlice.isShowSliceFlag(); 
	bLoad = m_timeSlice.isLoadSliceFlag();
	time  = m_timeSlice.GetSliceTime(); 
	ref   = m_timeSlice.GetSliceReference();
}


        BOOL m_bShowSliceFlag;
        BOOL m_bLoadSliceFlag;
        int m_sliceTime;
        CString selectedString;
	pDoc->GetSliceParms(m_bShowSliceFlag, m_bLoadSliceFlag, m_sliceTime, selectedString);

	pDoc->GetSliceParms(bShowSliceFlag, bLoadSliceFlag, sliceTime, selectedHorizon);        

-----

       CPen greyPen, normPen, dottedPen;
       dottedPen.CreatePen(PS_DOT, 1, RGB(180, 180, 180));                                                        

	// create color pens for the corresponding horizons.
	for (int i = 0; i < horizonCount; i++) {
		if (pHorizonPen[i] != NULL) delete pHorizonPen[i];
		COLORREF horizonColor = pHorizon->GetLineColor(i);
		horizonColor &= 0x00FFFFFF; // color bits only.
		pHorizonPen[i] = new CPen(PS_SOLID, 1, horizonColor);
		if (pHorizonPen[i] == NULL) {
			CString txt;
			txt.Format("Error allocating color pen for horizon %d", i);
			AfxMessageBox(txt);
			return;
		}
	}


							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev - 1);
							pDC->LineTo(xCurr, yCurr - 1);
							// draw color the correct width
							pDC->SelectObject(pHorizonPen[j]);
							for (int k = 0; k < lineWidth; k++) {
								pDC->MoveTo(xPrev, yPrev++);
								pDC->LineTo(xCurr, yCurr++);
							}
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev);
							pDC->LineTo(xCurr, yCurr);

                                                        
	pDC->SelectObject(m_pFontSmall);
	CHorizon* pHorizon = pDoc->GetHorizonDataPtr();
	int horizonCount = pHorizon->GetHorizonCount();

	for (int i = 0; i < MAXHRZ; i++) {
		pHorizonPen[i] = NULL;
	}

-In destructor:

	for (int i = 0; i < MAXHRZ; i++) {
		if (pHorizonPen[i]) delete pHorizonPen[i];
	}
                                                        

2020.12.18
I. Researching and implementing solution:

	int          m_lineWidth[MAXHRZ];
	int          m_sliceLineWidth[MAXHRZ];

	int      GetLineWidth(int n)                 { return m_lineWidth[n]; }
	int      GetSliceLineWidth(int n)            { return m_sliceLineWidth[n]; }

	void     SetLineWidth(int n, int width)      { if (n<MAXHRZ) m_lineWidth[n]   = width; }
	
void CHrzParmDlg::GetControlData()
{
	UpdateData(TRUE);

	int nRows = m_hrzList.GetItemCount();
	for (int i=0; i<nRows; i++) {
		m_pLocalHor->SetName(i, m_hrzList.GetItemText(i, 0));
		CString txt = m_hrzList.GetItemText(i, 2);
		BOOL bdisp = (txt=="Yes");
		m_pLocalHor->SetDisplayMode(i, bdisp);
		m_pLocalHor->SetLineWidth (i, atoi(m_hrzList.GetItemText(i, 3)));
		m_pLocalHor->SetLineColor (i, m_hrzList.GetSubitemColor(1, i));
	}
}

1)

		COLORREF horizonColor = pHorizon->GetLineColor(i);
		horizonColor &= 0x00FFFFFF; // color bits only.
		
COLORREF GetLineColor(int n)                 { return m_color[n]; }

	void     SetLineColor(int n, COLORREF color) { if (n<MAXHRZ) m_color[n]       = color; }
	
void CHrzParmDlg::GetControlData()
{
	UpdateData(TRUE);

	int nRows = m_hrzList.GetItemCount();
	for (int i=0; i<nRows; i++) {
		m_pLocalHor->SetName(i, m_hrzList.GetItemText(i, 0));
		CString txt = m_hrzList.GetItemText(i, 2);
		BOOL bdisp = (txt=="Yes");
		m_pLocalHor->SetDisplayMode(i, bdisp);
		m_pLocalHor->SetLineWidth (i, atoi(m_hrzList.GetItemText(i, 3)));
		m_pLocalHor->SetLineColor (i, m_hrzList.GetSubitemColor(1, i));
	}
}

Serialize:
		if (nVersion >= 16) {
			m_pHorizon->Serialize(ar);
			if (nVersion < 24) {
				// convert color index to raw color
				for (int i=0; i<m_pHorizon->GetHorizonCount(); i++) {
					COLORREF horColor = m_pHorizon->GetLineColor(i);
					if ((int)horColor < m_nClass) {
						horColor = m_colorbar[horColor];
					} else {
						horColor = NOCOLOR;
					}
					m_pHorizon->SetLineColor(i, horColor);
				}
			}
		}
		
SeiswareImportFunctions:
	pLocalHor->SetLineColor(m_pLocalHor->GetHorizonCount() - 1, horizonModel.colour);


2)
                                                
	horColor = dlg.GetSelectedColor();
	m_pLocalHor->SetLineColor(nItem, horColor);

                                                        

	// declare some arrays to save the horizon annotation
	struct HorizonLabelData
	{
		CString	name;
		int		firstY;
		int		lastY;
		BOOL	firstFound = FALSE;
		BOOL	lastFound = FALSE;
	};
	std::vector<HorizonLabelData> horizonLabelData(horizonCount);
	int     leftHorizonPt[1000];
	CString leftHorizonName[1000];
	int     leftCount = 0;
	int     rightHorizonPt[1000];
	CString rightHorizonName[1000];
	int     rightCount = 0;

	// declare some arrays to save the time slice annotation
	struct TimeSliceLabelData
	{
		CString	name;
		int		firstY;
		int		lastY;
		BOOL	firstFound = FALSE;
		BOOL	lastFound = FALSE;
	};
	std::vector<TimeSliceLabelData> timeSliceLabelData(horizonCount);
	int     leftTimeSlicePt[1000];
	CString leftTimeSliceName[1000];
	int     leftTimeSliceCount = 0;
	int     rightTimeSlicePt[1000];
	CString rightTimeSliceName[1000];
	int     rightTimeSliceCount = 0;

        
timeSliceCount++;

								timeSliceLabelData[j].name = horName + " slice";

3)
IDC_SELECT_COLOR3                                                                
IDC_TIMESLICE1

4)
cf:
IDC_SELECT_COLOR1
IDC_EDITWELL

m_wellWidth
COLORREF	selectColor1;
CColorButton m_highlightColor1;
float		timeSliceWidth;
COLORREF    timeSliceColor1;

                
CColorButton m_timeSliceColor1;
m_timeSliceWidth = 2;
CColorButton m_timeSliceColor1;
COLORREF m_timeSliceSelectColor1;

-----

void CClassifiedVolumeDisplaySettingsDlg::OnClickedSelectColor1()
{
	CGetColorDlg dlg;
	dlg.SetSelectedColor(m_selectColor1);
	if (dlg.DoModal() != IDOK) return;

	m_selectColor1 = dlg.GetSelectedColor();
	m_highlightColor1.SetColor(m_selectColor1);
}

OnClickedSelectTimeSliceColor1

-----

    COLORREF m_selectColor1;

#define IDC_EDITWELL                    1023
m_wellWidth

m_fWellWidth

float GetWellWidth() { return m_fWellWidth; }

int CIMACDoc::GetWellWidthPixels(CWell *pWell)
{ 
	float width = 0;
	if (pWell != NULL && pWell->GetCurveWidth() > 0) {
		width = pWell->GetCurveWidth();
	} else {
		width = m_fWellWidth;
	}
	return (int) (width * (float)DPI);
}

-----

QI-Pro.exe has triggered a breakpoint.

		// Could be a windowless OCX
		pSite = m_pDlgWnd->GetOleControlSite(nIDC);
		if (pSite == NULL)
		{
			TRACE(traceAppMsg, 0, "Error: no data exchange control with ID 0x%04X.\n", nIDC);
			ASSERT(FALSE);
			AfxThrowNotSupportedException();
		}

nIDC = 1508
#define IDC_TIMESLICE1                  1508



IDC_TIMESLICE1
m_timeSliceWidth
float m_fTimeSlice1Width;


m_timeSliceSelectColor1

m_fTimeSlice1Width

	CVDisplaySettingsDlg.m_timeSliceSelectColor1 = pDoc->GetTimeSliceColor1();
	CVDisplaySettingsDlg.m_timeSlice1Width = pDoc->GetTimeSlice1Width();

m_timeSliceSelectColor1 = 3452816845

m_timeSlice1Width = -431602080.

	DDX_Text(pDX, IDC_EDITWELL, m_wellWidth);
	DDV_MinMaxFloat(pDX, m_wellWidth, 0, 10);
	DDX_Text(pDX, IDC_EDITTIMESLICE1, m_timeSlice1Width);
	//DDV_MinMaxFloat(pDX, m_timeSlice1Width, 0, 2147483647);

        
-4.31602e+08

SavedState.selectColor1 = m_selectColor1;
SavedState.wellWidth = m_wellWidth;

	SavedState.timeSliceWidth = m_timeSlice1Width;
	SavedState.timeSliceColor1 = m_timeSliceSelectColor1;

        
class CPlotParmData : public CObject
{
public:
	CPlotParmData();
	virtual ~CPlotParmData();
	virtual void Serialize(CArchive& ar);

	int		m_dispLine;
	eLineMode m_inlineXlineMode;
	int		m_horizontalScale;
	float	m_verticalScale;
	int		m_startTime;
	int		m_endTime;
	int		m_10msTLineMode;
	int		m_100msTLineMode;
	int		m_500msTLineMode;
	int		m_cursorPositionMode;
	int		m_wellWidth;
	int		m_timeSliceWidth;
};

debug assertion failed program mfc140d.dll dlgdata.cpp

2020.12.21
I. Researching and implementing solution:

int nThisVersion = 80;

"Classified Seismic Volume Display Settings"

IDC_EDITTIMESLICE1 - "Time Slice Width"

	DDX_Text(pDX, IDC_EDITTIMESLICE1, m_timeSlice1Width);
	//DDV_MinMaxFloat(pDX, m_timeSlice1Width, 0, 2147483647);

    EDITTEXT        IDC_EDITTIMESLICE1,441,191,46,12,ES_RIGHT | ES_AUTOHSCROLL | WS_GROUP
    LTEXT           "Time Slice Width:",IDC_STATIC,374,191,63,12,SS_CENTERIMAGE

#define IDC_EDITTIMESLICE1              1506    

float   m_timeSlice1Width;

-----

"Horizon Flattening":
IDC_FLATTENING_DATUM - "Datum"

DDX_Text(pDX, IDC_FLATTENING_DATUM, m_flatteningDatum);
DDX_Control(pDX, IDC_FLATTENING_DATUM, m_flatteningDatumControl);


    EDITTEXT        IDC_FLATTENING_DATUM,406,140,41,12,ES_RIGHT | ES_AUTOHSCROLL

#define IDC_FLATTENING_DATUM            
    
int		m_flatteningDatum;
CEdit m_flatteningDatumControl;

Code	File	Line	Column
	m_flatteningDatum = 0;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	60	2
	DDX_Text(pDX, IDC_FLATTENING_DATUM, m_flatteningDatum);	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	118	38
	SavedState.flatteningDatum = m_flatteningDatum;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	380	31
	m_flatteningDatum = SavedState.flatteningDatum;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	419	2
	pDoc->SetFlatteningDatum(m_flatteningDatum);	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	517	27
		m_flatteningDatum = (int)CalculateHorizonAverage(m_horizon);	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	626	3
		m_flatteningDatum = (int)CalculateHorizonAverage(m_horizon);	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	637	3
	int		m_flatteningDatum;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.h	71	7
	m_flatteningDatum = 0;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACDoc.cpp	257	2
		ar << m_flatteningDatum;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACDoc.cpp	499	9
			ar >> m_flatteningDatum;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACDoc.cpp	1060	10
			m_flatteningDatum = 0;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACDoc.cpp	1066	4
    void SetFlatteningDatum(int n) { m_flatteningDatum = n;}	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACDoc.h	249	38
    int GetFlatteningDatum() { return  m_flatteningDatum; }	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACDoc.h	382	40
    int	m_flatteningDatum;	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACDoc.h	825	9
	CVDisplaySettingsDlg.m_flatteningDatum = pDoc->GetFlatteningDatum();	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACView.cpp	2853	23
	pDoc->SetFlatteningDatum(CVDisplaySettingsDlg.m_flatteningDatum);	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMACView.cpp	2948	48

        
void CClassifiedVolumeDisplaySettingsDlg::OnClickedHorizonAverageCheck()
{

	UpdateData(TRUE);
	if (m_useAverage) {
		m_flatteningDatumControl.EnableWindow(FALSE); 
		m_flatteningDatum = (int)CalculateHorizonAverage(m_horizon);
	}
	else m_flatteningDatumControl.EnableWindow(TRUE);
	UpdateData(FALSE);
}

void CClassifiedVolumeDisplaySettingsDlg::OnSelchangeHorizonList()
{
	UpdateData(TRUE);
	if (m_useAverage) {
		m_flatteningDatum = (int)CalculateHorizonAverage(m_horizon);
		}
	UpdateData(FALSE);
}

void CCSIViewParmDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	DDX_Text(pDX, IDC_HSCALE, m_horizontalScale);
	DDX_Text(pDX, IDC_VSCALE, m_verticalScale);
	DDX_Text(pDX, IDC_STIME, m_startTime);
	DDX_Text(pDX, IDC_ETIME, m_endTime);
	DDX_Text(pDX, IDC_CBMAX, m_colorBarMax);
	DDX_Text(pDX, IDC_CBMIN, m_colorBarMin);
	DDX_Check(pDX, IDC_10MIL, m_10msTLineMode);
	DDX_Check(pDX, IDC_CURSOR, m_cursorPositionMode);
	DDX_Text(pDX, IDC_WELLWIDTH, m_wellWidth);
	DDV_MinMaxInt(pDX, m_wellWidth, 1, 20);
}

CVDisplaySettingsDlg.m_timeSlice1Width = 2

-> Somehow setting to overflow value on this line:  ***

	CVDisplaySettingsDlg.m_timeSlice1Width = pDoc->GetTimeSlice1Width();

-----

IDC_STATIC32:

Code	File	Line	Column
    LTEXT           "Well Curve Line:",IDC_STATIC,194,154,63,12,SS_CENTERIMAGE	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1648	22

IDC_CURVE_BOLD

Code	File	Line	Column
    CONTROL         "Bold",IDC_CURVE_BOLD,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,267,156,29,12	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1600	28

DDX_Radio(pDX, IDC_CURVE_BOLD, m_bWellBoldPen);    

BOOL	m_bWellBoldPen;

DDX_Radio(pDX, IDC_CURVE_BOLD, m_bWellBoldPen);

-----
    
Code	File	Line	Column
    LTEXT           "Time Slice Color:",IDC_STATIC,374,176,63,14,SS_CENTERIMAGE	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1658	22
    
Code	File	Line	Column
    LTEXT           "Time Slice Width:",IDC_STATIC,374,191,63,12,SS_CENTERIMAGE	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1660	22

Code	File	Line	Column
    LTEXT           "Time Slice:",IDC_STATIC,374,206,63,12,SS_CENTERIMAGE	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1664	22

Time Slice On:
IDC_TIMESLICE_ON

Time Slice Off:
IDC_TIMESLICE_OFF

BOOL	m_bTimeSliceOn;

void SetTimeSliceOn(BOOL bSliceOn) { m_bTimeSliceOn = bSliceOn; }
BOOL GetTimeSlice() { return m_bTimeSliceOn; }

ar<<m_selectColor1;

-----

pDoc->SetTimeSliceColor1(CVDisplaySettingsDlg.m_timeSliceSelectColor1);

CVDisplaySettingsDlg.m_timeSliceSelectColor1 = 16777215

-----

IDC_SELECT_COLOR1    
Code	File	Line	Column
    LTEXT           "Highlight Color 1:",IDC_STATIC,194,19,63,14,SS_CENTERIMAGE	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1635	22


	CVDisplaySettingsDlg.m_timeSliceSelectColor1 = pDoc->GetTimeSliceColor1();
	CVDisplaySettingsDlg.m_timeSlice1Width = pDoc->GetTimeSlice1Width();
	CVDisplaySettingsDlg.m_bTimeSliceOn = pDoc->GetIsTimeSliceOn();

	pDoc->SetTimeSlice1Width(CVDisplaySettingsDlg.m_timeSlice1Width);
	pDoc->SetTimeSliceColor1(CVDisplaySettingsDlg.m_timeSliceSelectColor1);
	pDoc->SetTimeSliceOn(CVDisplaySettingsDlg.m_bTimeSliceOn);


							if (!bShowSliceFlag || !bCvSettingsShowTimeSlice) {
								continue;
							}
                                                        
SavedState.timeSliceOn = m_bTimeSliceOn;

CClassifiedVolumeDisplaySettingsDlg:: OnClickedApply(): Missing setter for m_bTimeSliceOn:


pDoc->SetTimeSliceOn(CVDisplaySettingsDlg.m_bTimeSliceOn);
CVDisplaySettingsDlg.m_bTimeSliceOn = 0


		pDoc->m_bTimeSliceOn	1	int

pDoc->SetTimeSliceOn(!CVDisplaySettingsDlg.m_bTimeSliceOn);

-----

pHorizonPen[i] = new CPen(PS_SOLID, 1, horizonColor);

horizonColor = 16720016

pTimeSlicePen[i] = new CPen(PS_DOT, timeSlicePenWidth, timesliceColor);

timeSlicePenWidth = 2
timesliceColor = 16719872

BOOL bCvSettingsShowTimeSlice = pDoc->GetIsTimeSliceOn();

int lineWidth = pTimeSlice->GetSliceLineWidth(j);
lineWidth = -842150451

-----

IDC_HIGHLIGHT_FILT

Code	File	Line	Column
    CONTROL         "Filtered",IDC_HIGHLIGHT_FILT,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,305,67,39,14	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1596	32

IDC_HIGHLIGHT_ALL    
-> Only in resources.h

Code	File	Line	Column
    CONTROL         "Normal",IDC_CURVE_NORM,"Button",BS_AUTORADIOBUTTON | WS_TABSTOP,305,156,39,12	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1601	30

Code	File	Line	Column
    CONTROL         "Bold",IDC_CURVE_BOLD,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,267,156,29,12	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1600	28    

Code	File	Line	Column
    CONTROL         "On",IDC_TIMESLICE_ON,"Button",BS_AUTORADIOBUTTON | WS_GROUP | WS_TABSTOP,441,208,29,12	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\IMAC.rc	1662	26

Code	File	Line	Column
	DDX_Radio(pDX, IDC_CURVE_BOLD, m_bWellBoldPen);	C:\Sound-QI_Source\SoundQI-Branch\RM_Branch\IMAC\ClassifiedVolumeDisplaySettingsDlg.cpp	96	17

        
-----

What is the difference between?

CCSIViewParmDlg dlg;

And:

...

2021.01.04
I. Researching and implementing solution:

-Need to also add time slice relative to "Time Zero":

CSI:
	// Depending if there is a reference horizon the reference time will be absolute or relative.
	// find index of reference horizon
	if (strReference != CHorizon::TIME_ZERO && pHorizon->GetHorizonCount() > 0) {
		int j = 0;
		while (j < pHorizon->GetHorizonCount() && pHorizon->GetName(j) != strReference) j++;
		if (j < pHorizon->GetHorizonCount()) horIndex = j;
	}
	// reference horizon not found, so reset to default.
	if (horIndex == -1) {
		strReference = CHorizon::TIME_ZERO;
		pTimeSlice->SetSliceReference(strReference);
	} else {
		pHor = pHorizon->GetHorizonDataPtr(horIndex);
	}

const CString CHorizon::TIME_ZERO =	"Time Zero";

	m_sliceTime  = 0;
	m_sliceReference = CHorizon::TIME_ZERO;
	m_bShowSliceFlag = FALSE;

IMAC:
void CIMACDoc::ValidateZones()
{
	// loop backwards so removing zones doesn`t mess us up.
	for(int i = (int) m_viewZoneArray.GetCount()-1; i >= 0; i--) {
		CViewZone zone = m_viewZoneArray[i];
		CString topHorizon = zone.GetZoneTopReference();
		CString bottomHorizon = zone.GetZoneBottomReference();
		if(!m_pHorizon->Contains(topHorizon) && topHorizon != CHorizon::TIME_ZERO) {
			TRACE("Removed Zone '%s' because reference to top Horizon '%s' is invalid.\n", zone.GetZoneName(), topHorizon);
			m_viewZoneArray.RemoveAt(i);
			SetUpdateXplotPaneFlagsAll(TRUE);
		} else if(!m_pHorizon->Contains(bottomHorizon) && bottomHorizon != CHorizon::TIME_ZERO) {
			TRACE("Removed Zone '%s' because reference to bottom Horizon '%s' is invalid.\n", zone.GetZoneName(), bottomHorizon);
			m_viewZoneArray.RemoveAt(i);
			SetUpdateXplotPaneFlagsAll(TRUE);
		}
	}
}

void CIMACDoc::ValidateTimeslice()
{
	CString horizon = m_timeSlice.GetSliceReference();
	if(!m_pHorizon->Contains(horizon) && horizon != CHorizon::TIME_ZERO) {
		TRACE("Removed Timeslice because reference to Horizon '%s' is invalid.\n", horizon);
		m_timeSlice.Destroy();
		m_timeSlice.Initalize();
		m_timeSlice.SetShowSliceFlag(FALSE);
		m_timeSlice.SetActiveFlag(FALSE);
	}
}

BOOL CMapSelectDlg::ValidateSliceTime()
{
	BOOL bReturn = TRUE;
	CString sliceReference;
	m_cmbSlice.GetLBText(m_cmbSlice.GetCurSel(), sliceReference);
	if ((sliceReference == CHorizon::TIME_ZERO) &&
		(m_sliceTime < pDoc->GetStartTime() ||
		m_sliceTime > pDoc->GetEndTime())) {
		AfxMessageBox("The request time slice falls outside the start/end time of the classified volume.");
		bReturn = FALSE;
	}
	
	return bReturn;
}

// reset the controls according to the document settings.
void CMapSelectDlg::UpdateControls()
{
	if (m_cmbSlice.m_hWnd == NULL) {
		TRACE("Error updating Time Slice Relative To combo box. Invalid window handle.\n");
		return;	// The dialog has probably been closed.
	}

	// time slice combo
	m_cmbSlice.ResetContent();  // this line of code breaks the redraw of the crossplot views.  See bug 237
	CString selectedString;
	pDoc->GetSliceParms(m_bShowSliceFlag, m_bLoadSliceFlag, m_sliceTime, selectedString);
	CString defaultString = CHorizon::TIME_ZERO;
	m_cmbSlice.AddString(defaultString);
	CHorizon *pHor = pDoc->GetHorizonDataPtr();
	for (int i=0; i<pHor->GetHorizonCount(); i++) {
		CString horizonName = pHor->GetName(i);
		m_cmbSlice.AddString(horizonName);
	}
	if (m_cmbSlice.SelectString(-1, selectedString) == CB_ERR) {
		TRACE("Error updating Time Slice Relative To combo box. Unable to select '%s'.\n", selectedString);
		m_cmbSlice.SelectString(-1, defaultString);
	}

	// enable/disable controls
	m_btnSliceButton.EnableWindow(m_bShowSliceFlag);


	// inline crossline mode
	m_selectMode = pDoc->GetInlineXlineMode();
	if (m_selectMode == eUSERLINE) {
		m_cmbUserLine.EnableWindow(TRUE);
		m_checkShowAllUserLines.EnableWindow(TRUE);
	}
	else {
		m_cmbUserLine.EnableWindow(FALSE);
		m_checkShowAllUserLines.EnableWindow(FALSE);
	}

	// if the userline data isn't loaded get it now.
	if (m_selectMode==eUSERLINE && pDoc->GetUserLineCount() > 0 && m_mapView.GetUserLine()->GetCount() == 0) {
		DWORD iLine = pDoc->GetSelectedUserLineNumber();
		SetUserLineData(iLine);
	}
	// detect if we've switched out of userline mode, if so remove the local data
	if (m_selectMode!=eUSERLINE && m_mapView.GetUserLine()->GetCount() > 0) {
		ClearUserLineData();
	}

	// user line combo box
	m_cmbUserLine.ResetContent();
	DWORD userLineCount = pDoc->GetUserLineCount();
	for (DWORD i=0; i<userLineCount; i++) {
		m_cmbUserLine.AddString(pDoc->GetUserLineName( i ));
	}

	int iSelect = pDoc->GetSelectedUserLineNumber();
	m_cmbUserLine.SetCurSel(iSelect);

	// user line list control
	m_mapList.DeleteAllItems();
	CPointArray *pLocalData = m_mapView.GetUserLine();
	for (int i=0; i<pLocalData->GetCount(); i++) {
		CPoint pt = pLocalData->GetAt(i);
		AddItemToListCtrl(i, pt.x, pt.y);
	}
	UpdateData(FALSE);
}

BOOL CNewZoneDlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();
	char buf[128];
	m_zoneBottom = _itoa(m_viewZone.GetZoneBottom(), buf, 10);
	m_zoneTop = _itoa(m_viewZone.GetZoneTop(), buf, 10);
	m_zoneName = m_viewZone.GetZoneName();

	CIMACDoc *pDoc = CIMACDoc::GetIMACDocPtr();
	CHorizon *pHor = pDoc->GetHorizonDataPtr();
	CString defaultString = CHorizon::TIME_ZERO;
	m_zoneBottomCombo.AddString(defaultString);
	m_zoneTopCombo.AddString(defaultString);
	for (int i=0; i<pHor->GetHorizonCount(); i++) {
		CString horizonName = pHor->GetName(i);
		m_zoneBottomCombo.AddString(horizonName);
		m_zoneTopCombo.AddString(horizonName);
	}

	if (m_zoneBottomCombo.SelectString(0, m_viewZone.GetZoneBottomReference()) == CB_ERR) {
		m_zoneBottomCombo.SelectString(0, defaultString);
	}
	if (m_zoneTopCombo.SelectString(0, m_viewZone.GetZoneTopReference()) == CB_ERR) {
		m_zoneTopCombo.SelectString(0, defaultString);
	}

	UpdateData(FALSE);

	return TRUE; 
}

--------------------------------------------------------------------------------

							// save the label coords for later
							if (timeSliceLabelData[j].firstFound) {
								CString horName = pHorizon->GetName(j);
								timeSliceLabelData[j].name = horName + " slice";
								timeSliceLabelData[j].lastY = yPrev;
								timeSliceLabelData[j].lastFound = TRUE;
							}
							else if (!timeSliceLabelData[j].firstFound) {
								CString horName = pHorizon->GetName(j);
								timeSliceLabelData[j].name = horName + " slice";
								timeSliceLabelData[j].firstFound = TRUE;
								timeSliceLabelData[j].firstY = yPrev;
							}

                                                        if (selectedHorizon != horizonLabelData[j].name) {
                                                                continue;
                                                        }
                            
							int lineWidth = pTimeSlice->GetSliceLineWidth(j);
							yPrev += sliceTime;
							yPrev -= lineWidth / 2;
							yCurr += sliceTime;
							yCurr -= lineWidth / 2;
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev - 1);
							pDC->LineTo(xCurr, yCurr - 1);
							// draw color the correct width
							pDC->SelectObject(pTimeSlicePen[j]);
							for (int k = 0; k < lineWidth; k++) {
								pDC->MoveTo(xPrev, yPrev++);
								pDC->LineTo(xCurr, yCurr++);
							}
							// white
							pDC->SelectObject(m_whitePen);
							pDC->MoveTo(xPrev, yPrev);
							pDC->LineTo(xCurr, yCurr);

http://sqi009:8080/tfs/DefaultCollection/SoundQI-Branch/_versionControl/changeset/818